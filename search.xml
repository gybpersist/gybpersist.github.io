<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构十一（快速排序QuickSort）</title>
      <link href="/2025/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%E4%B8%80%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FQuickSort%EF%BC%89/"/>
      <url>/2025/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%E4%B8%80%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FQuickSort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录key，key一般都是最左边，目的就是为了把key排到正确的位置，同时将key设为坑位<br>开始坑在左边，右边开始找值补坑，right找到比key小的值，放入坑位，right形成新的坑<br>现在坑在右边，左边开始找值补坑，left找到比key大的值，放入坑位，left形成新的坑<br>直到left和right相遇就结束，最后把key放到坑位，key就排到正确的位置</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%E4%B8%80%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FQuickSort%EF%BC%89/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序" title="快速排序"></p><p>More info: <a href="https://github.com/gybpersist/QuickSort">QuickSort</a></p><h2 id="快速排序（QuickSort）"><a href="#快速排序（QuickSort）" class="headerlink" title="快速排序（QuickSort）"></a>快速排序（QuickSort）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">bool QuickSort(int buf[],int begin,int end)</span><br><span class="line">&#123;</span><br><span class="line">    //备份关键元素</span><br><span class="line">    int temp = 0;</span><br><span class="line"></span><br><span class="line">    //备份首元素下标，尾元素下标</span><br><span class="line">    int left = begin,right = end;</span><br><span class="line"></span><br><span class="line">    //1 避免元素为空</span><br><span class="line">    if(begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        //备份关键元素(把首元素先作为关键元素)</span><br><span class="line">        temp = buf[begin];</span><br><span class="line"></span><br><span class="line">        //当左右找到相同元素是停止</span><br><span class="line">        while (left != right)</span><br><span class="line">        &#123;</span><br><span class="line">            //先是从右向左找 找到比关键元素大的，不交换，然后向左移动（h--）,直到找到比关键元素小的</span><br><span class="line">            while (left &lt; right &amp;&amp; buf[right] &gt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断左右两边是否指到同一个位置，不是则把 比关键元素小的元素放到关键元素位置上</span><br><span class="line">            if(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                //比关键元素小的元素放到关键元素位置上</span><br><span class="line">                buf[left] = buf[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //然后是从左向右找 找到比关键元素小的，不交换，然后向左移动（right--）,直到找到比关键元素小的</span><br><span class="line">            while (left &lt; right &amp;&amp; buf[left] &lt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断左右两边是否指到同一个位置，不是则把 比关键元素大的元素放到关键元素位置上</span><br><span class="line">            if(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                //比关键元素小的元素放到关键元素位置上</span><br><span class="line">                buf[right] = buf[left];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //左右两边指到同一个位置(buf[left] = buf[right]) 把关键元素放到这个位置上</span><br><span class="line">        buf[left] = temp;</span><br><span class="line"></span><br><span class="line">        //在基准元素归位之后，数组被分成了两个子数组：</span><br><span class="line">        //左子数组：从begin到left - 1</span><br><span class="line">        //右子数组：从left + 1到end</span><br><span class="line"></span><br><span class="line">        //随后，对这两个子数组分别调用QuickSort函数进行递归排序：</span><br><span class="line">        //对左子数组进行排序</span><br><span class="line">        QuickSort(buf,begin,left-1);</span><br><span class="line"></span><br><span class="line">        //右子数组进行排序</span><br><span class="line">        QuickSort(buf,left+1,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素（Prin）"><a href="#遍历元素（Prin）" class="headerlink" title="遍历元素（Prin）"></a>遍历元素（Prin）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool Prin(int buf[],int size)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Element:&quot;);</span><br><span class="line">    for(int i= 0;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个数组 10个整数</span><br><span class="line">    int buf[10]=&#123;2,4,1,6,8,2,6,1,7,4&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    QuickSort(buf, 0,9);</span><br><span class="line"></span><br><span class="line">    Prin(buf,sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element:2  4  1  6  8  2  6  1  7  4</span><br><span class="line">Element:1  1  2  2  4  4  6  6  7  8</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">//记录key，key一般都是最左边，目的就是为了把key排到正确的位置，同时将key设为坑位</span><br><span class="line">//开始坑在左边，右边开始找值补坑，right找到比key小的值，放入坑位，right形成新的坑</span><br><span class="line">//现在坑在右边，左边开始找值补坑，left找到比key大的值，放入坑位，left形成新的坑</span><br><span class="line">//直到left和right相遇就结束，最后把key放到坑位，key就排到正确的位置</span><br><span class="line"></span><br><span class="line">// 快速排序</span><br><span class="line">bool QuickSort(int buf[],int begin,int end)</span><br><span class="line">&#123;</span><br><span class="line">    //备份关键元素</span><br><span class="line">    int temp = 0;</span><br><span class="line"></span><br><span class="line">    //备份首元素下标，尾元素下标</span><br><span class="line">    int left = begin,right = end;</span><br><span class="line"></span><br><span class="line">    //1 避免元素为空</span><br><span class="line">    if(begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        //备份关键元素(把首元素先作为关键元素)</span><br><span class="line">        temp = buf[begin];</span><br><span class="line"></span><br><span class="line">        //当左右找到相同元素是停止</span><br><span class="line">        while (left != right)</span><br><span class="line">        &#123;</span><br><span class="line">            //先是从右向左找 找到比关键元素大的，不交换，然后向左移动（h--）,直到找到比关键元素小的</span><br><span class="line">            while (left &lt; right &amp;&amp; buf[right] &gt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断左右两边是否指到同一个位置，不是则把 比关键元素小的元素放到关键元素位置上</span><br><span class="line">            if(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                //比关键元素小的元素放到关键元素位置上</span><br><span class="line">                buf[left] = buf[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //然后是从左向右找 找到比关键元素小的，不交换，然后向左移动（right--）,直到找到比关键元素小的</span><br><span class="line">            while (left &lt; right &amp;&amp; buf[left] &lt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断左右两边是否指到同一个位置，不是则把 比关键元素大的元素放到关键元素位置上</span><br><span class="line">            if(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                //比关键元素小的元素放到关键元素位置上</span><br><span class="line">                buf[right] = buf[left];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //左右两边指到同一个位置(buf[left] = buf[right]) 把关键元素放到这个位置上</span><br><span class="line">        buf[left] = temp;</span><br><span class="line"></span><br><span class="line">        //在基准元素归位之后，数组被分成了两个子数组：</span><br><span class="line">        //左子数组：从begin到left - 1</span><br><span class="line">        //右子数组：从left + 1到end</span><br><span class="line"></span><br><span class="line">        //随后，对这两个子数组分别调用QuickSort函数进行递归排序：</span><br><span class="line">        //对左子数组进行排序</span><br><span class="line">        QuickSort(buf,begin,left-1);</span><br><span class="line"></span><br><span class="line">        //右子数组进行排序</span><br><span class="line">        QuickSort(buf,left+1,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历元素</span><br><span class="line">bool Prin(int buf[],int size)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Element:&quot;);</span><br><span class="line">    for(int i= 0;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个数组 10个整数</span><br><span class="line">    int buf[10]=&#123;2,4,1,6,8,2,6,1,7,4&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    QuickSort(buf, 0,9);</span><br><span class="line"></span><br><span class="line">    Prin(buf,sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 十一 快速排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构—快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构十（选择排序SelectSort）</title>
      <link href="/2025/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8FSelectSort%EF%BC%89/"/>
      <url>/2025/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8FSelectSort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>选择排序 从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8FSelectSort%EF%BC%89/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序" title="选择排序"></p><p>More info: <a href="https://github.com/gybpersist/SelectSort">SelectSort</a></p><h2 id="选择排序（SelectSort）"><a href="#选择排序（SelectSort）" class="headerlink" title="选择排序（SelectSort）"></a>选择排序（SelectSort）</h2><h3 id="选择排序-从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序"><a href="#选择排序-从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序" class="headerlink" title="选择排序 从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序"></a>选择排序 从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bool SelectSort(int buf[],int bufsize)</span><br><span class="line">&#123;</span><br><span class="line">    //备份交换元素</span><br><span class="line">    int temp = 0;</span><br><span class="line"></span><br><span class="line">    //1 通过线性查找找到最小元素，需要比较 n-1 轮（最后一轮不用排）</span><br><span class="line">    for (int n = 0; n &lt; bufsize-1; ++n)</span><br><span class="line">    &#123;</span><br><span class="line">        //假设每轮序列中第一个元素为最小</span><br><span class="line">        int min = n;</span><br><span class="line"></span><br><span class="line">        //找到最小元素的下标（m=n为自己和自己比,可以优化掉）</span><br><span class="line">        for (int m = n+1; m &lt; bufsize; ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            //比较找到最小元素下标</span><br><span class="line">            if(buf[min] &gt; buf[m])</span><br><span class="line">            &#123;</span><br><span class="line">                //更新最小值下标</span><br><span class="line">                min = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //把最小元素放到前面（交换元素）</span><br><span class="line">        temp = buf[n];</span><br><span class="line">        buf[n] = buf[min];</span><br><span class="line">        buf[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素（Prin）"><a href="#遍历元素（Prin）" class="headerlink" title="遍历元素（Prin）"></a>遍历元素（Prin）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool Prin(int buf[],int size)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Element:&quot;);</span><br><span class="line">    for(int i= 0;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个数组 10个整数</span><br><span class="line">    int buf[10]=&#123;2,4,1,6,8,2,6,1,7,4&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    SelectSort(buf, sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element:2  4  1  6  8  2  6  1  7  4</span><br><span class="line">Element:1  1  2  2  4  4  6  6  7  8</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">// 选择排序 从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序</span><br><span class="line">bool SelectSort(int buf[],int bufsize)</span><br><span class="line">&#123;</span><br><span class="line">    //备份交换元素</span><br><span class="line">    int temp = 0;</span><br><span class="line"></span><br><span class="line">    //1 通过线性查找找到最小元素，需要比较 n-1 轮（最后一轮不用排）</span><br><span class="line">    for (int n = 0; n &lt; bufsize-1; ++n)</span><br><span class="line">    &#123;</span><br><span class="line">        //假设每轮序列中第一个元素为最小</span><br><span class="line">        int min = n;</span><br><span class="line"></span><br><span class="line">        //找到最小元素的下标（m=n为自己和自己比,可以优化掉）</span><br><span class="line">        for (int m = n+1; m &lt; bufsize; ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            //比较找到最小元素下标</span><br><span class="line">            if(buf[min] &gt; buf[m])</span><br><span class="line">            &#123;</span><br><span class="line">                //更新最小值下标</span><br><span class="line">                min = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //把最小元素放到前面（交换元素）</span><br><span class="line">        temp = buf[n];</span><br><span class="line">        buf[n] = buf[min];</span><br><span class="line">        buf[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历元素</span><br><span class="line">bool Prin(int buf[],int size)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Element:&quot;);</span><br><span class="line">    for(int i= 0;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个数组 10个整数</span><br><span class="line">    int buf[10]=&#123;2,4,1,6,8,2,6,1,7,4&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    SelectSort(buf, sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 十 选择排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构—选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构九（冒泡排序BubbleSort）</title>
      <link href="/2025/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8FBubbleSort%EF%BC%89/"/>
      <url>/2025/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8FBubbleSort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>插入排序 是把无序序列依次插入到有序序列，一般是从尾部开始比较</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8FBubbleSort%EF%BC%89/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序" title="插入排序"></p><p>More info: <a href="https://github.com/gybpersist/BubbleSort">BubbleSort</a></p><h2 id="冒泡排序（BubbleSort）"><a href="#冒泡排序（BubbleSort）" class="headerlink" title="冒泡排序（BubbleSort）"></a>冒泡排序（BubbleSort）</h2><h3 id="元素两两之间进行交换，需要比较n轮-n初值为1-，每轮需要-bufsize-n-次-从左到右比较，升序"><a href="#元素两两之间进行交换，需要比较n轮-n初值为1-，每轮需要-bufsize-n-次-从左到右比较，升序" class="headerlink" title="元素两两之间进行交换，需要比较n轮(n初值为1)，每轮需要 bufsize-n 次(从左到右比较，升序)"></a>元素两两之间进行交换，需要比较n轮(n初值为1)，每轮需要 bufsize-n 次(从左到右比较，升序)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool BubbleSort(int buf[],int bufsize)</span><br><span class="line">&#123;</span><br><span class="line">    //备份元素 临时存储交换值</span><br><span class="line">    int temp=0;</span><br><span class="line"></span><br><span class="line">    //1 循环比较元素，比较的第n轮，总共需要比较(bufsize-1)轮</span><br><span class="line">    for (int n = 1; n &lt; bufsize; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        //每轮比较中需要 两两比较 的次数为（n=1 两两比较bufsize-1次；n=2 两两比较bufsize-2次...）</span><br><span class="line">        for (int m = 0 ; m &lt; bufsize-n ; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            //两两比较</span><br><span class="line">            if(buf[m] &gt; buf[m+1])</span><br><span class="line">            &#123;</span><br><span class="line">                temp=buf[m];</span><br><span class="line">                buf[m]=buf[m+1];</span><br><span class="line">                buf[m+1]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素（Prin）"><a href="#遍历元素（Prin）" class="headerlink" title="遍历元素（Prin）"></a>遍历元素（Prin）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool Prin(int buf[],int size)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Element:&quot;);</span><br><span class="line">    for(int i= 0;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个数组 10个整数</span><br><span class="line">    int buf[10]=&#123;2,4,1,6,8,2,6,1,7,4&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    BubbleSort(buf, sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element:2  4  1  6  8  2  6  1  7  4</span><br><span class="line">Element:1  1  2  2  4  4  6  6  7  8</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">// 冒泡排序 是元素两两之间进行交换，需要比较n轮（n初值为1），每轮需要 bufsize-n 次(从左到右比较，升序)</span><br><span class="line">bool BubbleSort(int buf[],int bufsize)</span><br><span class="line">&#123;</span><br><span class="line">    //备份元素 临时存储交换值</span><br><span class="line">    int temp=0;</span><br><span class="line"></span><br><span class="line">    //1 循环比较元素，比较的第n轮，总共需要比较(bufsize-1)轮</span><br><span class="line">    for (int n = 1; n &lt; bufsize; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        //每轮比较中需要 两两比较 的次数为（n=1 两两比较bufsize-1次；n=2 两两比较bufsize-2次...）</span><br><span class="line">        for (int m = 0 ; m &lt; bufsize-n ; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            //两两比较</span><br><span class="line">            if(buf[m] &gt; buf[m+1])</span><br><span class="line">            &#123;</span><br><span class="line">                temp=buf[m];</span><br><span class="line">                buf[m]=buf[m+1];</span><br><span class="line">                buf[m+1]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历元素</span><br><span class="line">bool Prin(int buf[],int size)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Element:&quot;);</span><br><span class="line">    for(int i= 0;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个数组 10个整数</span><br><span class="line">    int buf[10]=&#123;2,4,1,6,8,2,6,1,7,4&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    BubbleSort(buf, sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 九 冒泡排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构—冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构八（插入排序InsertSort）</title>
      <link href="/2025/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%EF%BC%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8FInsertSort%EF%BC%89/"/>
      <url>/2025/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%EF%BC%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8FInsertSort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>插入排序 是把无序序列依次插入到有序序列，一般是从尾部开始比较</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%EF%BC%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8FInsertSort%EF%BC%89/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg" alt="插入排序" title="插入排序"></p><p>More info: <a href="https://github.com/gybpersist/InsertSort">InsertSort</a></p><h2 id="插入排序（InsertSort）"><a href="#插入排序（InsertSort）" class="headerlink" title="插入排序（InsertSort）"></a>插入排序（InsertSort）</h2><h3 id="把无序序列的第一个当有序序列，然后每次从无序序列中拿出一个元素-在有序序列中进行比较（一般是从尾部开始比较）"><a href="#把无序序列的第一个当有序序列，然后每次从无序序列中拿出一个元素-在有序序列中进行比较（一般是从尾部开始比较）" class="headerlink" title="把无序序列的第一个当有序序列，然后每次从无序序列中拿出一个元素 在有序序列中进行比较（一般是从尾部开始比较）"></a>把无序序列的第一个当有序序列，然后每次从无序序列中拿出一个元素 在有序序列中进行比较（一般是从尾部开始比较）</h3><h3 id="1-如果比较结果为-待插入大于被比较的有序元素-则把待插入元素插入到被比较的有序元素后面"><a href="#1-如果比较结果为-待插入大于被比较的有序元素-则把待插入元素插入到被比较的有序元素后面" class="headerlink" title="1.如果比较结果为 待插入大于被比较的有序元素 则把待插入元素插入到被比较的有序元素后面"></a>1.如果比较结果为 待插入大于被比较的有序元素 则把待插入元素插入到被比较的有序元素后面</h3><h3 id="2-如果比较结果为-待插入小于被比较的有序元素-则把被比较的元素向后移动一位（依次与有序元素进行比较）直到来到首位或大于被比较的元素"><a href="#2-如果比较结果为-待插入小于被比较的有序元素-则把被比较的元素向后移动一位（依次与有序元素进行比较）直到来到首位或大于被比较的元素" class="headerlink" title="2.如果比较结果为 待插入小于被比较的有序元素 则把被比较的元素向后移动一位（依次与有序元素进行比较）直到来到首位或大于被比较的元素"></a>2.如果比较结果为 待插入小于被比较的有序元素 则把被比较的元素向后移动一位（依次与有序元素进行比较）直到来到首位或大于被比较的元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bool InsertSort(int buf[],int bufsize)</span><br><span class="line">&#123;</span><br><span class="line">    //备份元素</span><br><span class="line">    int temp=0;</span><br><span class="line"></span><br><span class="line">    //1 选择第一个元素作为已经排序过的，剩下的元素作为无序序列</span><br><span class="line">    for (int i = 1; i &lt; bufsize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        //备份待插入元素</span><br><span class="line">        temp = buf[i];</span><br><span class="line">        //备份待插入元素下标</span><br><span class="line">        int subscript=i;</span><br><span class="line"></span><br><span class="line">        //把当前待插入元素与有序序列中元素进行比较，从有序序列尾部开始</span><br><span class="line">        for (int j = i-1 ; j &gt;= 0 ; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            //当待插入元素 &gt; 当待插入元素前面的值</span><br><span class="line">            if(temp &gt;= buf[j])</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //当待插入元素 &lt; 当待插入元素前面的值</span><br><span class="line">            if(temp &lt; buf[j])</span><br><span class="line">            &#123;</span><br><span class="line">                subscript=j;</span><br><span class="line">                //把待插入元素前面的值向后移动</span><br><span class="line">                buf[j + 1] = buf[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //把待插入元素插入指定位置</span><br><span class="line">        buf[subscript]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素（Prin）"><a href="#遍历元素（Prin）" class="headerlink" title="遍历元素（Prin）"></a>遍历元素（Prin）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool Prin(int buf[],int size)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Element:&quot;);</span><br><span class="line">    for(int i= 0;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个数组 10个整数</span><br><span class="line">    int buf[10]=&#123;2,4,1,6,8,2,6,1,7,4&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    InsertSort(buf, sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element:2  4  1  6  8  2  6  1  7  4</span><br><span class="line">Element:1  1  2  2  4  4  6  6  7  8</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">//插入排序 是把无序序列依次插入到有序序列，一般是从尾部开始比较</span><br><span class="line">bool InsertSort(int buf[],int bufsize)</span><br><span class="line">&#123;</span><br><span class="line">    //备份元素</span><br><span class="line">    int temp=0;</span><br><span class="line"></span><br><span class="line">    //1 选择第一个元素作为已经排序过的，剩下的元素作为无序序列</span><br><span class="line">    for (int i = 1; i &lt; bufsize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        //备份待插入元素</span><br><span class="line">        temp = buf[i];</span><br><span class="line">        //备份待插入元素下标</span><br><span class="line">        int subscript=i;</span><br><span class="line"></span><br><span class="line">        //把当前待插入元素与有序序列中元素进行比较，从有序序列尾部开始</span><br><span class="line">        for (int j = i-1 ; j &gt;= 0 ; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            //当待插入元素 &gt; 当待插入元素前面的值</span><br><span class="line">            if(temp &gt;= buf[j])</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //当待插入元素 &lt; 当待插入元素前面的值</span><br><span class="line">            if(temp &lt; buf[j])</span><br><span class="line">            &#123;</span><br><span class="line">                subscript=j;</span><br><span class="line">                //把待插入元素前面的值向后移动</span><br><span class="line">                buf[j + 1] = buf[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //把待插入元素插入指定位置</span><br><span class="line">        buf[subscript]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历元素</span><br><span class="line">bool Prin(int buf[],int size)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Element:&quot;);</span><br><span class="line">    for(int i= 0;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个数组 10个整数</span><br><span class="line">    int buf[10]=&#123;2,4,1,6,8,2,6,1,7,4&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    InsertSort(buf, sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,sizeof(buf)/ sizeof(buf[1]));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 八 插入排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构—插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构七（二叉树BSTree）</title>
      <link href="/2025/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91BSTree%EF%BC%89/"/>
      <url>/2025/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91BSTree%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>设计BST二叉查找树，方便对二叉树进行结点的增删，采用双向不循环链表实现，每个结点<br>都需要2个指针，分别指向该结点的左子树（lchild）和右子树（rchild）<br>附加1：计算所有节点的数量<br>附加2: 计算所以叶子节点的数量（度为0）<br>附加3: 计算二叉树的深度</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91BSTree%EF%BC%89/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树" title="二叉树"></p><p>More info: <a href="https://github.com/gybpersist/BSTree">BSTree</a></p><h2 id="构造二叉树（BSTree）"><a href="#构造二叉树（BSTree）" class="headerlink" title="构造二叉树（BSTree）"></a>构造二叉树（BSTree）</h2><h3 id="构造BST树的结点-BST树中所以结点的数据类型应该是相同的（BSTreeNode）"><a href="#构造BST树的结点-BST树中所以结点的数据类型应该是相同的（BSTreeNode）" class="headerlink" title="构造BST树的结点 BST树中所以结点的数据类型应该是相同的（BSTreeNode）"></a>构造BST树的结点 BST树中所以结点的数据类型应该是相同的（BSTreeNode）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">typedef struct BSTreeNode &#123;</span><br><span class="line">    dataType_t Keyval;                 //BST树的键值</span><br><span class="line">    struct BSTreeNode *lchild;      //BST树的左子树的指针域</span><br><span class="line">    struct BSTreeNode *rchild;      //BST树的右子树的指针域</span><br><span class="line">&#125; BSTNode_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个带根结点的BST树，对BST树的根结点进行初始化（BSTree-Create）"><a href="#创建一个带根结点的BST树，对BST树的根结点进行初始化（BSTree-Create）" class="headerlink" title="创建一个带根结点的BST树，对BST树的根结点进行初始化（BSTree_Create）"></a>创建一个带根结点的BST树，对BST树的根结点进行初始化（BSTree_Create）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BSTNode_t* BSTree_Create(dataType_t Keyval)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 创建一个根结点并给根结点申请内存</span><br><span class="line">    BSTNode_t *Root = (BSTNode_t*)calloc(1,sizeof (BSTNode_t));</span><br><span class="line">    if(Root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for Root is Failed!\n&quot;);</span><br><span class="line">        exit(-1);       //退出程序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 对根结点进行初始化</span><br><span class="line">    Root-&gt;lchild = NULL;</span><br><span class="line">    Root-&gt;Keyval = Keyval;</span><br><span class="line">    Root-&gt;rchild = NULL;</span><br><span class="line"></span><br><span class="line">    //1.3 把头结点地地址返回</span><br><span class="line">    return Root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（BSTree-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（BSTree-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（BSTree_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（BSTree_NewNode）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BSTNode_t *BSTree_NewNode(dataType_t Keyval)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 创建一个新结点并给新结点申请内存</span><br><span class="line">    BSTNode_t *NewNode = (BSTNode_t *) calloc(1, sizeof(BSTNode_t));</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 对新结点进行初始化（数据域 指针域2个）</span><br><span class="line">    NewNode-&gt;lchild = NULL;</span><br><span class="line">    NewNode-&gt;Keyval = Keyval;</span><br><span class="line">    NewNode-&gt;rchild = NULL;</span><br><span class="line"></span><br><span class="line">    //2.3 把新结点地地址返回</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向BST树中加入结点-根结点的左子树键值比根结点的键值小，根结点的右子树键值比根结点的键值大-体现递归思想（BSTree-InsertNode）"><a href="#向BST树中加入结点-根结点的左子树键值比根结点的键值小，根结点的右子树键值比根结点的键值大-体现递归思想（BSTree-InsertNode）" class="headerlink" title="向BST树中加入结点  根结点的左子树键值比根结点的键值小，根结点的右子树键值比根结点的键值大 体现递归思想（BSTree_InsertNode）"></a>向BST树中加入结点  根结点的左子树键值比根结点的键值小，根结点的右子树键值比根结点的键值大 体现递归思想（BSTree_InsertNode）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">bool BSTree_InsertNode(BSTNode_t *Root,dataType_t Keyval)</span><br><span class="line">&#123;</span><br><span class="line">    //3.0 避免根结点地址丢失，对根结点地址进行备份</span><br><span class="line">    BSTNode_t *Proot = Root;</span><br><span class="line"></span><br><span class="line">    //3.1 创建新结点并对新结点进行初始化</span><br><span class="line">    BSTNode_t *NewNode = BSTree_NewNode(Keyval);</span><br><span class="line"></span><br><span class="line">    //3.2 此时分析当前BST树是否为空树（空树 or 非空树）</span><br><span class="line">    //为空树</span><br><span class="line">    if(Root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        //把新结点做为BST树的根结点</span><br><span class="line">        Root = NewNode;</span><br><span class="line">    &#125;</span><br><span class="line">    else  //为非空树,2种情况（键值 等于/不等于 根结点）</span><br><span class="line">    &#123;</span><br><span class="line">        while(Proot)</span><br><span class="line">        &#123;</span><br><span class="line">            //新结点的键值和当前新的根结点的键值比较,相等 直接退出</span><br><span class="line">            if(NewNode-&gt;Keyval == Proot-&gt;Keyval)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;Can Not Insert,......\n&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            else  //新结点的键值和当前新的根结点的键值比较,不相等 继续分析</span><br><span class="line">            &#123;</span><br><span class="line">                //新结点的键值和当前新的根结点的键值比较,小于 把根结点的左子树作为新的根</span><br><span class="line">                if(NewNode-&gt;Keyval &lt; Proot-&gt;Keyval)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(Proot-&gt;lchild == NULL)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Proot-&gt;lchild = NewNode;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Proot = Proot-&gt;lchild;</span><br><span class="line">                &#125;</span><br><span class="line">                else  //新结点的键值和当前新的根结点的键值比较,大于 把根结点的右子树作为新的根</span><br><span class="line">                &#123;</span><br><span class="line">                    if(Proot-&gt;rchild == NULL)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Proot-&gt;rchild = NewNode;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Proot = Proot-&gt;rchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前序遍历-根左右-体现递归思想（BSTree-PreOrder）"><a href="#前序遍历-根左右-体现递归思想（BSTree-PreOrder）" class="headerlink" title="前序遍历 根左右 体现递归思想（BSTree_PreOrder）"></a>前序遍历 根左右 体现递归思想（BSTree_PreOrder）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool BSTree_PreOrder(BSTNode_t *Root)</span><br><span class="line">&#123;</span><br><span class="line">    //使用递归函数，必须先写好终止条件</span><br><span class="line">    if(Root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //先输出根节点的键值</span><br><span class="line">    printf(&quot;%d  \n&quot;,Root-&gt;Keyval);</span><br><span class="line">    </span><br><span class="line">    //在输出根节点的左子树</span><br><span class="line">    BSTree_PreOrder(Root-&gt;lchild);</span><br><span class="line">    //在输出根节点的右子树</span><br><span class="line">    BSTree_PreOrder(Root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历-左根右-体现递归思想（BSTree-InOrder）"><a href="#中序遍历-左根右-体现递归思想（BSTree-InOrder）" class="headerlink" title="中序遍历 左根右 体现递归思想（BSTree_InOrder）"></a>中序遍历 左根右 体现递归思想（BSTree_InOrder）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool BSTree_InOrder(BSTNode_t *Root)</span><br><span class="line">&#123;</span><br><span class="line">    //使用递归函数，必须先写好终止条件</span><br><span class="line">    if(Root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //先输出根节点的左子树</span><br><span class="line">    BSTree_InOrder(Root-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    //在输出根节点的键值</span><br><span class="line">    printf(&quot;%d  \n&quot;,Root-&gt;Keyval);</span><br><span class="line"></span><br><span class="line">    //在输出根节点的右子树</span><br><span class="line">    BSTree_InOrder(Root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历-左右根-体现递归思想（BSTree-PostOrder）"><a href="#后序遍历-左右根-体现递归思想（BSTree-PostOrder）" class="headerlink" title="后序遍历 左右根 体现递归思想（BSTree_PostOrder）"></a>后序遍历 左右根 体现递归思想（BSTree_PostOrder）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool BSTree_PostOrder(BSTNode_t *Root)</span><br><span class="line">&#123;</span><br><span class="line">    //使用递归函数，必须先写好终止条件</span><br><span class="line">    if(Root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //先输出根节点的左子树</span><br><span class="line">    BSTree_PostOrder(Root-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    //在输出根节点的右子树</span><br><span class="line">    BSTree_PostOrder(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    //在输出根节点的键值</span><br><span class="line">    printf(&quot;%d  \n&quot;,Root-&gt;Keyval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附加1：计算所有节点的数量-可采用递归（BSTree-CountNode）"><a href="#附加1：计算所有节点的数量-可采用递归（BSTree-CountNode）" class="headerlink" title="附加1：计算所有节点的数量 可采用递归（BSTree_CountNode）"></a>附加1：计算所有节点的数量 可采用递归（BSTree_CountNode）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int BSTree_CountNode(BSTNode_t *Root)</span><br><span class="line">&#123;</span><br><span class="line">    int n1 = 0;     //记录左子树的节点数</span><br><span class="line">    int n2 = 0;     //记录右子树的节点数</span><br><span class="line"></span><br><span class="line">    //使用递归函数，必须先写好终止条件</span><br><span class="line">    if(Root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //假设采用后序遍历计算节点数量</span><br><span class="line">    n1 = BSTree_CountNode(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_CountNode(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    return n1 + n2 +1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附加2：计算所有叶子节点的数量-可采用递归（BSTree-CountLeafNode）"><a href="#附加2：计算所有叶子节点的数量-可采用递归（BSTree-CountLeafNode）" class="headerlink" title="附加2：计算所有叶子节点的数量 可采用递归（BSTree_CountLeafNode）"></a>附加2：计算所有叶子节点的数量 可采用递归（BSTree_CountLeafNode）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int BSTree_CountLeafNode(BSTNode_t *Root)</span><br><span class="line">&#123;</span><br><span class="line">    int n1 = 0;     //记录左子树的节点数</span><br><span class="line">    int n2 = 0;     //记录右子树的节点数</span><br><span class="line"></span><br><span class="line">    //使用递归函数，必须先写好终止条件</span><br><span class="line">    if (Root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //说明只有一个根节点</span><br><span class="line">    if(Root-&gt;lchild == NULL &amp;&amp; Root-&gt;rchild == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //说明有子树</span><br><span class="line">    n1 = BSTree_CountLeafNode(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_CountLeafNode(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    return n1 + n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附加3：计算二叉树的深度-可采用递归（BSTree-GetDepth）"><a href="#附加3：计算二叉树的深度-可采用递归（BSTree-GetDepth）" class="headerlink" title="附加3：计算二叉树的深度 可采用递归（BSTree_GetDepth）"></a>附加3：计算二叉树的深度 可采用递归（BSTree_GetDepth）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int BSTree_GetDepth(BSTNode_t *Root)</span><br><span class="line">&#123;</span><br><span class="line">    int n1 = 0;     //记录左子树的深度</span><br><span class="line">    int n2 = 0;     //记录右子树的深度</span><br><span class="line"></span><br><span class="line">    //使用递归函数，必须先写好终止条件</span><br><span class="line">    if (Root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    //被下面情况包括</span><br><span class="line">//    //说明只有一个根节点</span><br><span class="line">//    if(Root-&gt;lchild == NULL &amp;&amp; Root-&gt;rchild == NULL)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return 1;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    //说明有子树 计算左子树的深度 再 计算右子树的深度 最后 比较找最大再加一</span><br><span class="line">    n1 = BSTree_GetDepth(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_GetDepth(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    return ( (n1&gt;n2)?n1:n2 ) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //1 创建一个带根节点的BST树</span><br><span class="line">    BSTNode_t *Root = BSTree_Create(10);</span><br><span class="line"></span><br><span class="line">    //2 向BST树插入新节点</span><br><span class="line">    BSTree_InsertNode(Root,5);</span><br><span class="line">    BSTree_InsertNode(Root,20);</span><br><span class="line">    BSTree_InsertNode(Root,7);</span><br><span class="line">    BSTree_InsertNode(Root,12);</span><br><span class="line">    BSTree_InsertNode(Root,8);</span><br><span class="line">    BSTree_InsertNode(Root,3);</span><br><span class="line">    BSTree_InsertNode(Root,25);</span><br><span class="line">    BSTree_InsertNode(Root,26);</span><br><span class="line"></span><br><span class="line">//                     10</span><br><span class="line">//            5                   20</span><br><span class="line">//        3       7           12      25</span><br><span class="line">//                    8                     26</span><br><span class="line"></span><br><span class="line">    printf(&quot;前序遍历为:\n&quot;);</span><br><span class="line">    BSTree_PreOrder(Root);</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n中序遍历为:\n&quot;);</span><br><span class="line">    BSTree_InOrder(Root);</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n后序遍历为:\n&quot;);</span><br><span class="line">    BSTree_PostOrder(Root);</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n总节点数：%d&quot;,BSTree_CountNode(Root));</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n所有叶子节点数：%d&quot;,BSTree_CountLeafNode(Root));</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n二叉树的深度：%d&quot;,BSTree_GetDepth(Root));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">前序遍历为:</span><br><span class="line">10  5  3  7  8  20  12  25  26</span><br><span class="line">中序遍历为:</span><br><span class="line">3  5  7  8  10  12  20  25  26</span><br><span class="line">后序遍历为:</span><br><span class="line">3  8  7  5  12  26  25  20  10</span><br><span class="line">总节点数：9</span><br><span class="line">所有叶子节点数：4</span><br><span class="line">二叉树的深度：4</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">设计BST二叉查找树，方便对二叉树进行节点的增删，采用双向不循环链表实现，每个节点</span><br><span class="line">都需要2个指针，分别指向该节点的左子树（lchild）和右子树（rchild）</span><br><span class="line">附加1：计算所有节点的数量</span><br><span class="line">附加2: 计算所以叶子节点的数量（度为0）</span><br><span class="line">附加3: 计算二叉树的深度</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//类型别名 节点有效键值</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//构造BST树的节点 BST树中所以节点的数据类型应该是相同的</span><br><span class="line">typedef struct BSTreeNode &#123;</span><br><span class="line">    dataType_t Keyval;                 //BST树的键值</span><br><span class="line">    struct BSTreeNode *lchild;      //BST树的左子树的指针域</span><br><span class="line">    struct BSTreeNode *rchild;      //BST树的右子树的指针域</span><br><span class="line">&#125; BSTNode_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//1 创建一个带根节点的BST树，对BST树的根节点进行初始化</span><br><span class="line">BSTNode_t* BSTree_Create(dataType_t Keyval)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 创建一个根节点并给根节点申请内存</span><br><span class="line">    BSTNode_t *Root = (BSTNode_t*)calloc(1,sizeof (BSTNode_t));</span><br><span class="line">    if(Root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for Root is Failed!\n&quot;);</span><br><span class="line">        exit(-1);       //退出程序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 对根节点进行初始化</span><br><span class="line">    Root-&gt;lchild = NULL;</span><br><span class="line">    Root-&gt;Keyval = Keyval;</span><br><span class="line">    Root-&gt;rchild = NULL;</span><br><span class="line"></span><br><span class="line">    //1.3 把头节点地地址返回</span><br><span class="line">    return Root;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//2 创建新的节点，并对新节点进行初始化（数据域 指针域）</span><br><span class="line">BSTNode_t *BSTree_NewNode(dataType_t Keyval)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 创建一个新节点并给新节点申请内存</span><br><span class="line">    BSTNode_t *NewNode = (BSTNode_t *) calloc(1, sizeof(BSTNode_t));</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 对新节点进行初始化（数据域 指针域2个）</span><br><span class="line">    NewNode-&gt;lchild = NULL;</span><br><span class="line">    NewNode-&gt;Keyval = Keyval;</span><br><span class="line">    NewNode-&gt;rchild = NULL;</span><br><span class="line"></span><br><span class="line">    //2.3 把新节点地地址返回</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//3 向BST树中加入节点  根节点的左子树键值比根节点的键值小，根节点的右子树键值比根节点的键值大 体现递归思想</span><br><span class="line">bool BSTree_InsertNode(BSTNode_t *Root,dataType_t Keyval)</span><br><span class="line">&#123;</span><br><span class="line">    //3.0 避免根节点地址丢失，对根节点地址进行备份</span><br><span class="line">    BSTNode_t *Proot = Root;</span><br><span class="line"></span><br><span class="line">    //3.1 创建新节点并对新节点进行初始化</span><br><span class="line">    BSTNode_t *NewNode = BSTree_NewNode(Keyval);</span><br><span class="line"></span><br><span class="line">    //3.2 此时分析当前BST树是否为空树（空树 or 非空树）</span><br><span class="line">    //为空树</span><br><span class="line">    if(Root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        //把新节点做为BST树的根节点</span><br><span class="line">        Root = NewNode;</span><br><span class="line">    &#125;</span><br><span class="line">    else  //为非空树,2种情况（键值 等于/不等于 根节点）</span><br><span class="line">    &#123;</span><br><span class="line">        while(Proot)</span><br><span class="line">        &#123;</span><br><span class="line">            //新节点的键值和当前新的根节点的键值比较,相等 直接退出</span><br><span class="line">            if(NewNode-&gt;Keyval == Proot-&gt;Keyval)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;Can Not Insert,......\n&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            else  //新节点的键值和当前新的根节点的键值比较,不相等 继续分析</span><br><span class="line">            &#123;</span><br><span class="line">                //新节点的键值和当前新的根节点的键值比较,小于 把根节点的左子树作为新的根</span><br><span class="line">                if(NewNode-&gt;Keyval &lt; Proot-&gt;Keyval)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(Proot-&gt;lchild == NULL)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Proot-&gt;lchild = NewNode;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Proot = Proot-&gt;lchild;</span><br><span class="line">                &#125;</span><br><span class="line">                else  //新节点的键值和当前新的根节点的键值比较,大于 把根节点的右子树作为新的根</span><br><span class="line">                &#123;</span><br><span class="line">                    if(Proot-&gt;rchild == NULL)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Proot-&gt;rchild = NewNode;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Proot = Proot-&gt;rchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 前序遍历 根左右 体现递归思想</span><br><span class="line">bool BSTree_PreOrder(BSTNode_t *Root)</span><br><span class="line">&#123;</span><br><span class="line">    //使用递归函数，必须先写好终止条件</span><br><span class="line">    if(Root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //先输出根节点的键值</span><br><span class="line">    printf(&quot;%d  &quot;,Root-&gt;Keyval);</span><br><span class="line">    </span><br><span class="line">    //在输出根节点的左子树</span><br><span class="line">    BSTree_PreOrder(Root-&gt;lchild);</span><br><span class="line">    //在输出根节点的右子树</span><br><span class="line">    BSTree_PreOrder(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 中序遍历 左根右 体现递归思想</span><br><span class="line">bool BSTree_InOrder(BSTNode_t *Root)</span><br><span class="line">&#123;</span><br><span class="line">    //使用递归函数，必须先写好终止条件</span><br><span class="line">    if(Root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //先输出根节点的左子树</span><br><span class="line">    BSTree_InOrder(Root-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    //在输出根节点的键值</span><br><span class="line">    printf(&quot;%d  &quot;,Root-&gt;Keyval);</span><br><span class="line"></span><br><span class="line">    //在输出根节点的右子树</span><br><span class="line">    BSTree_InOrder(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 后序遍历 左右根 体现递归思想</span><br><span class="line">bool BSTree_PostOrder(BSTNode_t *Root)</span><br><span class="line">&#123;</span><br><span class="line">    //使用递归函数，必须先写好终止条件</span><br><span class="line">    if(Root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //先输出根节点的左子树</span><br><span class="line">    BSTree_PostOrder(Root-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    //在输出根节点的右子树</span><br><span class="line">    BSTree_PostOrder(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    //在输出根节点的键值</span><br><span class="line">    printf(&quot;%d  &quot;,Root-&gt;Keyval);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 附加1：计算所有节点的数量 可采用递归</span><br><span class="line">int BSTree_CountNode(BSTNode_t *Root)</span><br><span class="line">&#123;</span><br><span class="line">    int n1 = 0;     //记录左子树的节点数</span><br><span class="line">    int n2 = 0;     //记录右子树的节点数</span><br><span class="line"></span><br><span class="line">    //使用递归函数，必须先写好终止条件</span><br><span class="line">    if(Root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //假设采用后序遍历计算节点数量</span><br><span class="line">    n1 = BSTree_CountNode(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_CountNode(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    return n1 + n2 +1;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 附加2：计算所有叶子节点的数量 可采用递归</span><br><span class="line">int BSTree_CountLeafNode(BSTNode_t *Root)</span><br><span class="line">&#123;</span><br><span class="line">    int n1 = 0;     //记录左子树的节点数</span><br><span class="line">    int n2 = 0;     //记录右子树的节点数</span><br><span class="line"></span><br><span class="line">    //使用递归函数，必须先写好终止条件</span><br><span class="line">    if (Root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //说明只有一个根节点</span><br><span class="line">    if(Root-&gt;lchild == NULL &amp;&amp; Root-&gt;rchild == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //说明有子树</span><br><span class="line">    n1 = BSTree_CountLeafNode(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_CountLeafNode(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    return n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 附加3：计算二叉树的深度 可采用递归</span><br><span class="line">int BSTree_GetDepth(BSTNode_t *Root)</span><br><span class="line">&#123;</span><br><span class="line">    int n1 = 0;     //记录左子树的深度</span><br><span class="line">    int n2 = 0;     //记录右子树的深度</span><br><span class="line"></span><br><span class="line">    //使用递归函数，必须先写好终止条件</span><br><span class="line">    if (Root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    //被下面情况包括</span><br><span class="line">//    //说明只有一个根节点</span><br><span class="line">//    if(Root-&gt;lchild == NULL &amp;&amp; Root-&gt;rchild == NULL)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return 1;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    //说明有子树 计算左子树的深度 再 计算右子树的深度 最后 比较找最大再加一</span><br><span class="line">    n1 = BSTree_GetDepth(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_GetDepth(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    return ( (n1&gt;n2)?n1:n2 ) + 1;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //1 创建一个带根节点的BST树</span><br><span class="line">    BSTNode_t *Root = BSTree_Create(10);</span><br><span class="line"></span><br><span class="line">    //2 向BST树插入新节点</span><br><span class="line">    BSTree_InsertNode(Root,5);</span><br><span class="line">    BSTree_InsertNode(Root,20);</span><br><span class="line">    BSTree_InsertNode(Root,7);</span><br><span class="line">    BSTree_InsertNode(Root,12);</span><br><span class="line">    BSTree_InsertNode(Root,8);</span><br><span class="line">    BSTree_InsertNode(Root,3);</span><br><span class="line">    BSTree_InsertNode(Root,25);</span><br><span class="line">    BSTree_InsertNode(Root,26);</span><br><span class="line">    </span><br><span class="line">//                     10</span><br><span class="line">//            5                   20</span><br><span class="line">//        3       7           12      25</span><br><span class="line">//                    8                     26</span><br><span class="line"></span><br><span class="line">    printf(&quot;前序遍历为:\n&quot;);</span><br><span class="line">    BSTree_PreOrder(Root);</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n中序遍历为:\n&quot;);</span><br><span class="line">    BSTree_InOrder(Root);</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n后序遍历为:\n&quot;);</span><br><span class="line">    BSTree_PostOrder(Root);</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n总节点数：%d&quot;,BSTree_CountNode(Root));</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n所有叶子节点数：%d&quot;,BSTree_CountLeafNode(Root));</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n二叉树的深度：%d&quot;,BSTree_GetDepth(Root));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 七 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构—二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构六（顺序栈sequenceStack）</title>
      <link href="/2025/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/"/>
      <url>/2025/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个顺序栈实现对顺序栈内元素的<br> ——入栈<br> ——出栈<br> ——遍历顺序栈</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/%E9%A1%BA%E5%BA%8F%E6%A0%88.jpg" alt="顺序栈" title="顺序栈"></p><p>More info: <a href="https://github.com/gybpersist/sequenceStack">sequenceStack</a></p><h2 id="构造顺序栈（sequenceStack）"><a href="#构造顺序栈（sequenceStack）" class="headerlink" title="构造顺序栈（sequenceStack）"></a>构造顺序栈（sequenceStack）</h2><h3 id="构造顺序栈记录参数-顺序栈的栈底地址-顺序栈的容量-顺序栈的栈顶元素的下标"><a href="#构造顺序栈记录参数-顺序栈的栈底地址-顺序栈的容量-顺序栈的栈顶元素的下标" class="headerlink" title="构造顺序栈记录参数(顺序栈的栈底地址 顺序栈的容量 顺序栈的栈顶元素的下标)"></a>构造顺序栈记录参数(顺序栈的栈底地址 顺序栈的容量 顺序栈的栈顶元素的下标)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">typedef struct sequenceStack &#123;</span><br><span class="line">    dataType_t *Bottom;       //顺序栈的栈底地址</span><br><span class="line">    unsigned int size;      //顺序栈的容量</span><br><span class="line">    int Top;               //顺序栈的栈顶元素的下标</span><br><span class="line">&#125; sqStack_t;</span><br></pre></td></tr></table></figure><h2 id="创建顺序栈并对顺序栈进行初始化（sqStack-Create）"><a href="#创建顺序栈并对顺序栈进行初始化（sqStack-Create）" class="headerlink" title="创建顺序栈并对顺序栈进行初始化（sqStack_Create）"></a>创建顺序栈并对顺序栈进行初始化（sqStack_Create）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sqStack_t *sqStack_Create(unsigned int size)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 利用calloc为顺序栈的管理结构体申请堆内存</span><br><span class="line">    sqStack_t *manager = (sqStack_t*)calloc(1,sizeof (manager));</span><br><span class="line"></span><br><span class="line">    if(NULL == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for manager is failed&quot;);</span><br><span class="line">        exit(-1);       //程序终止</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 为所有元素申请堆内存 calloc,并完成错误处理</span><br><span class="line">    manager-&gt;Bottom = (dataType_t*)calloc(size,sizeof(dataType_t));</span><br><span class="line"></span><br><span class="line">    if(NULL == manager-&gt;Bottom)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for element is failed&quot;);</span><br><span class="line">        free(manager);  //释放内存</span><br><span class="line">        exit(-1);       //程序终止</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.3 对管理顺序栈的结构体进行初始化（元素容量 最后元素下标）</span><br><span class="line">    manager-&gt;size = size; //对顺序栈的容量进行初始化</span><br><span class="line">    manager-&gt;Top = -1;   //由于顺序栈为空，则最后元素下标初值为-1</span><br><span class="line"></span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序栈是否以满（sqStack-IsFull）"><a href="#判断顺序栈是否以满（sqStack-IsFull）" class="headerlink" title="判断顺序栈是否以满（sqStack_IsFull）"></a>判断顺序栈是否以满（sqStack_IsFull）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//判断顺序栈是否以满</span><br><span class="line">bool sqStack_IsFull(sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;Top+1 == manager-&gt;size) ? true : false;</span><br><span class="line">//        if(manager-&gt;Top+1 == manager-&gt;size)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return ture;</span><br><span class="line">//    &#125;</span><br><span class="line">//    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入栈-sqStack-Push"><a href="#入栈-sqStack-Push" class="headerlink" title="入栈(sqStack_Push)"></a>入栈(sqStack_Push)</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/%E5%85%A5%E6%A0%88.png" alt="入栈" title="入栈"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool sqStack_Push (sqStack_t *manager,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 判断顺序栈是否以满</span><br><span class="line">    if(sqStack_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;sequenceStack is Full!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 若顺序栈有空闲空间，则把新元素添加到顺序栈尾部</span><br><span class="line">/*    manager-&gt;Top++;</span><br><span class="line">    *(manager-&gt;Bottom + manager-&gt;Top) = data;   */</span><br><span class="line">    manager-&gt;Bottom[++manager-&gt;Top] = data;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序栈是否为空（sqStack-IsEmpty）"><a href="#判断顺序栈是否为空（sqStack-IsEmpty）" class="headerlink" title="判断顺序栈是否为空（sqStack_IsEmpty）"></a>判断顺序栈是否为空（sqStack_IsEmpty）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool sqStack_IsEmpty(sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;Top == -1) ? true : false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出栈（sqStack-Pop）"><a href="#出栈（sqStack-Pop）" class="headerlink" title="出栈（sqStack_Pop）"></a>出栈（sqStack_Pop）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/%E5%87%BA%E6%A0%88.png" alt="出栈" title="出栈"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dataType_t sqStack_Pop (sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    dataType_t temp=-1;     //记录需要出栈的值</span><br><span class="line"></span><br><span class="line">    //4.1 判断顺序栈是否为空</span><br><span class="line">    if(sqStack_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;SequenceStack is Empty!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 由于删掉一个元素，则顺序栈有效元素下标减一 后--（先赋值后--）</span><br><span class="line">    temp = manager-&gt;Bottom[manager-&gt;Top--];</span><br><span class="line">    return temp;</span><br><span class="line"></span><br><span class="line">    //return manager-&gt;Bottom[manager-&gt;Top--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历顺序栈（sqStack-print）"><a href="#遍历顺序栈（sqStack-print）" class="headerlink" title="遍历顺序栈（sqStack_print）"></a>遍历顺序栈（sqStack_print）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//5 遍历顺序栈中的元素</span><br><span class="line">void sqStack_print (sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;=manager-&gt;Top;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Element[%d]=%d\n&quot;,i,manager-&gt;Bottom[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //1 创建顺序栈</span><br><span class="line">    sqStack_t *manager = sqStack_Create(10);</span><br><span class="line"></span><br><span class="line">    //2 向顺序栈  入栈</span><br><span class="line">    sqStack_Push (manager,5);</span><br><span class="line">    sqStack_Push (manager,2);</span><br><span class="line">    sqStack_Push (manager,1);</span><br><span class="line">    sqStack_Push (manager,4);</span><br><span class="line">    sqStack_Push (manager,6);</span><br><span class="line">    sqStack_Push (manager,8);</span><br><span class="line"></span><br><span class="line">    //3 遍历顺序栈</span><br><span class="line">    sqStack_print (manager);     //5 2 1 4 6</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //6 出栈</span><br><span class="line">    dataType_t temp1,temp2,temp3,temp4;</span><br><span class="line">    </span><br><span class="line">    temp1 = sqStack_Pop (manager);</span><br><span class="line">    printf(&quot; 出栈：%d &quot;,temp1);</span><br><span class="line"></span><br><span class="line">    temp2 = sqStack_Pop (manager);</span><br><span class="line">    printf(&quot; 出栈：%d &quot;,temp2);</span><br><span class="line"></span><br><span class="line">    temp3 = sqStack_Pop (manager);</span><br><span class="line">    printf(&quot; 出栈：%d &quot;,temp3);</span><br><span class="line"></span><br><span class="line">    temp4 = sqStack_Pop (manager);</span><br><span class="line">    printf(&quot; 出栈：%d\n&quot;,temp4);</span><br><span class="line"></span><br><span class="line">    //7 遍历顺序栈</span><br><span class="line">    sqStack_print (manager);     //8 8 4 8 2 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Element[0]=5</span><br><span class="line">Element[1]=2</span><br><span class="line">Element[2]=1</span><br><span class="line">Element[3]=4</span><br><span class="line">Element[4]=6</span><br><span class="line">Element[5]=8</span><br><span class="line"></span><br><span class="line"> 出栈：8  出栈：6  出栈：4  出栈：1</span><br><span class="line">Element[0]=5</span><br><span class="line">Element[1]=2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//构造顺序栈记录参数(顺序栈的栈底地址 顺序栈的容量 顺序栈的栈顶元素的下标)</span><br><span class="line">typedef struct sequenceStack &#123;</span><br><span class="line">    dataType_t *Bottom;       //顺序栈的栈底地址</span><br><span class="line">    unsigned int size;      //顺序栈的容量</span><br><span class="line">    int Top;               //顺序栈的栈顶元素的下标</span><br><span class="line">&#125; sqStack_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//1 创建顺序栈并对顺序栈进行初始化</span><br><span class="line">sqStack_t *sqStack_Create(unsigned int size)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 利用calloc为顺序栈的管理结构体申请堆内存</span><br><span class="line">    sqStack_t *manager = (sqStack_t*)calloc(1,sizeof (manager));</span><br><span class="line"></span><br><span class="line">    if(NULL == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for manager is failed&quot;);</span><br><span class="line">        exit(-1);       //程序终止</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 为所有元素申请堆内存 calloc,并完成错误处理</span><br><span class="line">    manager-&gt;Bottom = (dataType_t*)calloc(size,sizeof(dataType_t));</span><br><span class="line"></span><br><span class="line">    if(NULL == manager-&gt;Bottom)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for element is failed&quot;);</span><br><span class="line">        free(manager);  //释放内存</span><br><span class="line">        exit(-1);       //程序终止</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.3 对管理顺序栈的结构体进行初始化（元素容量 最后元素下标）</span><br><span class="line">    manager-&gt;size = size; //对顺序栈的容量进行初始化</span><br><span class="line">    manager-&gt;Top = -1;   //由于顺序栈为空，则最后元素下标初值为-1</span><br><span class="line"></span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//判断顺序栈是否以满</span><br><span class="line">bool sqStack_IsFull(sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;Top+1 == manager-&gt;size) ? true : false;</span><br><span class="line">//        if(manager-&gt;Top+1 == manager-&gt;size)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return ture;</span><br><span class="line">//    &#125;</span><br><span class="line">//    return false;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//2 顺序栈   入栈</span><br><span class="line">bool sqStack_Push (sqStack_t *manager,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 判断顺序栈是否以满</span><br><span class="line">    if(sqStack_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;sequenceStack is Full!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 若顺序栈有空闲空间，则把新元素添加到顺序栈尾部</span><br><span class="line">/*    manager-&gt;Bottom++;</span><br><span class="line">    *(manager-&gt;Bottom + manager-&gt;Top) = data;   */</span><br><span class="line">    manager-&gt;Bottom[++manager-&gt;Top] = data;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//判断顺序栈是否为空</span><br><span class="line">bool sqStack_IsEmpty(sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;Top == -1) ? true : false;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//4 顺序栈  出栈</span><br><span class="line">dataType_t sqStack_Pop (sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    dataType_t temp=-1;     //记录需要出栈的值</span><br><span class="line"></span><br><span class="line">    //4.1 判断顺序栈是否为空</span><br><span class="line">    if(sqStack_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;SequenceStack is Empty!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 由于删掉一个元素，则顺序栈有效元素下标减一 后--（先赋值后--）</span><br><span class="line">    temp = manager-&gt;Bottom[manager-&gt;Top--];</span><br><span class="line">    return temp;</span><br><span class="line"></span><br><span class="line">    //return manager-&gt;Bottom[manager-&gt;Top--];</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//5 遍历顺序栈中的元素</span><br><span class="line">void sqStack_print (sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;=manager-&gt;Top;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Element[%d]=%d\n&quot;,i,manager-&gt;Bottom[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //1 创建顺序栈</span><br><span class="line">    sqStack_t *manager = sqStack_Create(10);</span><br><span class="line"></span><br><span class="line">    //2 向顺序栈  入栈</span><br><span class="line">    sqStack_Push (manager,5);</span><br><span class="line">    sqStack_Push (manager,2);</span><br><span class="line">    sqStack_Push (manager,1);</span><br><span class="line">    sqStack_Push (manager,4);</span><br><span class="line">    sqStack_Push (manager,6);</span><br><span class="line">    sqStack_Push (manager,8);</span><br><span class="line"></span><br><span class="line">    //3 遍历顺序栈</span><br><span class="line">    sqStack_print (manager);     //5 2 1 4 6</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //6 出栈</span><br><span class="line">    dataType_t temp1,temp2,temp3,temp4;</span><br><span class="line">    </span><br><span class="line">    temp1 = sqStack_Pop (manager);</span><br><span class="line">    printf(&quot; 出栈：%d &quot;,temp1);</span><br><span class="line"></span><br><span class="line">    temp2 = sqStack_Pop (manager);</span><br><span class="line">    printf(&quot; 出栈：%d &quot;,temp2);</span><br><span class="line"></span><br><span class="line">    temp3 = sqStack_Pop (manager);</span><br><span class="line">    printf(&quot; 出栈：%d &quot;,temp3);</span><br><span class="line"></span><br><span class="line">    temp4 = sqStack_Pop (manager);</span><br><span class="line">    printf(&quot; 出栈：%d\n&quot;,temp4);</span><br><span class="line"></span><br><span class="line">    //7 遍历顺序栈</span><br><span class="line">    sqStack_print (manager);     //8 8 4 8 2 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 六 顺序栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构—顺序栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构五（双向循环链表DoubleCirLList）</title>
      <link href="/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCircularLinkeList%EF%BC%89/"/>
      <url>/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCircularLinkeList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个双向循环链表实现对双向循环链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历双向循环链表</p><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="双向循环链表" title="双向循环链表"></p><p>More info: <a href="https://github.com/gybpersist/DoubleCirLList">DoubleCirLList</a></p><h2 id="构造双向循环链表（DoubleCirLList）"><a href="#构造双向循环链表（DoubleCirLList）" class="headerlink" title="构造双向循环链表（DoubleCirLList）"></a>构造双向循环链表（DoubleCirLList）</h2><h3 id="构造双向循环链表的结点-双向循环链表中所有结点的数据类型应该是相同的"><a href="#构造双向循环链表的结点-双向循环链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造双向循环链表的结点 双向循环链表中所有结点的数据类型应该是相同的"></a>构造双向循环链表的结点 双向循环链表中所有结点的数据类型应该是相同的</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">typedef struct DoubleCirLList &#123;</span><br><span class="line">    dataType_t data;                 // 双向循环链表的数据域，用于存储具体的数据</span><br><span class="line">    struct DoubleCirLList *prev;   // 双向循环链表的前驱指针域，指向前一个节点</span><br><span class="line">    struct DoubleCirLList *next;   // 双向循环链表的后继指针域，指向后一个节点</span><br><span class="line">&#125; DoubleLList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（DoubleCirLList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（DoubleCirLList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（DoubleCirLList_Create）"></a>创建一个空链表，空链表应该有一个头结点（DoubleCirLList_Create）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t* DoubleCirLList_Create(void) &#123;</span><br><span class="line">    // 创建一个头结点并给头结点申请内存，使用 calloc 函数将内存初始化为 0</span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)calloc(1, sizeof(DoubleLList_t));</span><br><span class="line">    if (Head == NULL) &#123;</span><br><span class="line">        // 若内存分配失败，使用 perror 输出错误信息并退出程序</span><br><span class="line">        perror(&quot;calloc memory for Head is Failed!\n&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对头结点进行初始化，体现循环，将头结点的 prev 和 next 指针都指向自己</span><br><span class="line">    Head-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    // 把头结点的地址返回，方便后续操作</span><br><span class="line">    return Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleCirLList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleCirLList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleCirLList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleCirLList_NewNode）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t *DoubleCirLList_NewNode(dataType_t data) &#123;</span><br><span class="line">    // 创建一个新结点并给新结点申请内存，使用 calloc 函数将内存初始化为 0</span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) calloc(1, sizeof(DoubleLList_t));</span><br><span class="line">    if (NewNode == NULL) &#123;</span><br><span class="line">        // 若内存分配失败，使用 perror 输出错误信息并返回 NULL</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对新结点进行初始化（数据域 指针域2个），体现循环，将新结点的 prev 和 next 指针都指向自己</span><br><span class="line">    NewNode-&gt;prev = NewNode;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    // 把新结点的地址返回，方便后续操作</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入新节点到指定节点之后（insertAfter）"><a href="#插入新节点到指定节点之后（insertAfter）" class="headerlink" title="插入新节点到指定节点之后（insertAfter）"></a>插入新节点到指定节点之后（insertAfter）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void insertAfter(DoubleLList_t *node, DoubleLList_t *newNode) &#123;</span><br><span class="line">    // 将新节点的 next 指针指向指定节点的下一个节点</span><br><span class="line">    newNode-&gt;next = node-&gt;next;</span><br><span class="line">    // 将新节点的 prev 指针指向指定节点</span><br><span class="line">    newNode-&gt;prev = node;</span><br><span class="line">    // 将指定节点的下一个节点的 prev 指针指向新节点</span><br><span class="line">    node-&gt;next-&gt;prev = newNode;</span><br><span class="line">    // 将指定节点的 next 指针指向新节点</span><br><span class="line">    node-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（DoubleCirLList-HeadInsert）"><a href="#头插（DoubleCirLList-HeadInsert）" class="headerlink" title="头插（DoubleCirLList_HeadInsert）"></a>头插（DoubleCirLList_HeadInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleCirLList_HeadInsert(DoubleLList_t *Head, dataType_t data) &#123;</span><br><span class="line">    //3.1建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    if (NewNode == NULL) &#123;</span><br><span class="line">        // 若新节点创建失败，输出提示信息并返回 false</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        Head-&gt;prev = NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 以下四步操作将新节点插入到链表头部</span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    //    insertAfter(Phead, NewNode);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（DoubleCirLList-TailInsert）"><a href="#尾插（DoubleCirLList-TailInsert）" class="headerlink" title="尾插（DoubleCirLList_TailInsert）"></a>尾插（DoubleCirLList_TailInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleCirLList_TailInsert(DoubleLList_t *Head, dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        // 若新节点创建失败，输出提示信息并返回 false</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //把新结点插入到链表尾部</span><br><span class="line">    // 将新节点的 prev 指针指向原尾节点</span><br><span class="line">    NewNode-&gt;prev = Head-&gt;prev;</span><br><span class="line">    // 将原尾节点的 next 指针指向新节点</span><br><span class="line">    Head-&gt;prev-&gt;next = NewNode;</span><br><span class="line">    // 将新节点的 next 指针指向头结点</span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    // 将头结点的 prev 指针指向新节点</span><br><span class="line">    Head-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    //    insertAfter(Phead, NewNode);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（DoubleCirLList-DestInsert）"><a href="#指定插入（DoubleCirLList-DestInsert）" class="headerlink" title="指定插入（DoubleCirLList_DestInsert）"></a>指定插入（DoubleCirLList_DestInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleCirLList_DestInsert(DoubleLList_t *Head, dataType_t destval, dataType_t data) &#123;</span><br><span class="line">    // 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    if (NewNode == NULL) &#123;</span><br><span class="line">        // 若新节点创建失败，输出提示信息并返回 false</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历链表，找到目标结点（比较数据域）</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != Head &amp;&amp; Phead-&gt;data != destval) &#123;</span><br><span class="line">        // 若未找到目标节点且未遍历完链表，将指针移动到下一个节点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (Phead == Head) &#123;</span><br><span class="line">        // 未找到目标节点，释放新节点的内存并返回 false</span><br><span class="line">        free(NewNode);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 以下四步操作将新节点插入到目标节点之后</span><br><span class="line">    NewNode-&gt;next = Phead-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Phead-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">//    insertAfter(Phead, NewNode);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（DoubleCirLList-Print）"><a href="#遍历链表（DoubleCirLList-Print）" class="headerlink" title="遍历链表（DoubleCirLList_Print）"></a>遍历链表（DoubleCirLList_Print）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleCirLList_Print(DoubleLList_t *Head) &#123;</span><br><span class="line">    // 判断当前链表是否为空，为空则直接退出</span><br><span class="line">    if (Head-&gt;next == Head) &#123;</span><br><span class="line">        // 若链表为空，输出提示信息并返回 false</span><br><span class="line">        printf(&quot;Current linkedList is empty!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断当前链表不为空则继续遍历</span><br><span class="line">    int i = 0;</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != Head) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        // 输出当前节点的数据</span><br><span class="line">        printf(&quot;Date[%d] = %d\n&quot;, i, Phead-&gt;data);</span><br><span class="line">        // 将指针移动到下一个节点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除指定节点（deleteNode）"><a href="#删除指定节点（deleteNode）" class="headerlink" title="删除指定节点（deleteNode）"></a>删除指定节点（deleteNode）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void deleteNode(DoubleLList_t *node) &#123;</span><br><span class="line">    // 将指定节点的前一个节点的 next 指针指向指定节点的下一个节点</span><br><span class="line">    node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    // 将指定节点的下一个节点的 prev 指针指向指定节点的前一个节点</span><br><span class="line">    node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    // 将指定节点的 next 和 prev 指针置为 NULL</span><br><span class="line">    node-&gt;next = NULL;</span><br><span class="line">    node-&gt;prev = NULL;</span><br><span class="line">    // 释放指定节点的内存</span><br><span class="line">    free(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除首结点（DoubleCirLList-HeadDel）"><a href="#头删-删除首结点（DoubleCirLList-HeadDel）" class="headerlink" title="头删 删除首结点（DoubleCirLList_HeadDel）"></a>头删 删除首结点（DoubleCirLList_HeadDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleCirLList_HeadDel(DoubleLList_t *Head) &#123;</span><br><span class="line">    // 判断链表是否为空，如果为空则直接退出</span><br><span class="line">    if (Head-&gt;next == Head) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 7.2 对链表的首结点进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    // 7.3 链表非空 删除首结点</span><br><span class="line">    // 将首结点之后的结点的 prev 指针连接到头结点</span><br><span class="line">    Head-&gt;next-&gt;next-&gt;prev = Head;</span><br><span class="line">    // 将头结点的 next 指针指向原先首结点之后的结点</span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    // 7.4 释放首结点的内存</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    //    deleteNode(Head-&gt;next);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（DoubleCirLList-TailDel）"><a href="#尾删-删除尾结点（DoubleCirLList-TailDel）" class="headerlink" title="尾删 删除尾结点（DoubleCirLList_TailDel）"></a>尾删 删除尾结点（DoubleCirLList_TailDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleCirLList_TailDel(DoubleLList_t *Head) &#123;</span><br><span class="line">    // 8.1 判断判断链表是否为空，如果为空则直接退出</span><br><span class="line">    if (Head-&gt;next == Head) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 8.2 记录当前尾结点的地址</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;prev;</span><br><span class="line"></span><br><span class="line">    // 8.3 链表非空 删除尾结点</span><br><span class="line">    // 将头结点的 prev 指针连接到尾结点的前一个结点</span><br><span class="line">    Head-&gt;next-&gt;prev = Phead-&gt;prev;</span><br><span class="line">    // 将尾结点的前一个结点的 next 指针连接到头结点</span><br><span class="line">    Phead-&gt;prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    // 8.4 释放尾结点的内存</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    //    deleteNode(Head-&gt;prev);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个双向循环链表</span><br><span class="line">    DoubleLList_t *Head = DoubleCirLList_Create();</span><br><span class="line"></span><br><span class="line">    // 进行头插操作</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 5);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 8);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 1);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 6);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 3);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 进行尾插操作</span><br><span class="line">    DoubleCirLList_TailInsert(Head, 4);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 在值为 1 的节点后插入新节点</span><br><span class="line">    DoubleCirLList_DestInsert(Head, 1, 9);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 进行头删操作</span><br><span class="line">    DoubleCirLList_HeadDel(Head);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 进行尾删操作</span><br><span class="line">    DoubleCirLList_TailDel(Head);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line"></span><br><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line">Date[6] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 9</span><br><span class="line">Date[5] = 8</span><br><span class="line">Date[6] = 5</span><br><span class="line">Date[7] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 6</span><br><span class="line">Date[2] = 1</span><br><span class="line">Date[3] = 9</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line">Date[6] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 6</span><br><span class="line">Date[2] = 1</span><br><span class="line">Date[3] = 9</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 类型别名，将 int 类型重命名为 dataType_t，方便后续修改数据类型</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 构造双向循环链表的结点</span><br><span class="line">typedef struct DoubleCirLList &#123;</span><br><span class="line">    dataType_t data;                 // 双向循环链表的数据域，用于存储具体的数据</span><br><span class="line">    struct DoubleCirLList *prev;   // 双向循环链表的前驱指针域，指向前一个节点</span><br><span class="line">    struct DoubleCirLList *next;   // 双向循环链表的后继指针域，指向后一个节点</span><br><span class="line">&#125; DoubleLList_t;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 1 创建一个空链表，空链表应该有一个头结点</span><br><span class="line">DoubleLList_t* DoubleCirLList_Create(void) &#123;</span><br><span class="line">    // 创建一个头结点并给头结点申请内存，使用 calloc 函数将内存初始化为 0</span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)calloc(1, sizeof(DoubleLList_t));</span><br><span class="line">    if (Head == NULL) &#123;</span><br><span class="line">        // 若内存分配失败，使用 perror 输出错误信息并退出程序</span><br><span class="line">        perror(&quot;calloc memory for Head is Failed!\n&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对头结点进行初始化，体现循环，将头结点的 prev 和 next 指针都指向自己</span><br><span class="line">    Head-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    // 把头结点的地址返回，方便后续操作</span><br><span class="line">    return Head;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">DoubleLList_t *DoubleCirLList_NewNode(dataType_t data) &#123;</span><br><span class="line">    // 创建一个新结点并给新结点申请内存，使用 calloc 函数将内存初始化为 0</span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) calloc(1, sizeof(DoubleLList_t));</span><br><span class="line">    if (NewNode == NULL) &#123;</span><br><span class="line">        // 若内存分配失败，使用 perror 输出错误信息并返回 NULL</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对新结点进行初始化（数据域 指针域2个），体现循环，将新结点的 prev 和 next 指针都指向自己</span><br><span class="line">    NewNode-&gt;prev = NewNode;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    // 把新结点的地址返回，方便后续操作</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 插入新节点到指定节点之后</span><br><span class="line">void insertAfter(DoubleLList_t *node, DoubleLList_t *newNode) &#123;</span><br><span class="line">    // 将新节点的 next 指针指向指定节点的下一个节点</span><br><span class="line">    newNode-&gt;next = node-&gt;next;</span><br><span class="line">    // 将新节点的 prev 指针指向指定节点</span><br><span class="line">    newNode-&gt;prev = node;</span><br><span class="line">    // 将指定节点的下一个节点的 prev 指针指向新节点</span><br><span class="line">    node-&gt;next-&gt;prev = newNode;</span><br><span class="line">    // 将指定节点的 next 指针指向新节点</span><br><span class="line">    node-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 3 在链表中 头插</span><br><span class="line">bool DoubleCirLList_HeadInsert(DoubleLList_t *Head, dataType_t data) &#123;</span><br><span class="line">    //3.1建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    if (NewNode == NULL) &#123;</span><br><span class="line">        // 若新节点创建失败，输出提示信息并返回 false</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        Head-&gt;prev = NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 以下四步操作将新节点插入到链表头部</span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    //    insertAfter(Phead, NewNode);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 4 在链表中 尾部插</span><br><span class="line">bool DoubleCirLList_TailInsert(DoubleLList_t *Head, dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        // 若新节点创建失败，输出提示信息并返回 false</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //把新结点插入到链表尾部</span><br><span class="line">    // 将新节点的 prev 指针指向原尾节点</span><br><span class="line">    NewNode-&gt;prev = Head-&gt;prev;</span><br><span class="line">    // 将原尾节点的 next 指针指向新节点</span><br><span class="line">    Head-&gt;prev-&gt;next = NewNode;</span><br><span class="line">    // 将新节点的 next 指针指向头结点</span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    // 将头结点的 prev 指针指向新节点</span><br><span class="line">    Head-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    //    insertAfter(Phead, NewNode);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 5 在链表中 指定插入</span><br><span class="line">bool DoubleCirLList_DestInsert(DoubleLList_t *Head, dataType_t destval, dataType_t data) &#123;</span><br><span class="line">    // 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    if (NewNode == NULL) &#123;</span><br><span class="line">        // 若新节点创建失败，输出提示信息并返回 false</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历链表，找到目标结点（比较数据域）</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != Head &amp;&amp; Phead-&gt;data != destval) &#123;</span><br><span class="line">        // 若未找到目标节点且未遍历完链表，将指针移动到下一个节点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (Phead == Head) &#123;</span><br><span class="line">        // 未找到目标节点，释放新节点的内存并返回 false</span><br><span class="line">        free(NewNode);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 以下四步操作将新节点插入到目标节点之后</span><br><span class="line">    NewNode-&gt;next = Phead-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Phead-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">//    insertAfter(Phead, NewNode);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 6 遍历链表</span><br><span class="line">bool DoubleCirLList_Print(DoubleLList_t *Head) &#123;</span><br><span class="line">    // 判断当前链表是否为空，为空则直接退出</span><br><span class="line">    if (Head-&gt;next == Head) &#123;</span><br><span class="line">        // 若链表为空，输出提示信息并返回 false</span><br><span class="line">        printf(&quot;Current linkedList is empty!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断当前链表不为空则继续遍历</span><br><span class="line">    int i = 0;</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != Head) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        // 输出当前节点的数据</span><br><span class="line">        printf(&quot;Date[%d] = %d\n&quot;, i, Phead-&gt;data);</span><br><span class="line">        // 将指针移动到下一个节点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 删除指定节点</span><br><span class="line">void deleteNode(DoubleLList_t *node) &#123;</span><br><span class="line">    // 将指定节点的前一个节点的 next 指针指向指定节点的下一个节点</span><br><span class="line">    node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    // 将指定节点的下一个节点的 prev 指针指向指定节点的前一个节点</span><br><span class="line">    node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    // 将指定节点的 next 和 prev 指针置为 NULL</span><br><span class="line">    node-&gt;next = NULL;</span><br><span class="line">    node-&gt;prev = NULL;</span><br><span class="line">    // 释放指定节点的内存</span><br><span class="line">    free(node);</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 7 头删 删除首结点</span><br><span class="line">bool DoubleCirLList_HeadDel(DoubleLList_t *Head) &#123;</span><br><span class="line">    // 判断链表是否为空，如果为空则直接退出</span><br><span class="line">    if (Head-&gt;next == Head) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 7.2 对链表的首结点进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    // 7.3 链表非空 删除首结点</span><br><span class="line">    // 将首结点之后的结点的 prev 指针连接到头结点</span><br><span class="line">    Head-&gt;next-&gt;next-&gt;prev = Head;</span><br><span class="line">    // 将头结点的 next 指针指向原先首结点之后的结点</span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    // 7.4 释放首结点的内存</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    //    deleteNode(Head-&gt;next);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 8 尾删 删除尾结点</span><br><span class="line">bool DoubleCirLList_TailDel(DoubleLList_t *Head) &#123;</span><br><span class="line">    // 8.1 判断判断链表是否为空，如果为空则直接退出</span><br><span class="line">    if (Head-&gt;next == Head) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 8.2 记录当前尾结点的地址</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;prev;</span><br><span class="line"></span><br><span class="line">    // 8.3 链表非空 删除尾结点</span><br><span class="line">    // 将头结点的 prev 指针连接到尾结点的前一个结点</span><br><span class="line">    Head-&gt;next-&gt;prev = Phead-&gt;prev;</span><br><span class="line">    // 将尾结点的前一个结点的 next 指针连接到头结点</span><br><span class="line">    Phead-&gt;prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    // 8.4 释放尾结点的内存</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    //    deleteNode(Head-&gt;prev);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个双向循环链表</span><br><span class="line">    DoubleLList_t *Head = DoubleCirLList_Create();</span><br><span class="line"></span><br><span class="line">    // 进行头插操作</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 5);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 8);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 1);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 6);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 3);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 进行尾插操作</span><br><span class="line">    DoubleCirLList_TailInsert(Head, 4);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 在值为 1 的节点后插入新节点</span><br><span class="line">    DoubleCirLList_DestInsert(Head, 1, 9);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 进行头删操作</span><br><span class="line">    DoubleCirLList_HeadDel(Head);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 进行尾删操作</span><br><span class="line">    DoubleCirLList_TailDel(Head);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 五 双向循环链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构—双向循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构四（单向循环链表CircularLinkedList）</title>
      <link href="/2025/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/"/>
      <url>/2025/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个单向循环链表实现对单向循环链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历单向循环链表</p><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="单向循环链表" title="单向循环链表"></p><p>More info: <a href="https://github.com/gybpersist/CircularLinkedList">CircularLinkedList</a></p><h2 id="构造单向循环链表（CircularLinkedList）"><a href="#构造单向循环链表（CircularLinkedList）" class="headerlink" title="构造单向循环链表（CircularLinkedList）"></a>构造单向循环链表（CircularLinkedList）</h2><h3 id="构造单向循环链表的结点-单向循环链表中所有结点的数据类型应该是相同的"><a href="#构造单向循环链表的结点-单向循环链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造单向循环链表的结点 单向循环链表中所有结点的数据类型应该是相同的"></a>构造单向循环链表的结点 单向循环链表中所有结点的数据类型应该是相同的</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">typedef struct CircularLinkedList &#123;</span><br><span class="line">    dataType_t data;                 //单向循环链表的数据域</span><br><span class="line">    struct CircularLinkedList *next;      //单向循环链表的指针域</span><br><span class="line">&#125; CricLList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（CricLList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（CricLList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（CricLList_Create）"></a>创建一个空链表，空链表应该有一个头结点（CricLList_Create）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CricLList_t* CricLList_Create(void)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 创建一个头结点并给头结点申请内存</span><br><span class="line">    CricLList_t *Head = (CricLList_t*)calloc(1,sizeof (CricLList_t));</span><br><span class="line">    if(Head == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for Head is Failed!\n&quot;);</span><br><span class="line">        exit(-1);       //退出程序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 对头结点进行初始化，头结点是不存储有效内容的</span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    //1.3 把头结点地地址返回</span><br><span class="line">    return Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（CricLList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（CricLList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（CricLList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（CricLList_NewNode）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CricLList_t *CricLList_NewNode(dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 创建一个新结点并给新结点申请内存</span><br><span class="line">    CricLList_t *NewNode = (CricLList_t *) calloc(1, sizeof(CricLList_t));</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 对新结点进行初始化（数据域 指针域）</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //2.3 把新结点地地址返回</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（CricLList-HeadInsert）"><a href="#头插（CricLList-HeadInsert）" class="headerlink" title="头插（CricLList_HeadInsert）"></a>头插（CricLList_HeadInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool CricLList_HeadInsert(CricLList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.3 如果链表为非空，则把新结点插入到链表头部</span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（CricLList-TailInsert）"><a href="#尾插（CricLList-TailInsert）" class="headerlink" title="尾插（CricLList_TailInsert）"></a>尾插（CricLList_TailInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool CricLList_TailInsert(CricLList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.3 如果链表为非空，则把新结点插入到链表尾部</span><br><span class="line">    //对链表的头结点进行备份</span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line">    while (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（CricLList-DestInsert）"><a href="#指定插入（CricLList-DestInsert）" class="headerlink" title="指定插入（CricLList_DestInsert）"></a>指定插入（CricLList_DestInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">bool CricLList_DestInsert(CricLList_t *Head,dataType_t destval,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span><br><span class="line">    //对链表的首结点进行备份</span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != Head &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        //把结点的直接后继作为新的结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        if(Phead == Head)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;   //代表循环完之后未找到 目标值destval</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.4 说明找到目标结点，则把新结点加入到目标结点后面</span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（CricLList-Print）"><a href="#遍历链表（CricLList-Print）" class="headerlink" title="遍历链表（CricLList_Print）"></a>遍历链表（CricLList_Print）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bool CricLList_Print(CricLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //对链表的头结点的地址进行备份</span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    //判断当前链表是否为空，为空则直接退出</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Current linkedList is empty!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断当前链表不为空则继续遍历</span><br><span class="line">    //记录第几个</span><br><span class="line">    int i=0;</span><br><span class="line">    while (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        //输出头结点的直接后继的数据域</span><br><span class="line">        printf(&quot;Date[%d] = %d\n&quot;,i,Phead-&gt;data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除头结点（CricLList-HeadDel）"><a href="#头删-删除头结点（CricLList-HeadDel）" class="headerlink" title="头删 删除头结点（CricLList_HeadDel）"></a>头删 删除头结点（CricLList_HeadDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool CricLList_HeadDel(CricLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //7.1 对链表的首结点进行备份</span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //7.2 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7.3 链表非空 删除首结点</span><br><span class="line">    Head-&gt;next = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    // 如果链表只有一个节点，删除后让头结点指向自身</span><br><span class="line">    if (Phead-&gt;next == Head) &#123;</span><br><span class="line">        Head-&gt;next = Head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7.4 原先首结点的 next指向NULL，并释放首结点的内存</span><br><span class="line">    Phead-&gt;next = NULL;</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（CricLList-TailDel）"><a href="#尾删-删除尾结点（CricLList-TailDel）" class="headerlink" title="尾删 删除尾结点（CricLList_TailDel）"></a>尾删 删除尾结点（CricLList_TailDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bool CricLList_TailDel(CricLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //8.1 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //8.2 记录当前结点的地址</span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //记录当前结点的直接前驱</span><br><span class="line">    CricLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    //8.3 链表非空 删除尾结点</span><br><span class="line">    while (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    CricLList_t *Head = CricLList_Create();            //创建链表</span><br><span class="line"></span><br><span class="line">    CricLList_HeadInsert(Head,5);            //头插</span><br><span class="line">    CricLList_HeadInsert(Head,8);</span><br><span class="line">    CricLList_HeadInsert(Head,1);</span><br><span class="line">    CricLList_HeadInsert(Head,6);</span><br><span class="line">    CricLList_HeadInsert(Head,3);</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 3 6 1 8 5</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    CricLList_TailInsert(Head,4);               //尾插</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 3 6 1 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    CricLList_DestInsert(Head,1,9);     //destval后面插入</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 3 6 1 9 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    CricLList_HeadDel(Head);                        //头删</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 6 1 9 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    CricLList_TailDel(Head);                        //尾删</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 6 1 9 8 5</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line"></span><br><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line">Date[6] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 9</span><br><span class="line">Date[5] = 8</span><br><span class="line">Date[6] = 5</span><br><span class="line">Date[7] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 6</span><br><span class="line">Date[2] = 1</span><br><span class="line">Date[3] = 9</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line">Date[6] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 6</span><br><span class="line">Date[2] = 1</span><br><span class="line">Date[3] = 9</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//构造单向循环链表的结点 单向链循环表中所以结点的数据类型应该是相同的</span><br><span class="line">typedef struct CircularLinkedList &#123;</span><br><span class="line">    dataType_t data;                 //单向链表的数据域</span><br><span class="line">    struct CircularLinkedList *next;      //单向链表的指针域</span><br><span class="line">&#125; CricLList_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//1 创建一个空链表，空链表应该有一个头结点</span><br><span class="line">CricLList_t* CricLList_Create(void)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 创建一个头结点并给头结点申请内存</span><br><span class="line">    CricLList_t *Head = (CricLList_t*)calloc(1,sizeof (CricLList_t));</span><br><span class="line">    if(Head == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for Head is Failed!\n&quot;);</span><br><span class="line">        exit(-1);       //退出程序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 对头结点进行初始化，头结点是不存储有效内容的,指针域指向自己，体现循环思想</span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    //1.3 把头结点地地址返回</span><br><span class="line">    return Head;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">CricLList_t *CricLList_NewNode(dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 创建一个新结点并给新结点申请内存</span><br><span class="line">    CricLList_t *NewNode = (CricLList_t *) calloc(1, sizeof(CricLList_t));</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 对新结点进行初始化（数据域 指针域）</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //2.3 把新结点地地址返回</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//3 在链表中 头插</span><br><span class="line">bool CricLList_HeadInsert(CricLList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.3 如果链表为非空，则把新结点插入到链表头部</span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//4 在链表中 尾部插</span><br><span class="line">bool CricLList_TailInsert(CricLList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.3 如果链表为非空，则把新结点插入到链表尾部</span><br><span class="line">    //对链表的头结点进行备份</span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line">    while (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next = NewNode;</span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//5 在链表中 指定插入</span><br><span class="line">bool CricLList_DestInsert(CricLList_t *Head,dataType_t destval,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span><br><span class="line">    //对链表的首结点进行备份</span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != Head &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        //把结点的直接后继作为新的结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        if(Phead == Head)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;   //代表循环完之后未找到 目标值destval</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.4 说明找到目标结点，则把新结点加入到目标结点后面</span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//6 遍历链表</span><br><span class="line">bool CricLList_Print(CricLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //对链表的头结点的地址进行备份</span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    //判断当前链表是否为空，为空则直接退出</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Current linkedList is empty!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断当前链表不为空则继续遍历</span><br><span class="line">    //记录第几个</span><br><span class="line">    int i=0;</span><br><span class="line">    while (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        //输出头结点的直接后继的数据域</span><br><span class="line">        printf(&quot;Date[%d] = %d\n&quot;,i,Phead-&gt;data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//7 头删 删除首结点</span><br><span class="line">bool CricLList_HeadDel(CricLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //7.1 对链表的首结点进行备份</span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //7.2 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7.3 链表非空 删除首结点</span><br><span class="line">    Head-&gt;next = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    // 如果链表只有一个节点，删除后让头结点指向自身</span><br><span class="line">    if (Phead-&gt;next == Head) &#123;</span><br><span class="line">        Head-&gt;next = Head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7.4 原先首结点的 next指向NULL，并释放首结点的内存</span><br><span class="line">    Phead-&gt;next = NULL;</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//8 尾删 删除尾结点</span><br><span class="line">bool CricLList_TailDel(CricLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //8.1 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //8.2 记录当前结点的地址</span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //记录当前结点的直接前驱</span><br><span class="line">    CricLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    //8.3 链表非空 删除尾结点</span><br><span class="line">    while (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    CricLList_t *Head = CricLList_Create();            //创建链表</span><br><span class="line"></span><br><span class="line">    CricLList_HeadInsert(Head,5);            //头插</span><br><span class="line">    CricLList_HeadInsert(Head,8);</span><br><span class="line">    CricLList_HeadInsert(Head,1);</span><br><span class="line">    CricLList_HeadInsert(Head,6);</span><br><span class="line">    CricLList_HeadInsert(Head,3);</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 3 6 1 8 5</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    CricLList_TailInsert(Head,4);               //尾插</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 3 6 1 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    CricLList_DestInsert(Head,1,9);     //destval后面插入</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 3 6 1 9 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    CricLList_HeadDel(Head);                        //头删</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 6 1 9 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    CricLList_TailDel(Head);                        //尾删</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 6 1 9 8 5</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 四 单向循环链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构—单向循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构二（单向链表linkedList）</title>
      <link href="/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/"/>
      <url>/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个单向链表实现对单向链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历单向链表</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="单向链表" title="单向链表"></p><p>More info: <a href="https://github.com/gybpersist/linkedList">linkedList</a></p><h2 id="构造单向链表（linkedList）"><a href="#构造单向链表（linkedList）" class="headerlink" title="构造单向链表（linkedList）"></a>构造单向链表（linkedList）</h2><h3 id="构造单向链表的结点-单向链表中所有结点的数据类型应该是相同的"><a href="#构造单向链表的结点-单向链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造单向链表的结点 单向链表中所有结点的数据类型应该是相同的"></a>构造单向链表的结点 单向链表中所有结点的数据类型应该是相同的</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">typedef struct linkedList &#123;</span><br><span class="line">    dataType_t data;                 //单向链表的数据域</span><br><span class="line">    struct linkedList *next;      //单向链表的指针域</span><br><span class="line">&#125; lList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（lList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（lList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（lList_Create）"></a>创建一个空链表，空链表应该有一个头结点（lList_Create）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lList_t* lList_Create(void)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 创建一个头结点并给头结点申请内存</span><br><span class="line">    lList_t *Head = (lList_t*)calloc(1,sizeof (lList_t));</span><br><span class="line">    if(Head == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for Head is Failed!\n&quot;);</span><br><span class="line">        exit(-1);       //退出程序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 对头结点进行初始化，头结点是不存储有效内容的</span><br><span class="line">    Head-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //1.3 把头结点地地址返回</span><br><span class="line">    return Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（lList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（lList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（lList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（lList_NewNode）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lList_t *lList_NewNode(dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 创建一个新结点并给新结点申请内存</span><br><span class="line">    lList_t *NewNode = (lList_t *) calloc(1, sizeof(lList_t));</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 对新结点进行初始化（数据域 指针域）</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //2.3 把新结点地地址返回</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（lList-HeadInsert）"><a href="#头插（lList-HeadInsert）" class="headerlink" title="头插（lList_HeadInsert）"></a>头插（lList_HeadInsert）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bool lList_HeadInsert(lList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.3 如果链表为非空，则把新结点插入到链表头部</span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（lList-TailInsert）"><a href="#尾插（lList-TailInsert）" class="headerlink" title="尾插（lList_TailInsert）"></a>尾插（lList_TailInsert）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bool lList_TailInsert(lList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.3 如果链表为非空，则把新结点插入到链表尾部</span><br><span class="line">    //对链表的头结点进行备份</span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line">    while (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（lList-DestInsert）"><a href="#指定插入（lList-DestInsert）" class="headerlink" title="指定插入（lList_DestInsert）"></a>指定插入（lList_DestInsert）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">bool lList_DestInsert(lList_t *Head,dataType_t destval,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span><br><span class="line">    //对链表的首结点进行备份</span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != NULL &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        //把结点的直接后继作为新的结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        if(Phead == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.4 说明找到目标结点，则把新结点加入到目标结点后面</span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（lList-Print）"><a href="#遍历链表（lList-Print）" class="headerlink" title="遍历链表（lList_Print）"></a>遍历链表（lList_Print）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void lList_Print(lList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //对链表的头结点进行备份</span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    //记录第几个</span><br><span class="line">    int i=0;</span><br><span class="line">    while (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        //输出头结点的直接后继的数据域</span><br><span class="line">        printf(&quot;Date[%d] = %d\n&quot;,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除首结点（lList-HeadDel）"><a href="#头删-删除首结点（lList-HeadDel）" class="headerlink" title="头删 删除首结点（lList_HeadDel）"></a>头删 删除首结点（lList_HeadDel）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool lList_HeadDel(lList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //7.1 对链表的首结点进行备份</span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //7.2 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7.3 链表非空 删除首结点</span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    //7.4 原先首结点的 next指向NULL，并释放首结点的内存</span><br><span class="line">    Phead-&gt;next = NULL;</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（lList-TailDel）"><a href="#尾删-删除尾结点（lList-TailDel）" class="headerlink" title="尾删 删除尾结点（lList_TailDel）"></a>尾删 删除尾结点（lList_TailDel）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool lList_TailDel(lList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //8.1 记录当前结点的地址</span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //记录当前结点的直接前驱</span><br><span class="line">    lList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //8.2 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //8.3 链表非空 删除尾结点</span><br><span class="line">    while (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    lList_t *Head = lList_Create();            //创建链表</span><br><span class="line">    lList_NewNode(5);                    //创建新结点</span><br><span class="line"></span><br><span class="line">    lList_HeadInsert(Head,5);            //头插</span><br><span class="line">    lList_HeadInsert(Head,8);</span><br><span class="line">    lList_HeadInsert(Head,1);</span><br><span class="line">    lList_HeadInsert(Head,6);</span><br><span class="line">    lList_HeadInsert(Head,3);</span><br><span class="line"></span><br><span class="line">    lList_TailInsert(Head,4);               //尾插</span><br><span class="line"></span><br><span class="line">    lList_DestInsert(Head,1,9);     //destval后面插入</span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         //遍历链表 3 6 1 9 8 5 4</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    lList_HeadDel(Head);                        //头删</span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         //遍历链表 6 1 9 8 5 4</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    lList_TailDel(Head);                        //尾删</span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         //遍历链表 6 1 9 8 5</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 9</span><br><span class="line">Date[5] = 8</span><br><span class="line">Date[6] = 5</span><br><span class="line">Date[7] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 6</span><br><span class="line">Date[2] = 1</span><br><span class="line">Date[3] = 9</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line">Date[6] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 6</span><br><span class="line">Date[2] = 1</span><br><span class="line">Date[3] = 9</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//构造单向链表的结点 单向链表中所有结点的数据类型应该是相同的</span><br><span class="line">typedef struct linkedList &#123;</span><br><span class="line">    dataType_t data;                 //单向链表的数据域</span><br><span class="line">    struct linkedList *next;      //单向链表的指针域</span><br><span class="line">&#125; lList_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//1 创建一个空链表，空链表应该有一个头结点</span><br><span class="line">lList_t* lList_Create(void)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 创建一个头结点并给头结点申请内存</span><br><span class="line">    lList_t *Head = (lList_t*)calloc(1,sizeof (lList_t));</span><br><span class="line">    if(Head == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for Head is Failed!\n&quot;);</span><br><span class="line">        exit(-1);       //退出程序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 对头结点进行初始化，头结点是不存储有效内容的</span><br><span class="line">    Head-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //1.3 把头结点地地址返回</span><br><span class="line">    return Head;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">lList_t *lList_NewNode(dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 创建一个新结点并给新结点申请内存</span><br><span class="line">    lList_t *NewNode = (lList_t *) calloc(1, sizeof(lList_t));</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 对新结点进行初始化（数据域 指针域）</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //2.3 把新结点地地址返回</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//3 ccccccccc</span><br><span class="line">bool lList_HeadInsert(lList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.3 如果链表为非空，则把新结点插入到链表头部</span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//4 在链表中 尾部插</span><br><span class="line">bool lList_TailInsert(lList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.3 如果链表为非空，则把新结点插入到链表尾部</span><br><span class="line">    //对链表的头结点进行备份</span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line">    while (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//5 在链表中 指定插入</span><br><span class="line">bool lList_DestInsert(lList_t *Head,dataType_t destval,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span><br><span class="line">    //对链表的首结点进行备份</span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != NULL &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        //把结点的直接后继作为新的结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        if(Phead == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.4 说明找到目标结点，则把新结点加入到目标结点后面</span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//6 遍历链表</span><br><span class="line">void lList_Print(lList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //对链表的头结点进行备份</span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    //记录第几个</span><br><span class="line">    int i=0;</span><br><span class="line">    while (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        //输出头结点的直接后继的数据域</span><br><span class="line">        printf(&quot;Date[%d] = %d\n&quot;,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//7 头删 删除首结点</span><br><span class="line">bool lList_HeadDel(lList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //7.1 对链表的首结点进行备份</span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //7.2 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7.3 链表非空 删除首结点</span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    //7.4 原先首结点的 next指向NULL，并释放首结点的内存</span><br><span class="line">    Phead-&gt;next = NULL;</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//8 尾删 删除尾结点</span><br><span class="line">bool lList_TailDel(lList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //8.1 记录当前结点的地址</span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //记录当前结点的直接前驱</span><br><span class="line">    lList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //8.2 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //8.3 链表非空 删除尾结点</span><br><span class="line">    while (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    lList_t *Head = lList_Create();            //创建链表</span><br><span class="line">    lList_NewNode(5);                    //创建新结点</span><br><span class="line"></span><br><span class="line">    lList_HeadInsert(Head,5);            //头插</span><br><span class="line">    lList_HeadInsert(Head,8);</span><br><span class="line">    lList_HeadInsert(Head,1);</span><br><span class="line">    lList_HeadInsert(Head,6);</span><br><span class="line">    lList_HeadInsert(Head,3);</span><br><span class="line"></span><br><span class="line">    lList_TailInsert(Head,4);               //尾插</span><br><span class="line"></span><br><span class="line">    lList_DestInsert(Head,1,9);     //destval后面插入</span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         //遍历链表 3 6 1 9 8 5 4</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    lList_HeadDel(Head);                        //头删</span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         //遍历链表 6 1 9 8 5 4</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    lList_TailDel(Head);                        //尾删</span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         //遍历链表 6 1 9 8 5</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 二 单向链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构—单向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构一（顺序表sequenceList）</title>
      <link href="/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8sequenceList%EF%BC%89/"/>
      <url>/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8sequenceList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p> --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个顺序表实现对顺序表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历顺序表</p><p><img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8sequenceList%EF%BC%89/%E9%A1%BA%E5%BA%8F%E8%A1%A8.png" alt="顺序表" title="顺序表"></p><p>More info: <a href="https://github.com/gybpersist/sequenceList">sequenceList</a></p><h2 id="构造顺序表（sequenceList）"><a href="#构造顺序表（sequenceList）" class="headerlink" title="构造顺序表（sequenceList）"></a>构造顺序表（sequenceList）</h2><h3 id="构造顺序表记录参数-顺序表的首地址-顺序表的容量-顺序表的有效元素的下标"><a href="#构造顺序表记录参数-顺序表的首地址-顺序表的容量-顺序表的有效元素的下标" class="headerlink" title="构造顺序表记录参数(顺序表的首地址 顺序表的容量 顺序表的有效元素的下标)"></a>构造顺序表记录参数(顺序表的首地址 顺序表的容量 顺序表的有效元素的下标)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">typedef struct sequenceList &#123;</span><br><span class="line">    dataType_t *Addr;       //顺序表的首地址</span><br><span class="line">    unsigned int size;      //顺序表的容量</span><br><span class="line">    int last;               //顺序表的有效元素的下标</span><br><span class="line">&#125; sqList_t;</span><br></pre></td></tr></table></figure><h2 id="创建顺序表并对顺序表进行初始化（sqList-Create）"><a href="#创建顺序表并对顺序表进行初始化（sqList-Create）" class="headerlink" title="创建顺序表并对顺序表进行初始化（sqList_Create）"></a>创建顺序表并对顺序表进行初始化（sqList_Create）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sqList_t *sqList_Create(unsigned int size)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 利用calloc为顺序表的管理结构体申请堆内存</span><br><span class="line">    sqList_t *manager = (sqList_t*)calloc(1,sizeof (manager));</span><br><span class="line"></span><br><span class="line">    if(NULL == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for manager is failed&quot;);</span><br><span class="line">        exit(-1);       //程序终止</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 为所有元素申请堆内存 calloc,并完成错误处理</span><br><span class="line">    manager-&gt;Addr = (dataType_t*)calloc(size,sizeof(dataType_t));</span><br><span class="line"></span><br><span class="line">    if(NULL == manager-&gt;Addr)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for element is failed&quot;);</span><br><span class="line">        free(manager);  //释放内存</span><br><span class="line">        exit(-1);       //程序终止</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.3 对管理顺序表的结构体进行初始化（元素容量 最后元素下标）</span><br><span class="line">    manager-&gt;size = size; //对顺序表的容量进行初始化</span><br><span class="line">    manager-&gt;last = -1;   //由于顺序表为空，则最后元素下标初值为-1</span><br><span class="line"></span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序表是否以满（sqList-IsFull）"><a href="#判断顺序表是否以满（sqList-IsFull）" class="headerlink" title="判断顺序表是否以满（sqList_IsFull）"></a>判断顺序表是否以满（sqList_IsFull）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//判断顺序表是否以满</span><br><span class="line">bool sqList_IsFull(sqList_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;last+1 == manager-&gt;size) ? true : false;</span><br><span class="line">//        if(manager-&gt;last+1 == manager-&gt;size)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return ture;</span><br><span class="line">//    &#125;</span><br><span class="line">//    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（sqList-endAdd）"><a href="#尾插（sqList-endAdd）" class="headerlink" title="尾插（sqList_endAdd）"></a>尾插（sqList_endAdd）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//向顺序表的尾部插入元素</span><br><span class="line">bool sqList_endAdd (sqList_t *manager,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 判断顺序表是否以满</span><br><span class="line">    if(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;sequenceList is Full!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 若顺序表有空闲空间，则把新元素添加到顺序表尾部</span><br><span class="line">/*    manager-&gt;last++;</span><br><span class="line">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span><br><span class="line">    manager-&gt;Addr[++manager-&gt;last] = data;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（sqList-headAdd）"><a href="#头插（sqList-headAdd）" class="headerlink" title="头插（sqList_headAdd）"></a>头插（sqList_headAdd）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//3 向顺序表的头部插入元素</span><br><span class="line">bool sqList_headAdd (sqList_t *manager,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 判断顺序表是否以满</span><br><span class="line">    if(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;sequenceList is Full!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 若顺序表有空闲空间，则把新元素添加到顺序表头部 顺序表中所以元素向后移动1个单位</span><br><span class="line">/*    manager-&gt;last++;</span><br><span class="line">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span><br><span class="line">    for(int i = manager-&gt;last;i &gt;= 0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i+1] = manager-&gt;Addr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.3 把新元素放到顺序表的头部,并且更新管理结构体中的元素下标+1</span><br><span class="line">    manager-&gt;Addr[0] = data;</span><br><span class="line">    manager-&gt;last++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序表是否为空（sqList-IsEmpty）"><a href="#判断顺序表是否为空（sqList-IsEmpty）" class="headerlink" title="判断顺序表是否为空（sqList_IsEmpty）"></a>判断顺序表是否为空（sqList_IsEmpty）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//判断顺序表是否为空</span><br><span class="line">bool sqList_IsEmpty(sqList_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;last == -1) ? true : false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定删除（sqList-delAdd）"><a href="#指定删除（sqList-delAdd）" class="headerlink" title="指定删除（sqList_delAdd）"></a>指定删除（sqList_delAdd）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//4 向顺序表删除元素</span><br><span class="line">bool sqList_delAdd (sqList_t *manager,dataType_t destVal)</span><br><span class="line">&#123;</span><br><span class="line">    int temp=-1;     //记录需要删除的下标</span><br><span class="line"></span><br><span class="line">    //4.1 判断顺序表是否为空</span><br><span class="line">    if(sqList_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;SequenceList is Empty!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 需要查找目标值是否在顺序表中</span><br><span class="line">    for(int i=0;i &lt;= manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果目标值与顺序表中的值相同</span><br><span class="line">        if(destVal == manager-&gt;Addr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            temp=i;     //把目标元素的下标备份到变量temp中</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.3 如果顺序表中没有目标值的元素则终止函数</span><br><span class="line">    if(temp==-1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;destval [%d] is not found\n&quot;,destVal);</span><br><span class="line">        return  false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.4 如果顺序表中有目标值的元素，则将该元素的后继元素向前移动一位</span><br><span class="line">    for (int i = temp; i &lt; manager-&gt;last; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i] = manager-&gt;Addr[i+1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.5 由于删掉一个元素，则顺序表有效元素下标减一</span><br><span class="line">    manager-&gt;last--;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历顺序表（sqList-print）"><a href="#遍历顺序表（sqList-print）" class="headerlink" title="遍历顺序表（sqList_print）"></a>遍历顺序表（sqList_print）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//5 遍历顺序表中的元素</span><br><span class="line">void sqList_print (sqList_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;=manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Element[%d]=%d\n&quot;,i,manager-&gt;Addr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //1 创建顺序表</span><br><span class="line">    sqList_t *manager = sqList_Create(10);</span><br><span class="line"></span><br><span class="line">    //2 向顺序表尾部插入新元素</span><br><span class="line">    sqList_endAdd (manager,5);</span><br><span class="line">    sqList_endAdd (manager,2);</span><br><span class="line">    sqList_endAdd (manager,1);</span><br><span class="line">    sqList_endAdd (manager,4);</span><br><span class="line">    sqList_endAdd (manager,6);</span><br><span class="line"></span><br><span class="line">    //3 遍历顺序表</span><br><span class="line">    sqList_print (manager);     //5 2 1 4 6</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //4 向顺序表头部插入新元素</span><br><span class="line">    sqList_headAdd (manager,8);</span><br><span class="line">    sqList_headAdd (manager,4);</span><br><span class="line">    sqList_headAdd (manager,8);</span><br><span class="line">    sqList_headAdd (manager,8);</span><br><span class="line"></span><br><span class="line">    //5 遍历顺序表</span><br><span class="line">    sqList_print (manager);     //8 8 4 8 5 2 1 4 6</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //6 删除顺序表中元素</span><br><span class="line">    sqList_delAdd (manager,20);</span><br><span class="line">    sqList_delAdd (manager,5);</span><br><span class="line">    sqList_delAdd (manager,1);</span><br><span class="line">    sqList_delAdd (manager,6);</span><br><span class="line"></span><br><span class="line">    //7 遍历顺序表</span><br><span class="line">    sqList_print (manager);     //8 8 4 8 2 4</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Element[0]=5</span><br><span class="line">Element[1]=2</span><br><span class="line">Element[2]=1</span><br><span class="line">Element[3]=4</span><br><span class="line">Element[4]=6</span><br><span class="line"></span><br><span class="line">Element[0]=8</span><br><span class="line">Element[1]=8</span><br><span class="line">Element[2]=4</span><br><span class="line">Element[3]=8</span><br><span class="line">Element[4]=5</span><br><span class="line">Element[5]=2</span><br><span class="line">Element[6]=1</span><br><span class="line">Element[7]=4</span><br><span class="line">Element[8]=6</span><br><span class="line"></span><br><span class="line">destval [20] is not found</span><br><span class="line">Element[0]=8</span><br><span class="line">Element[1]=8</span><br><span class="line">Element[2]=4</span><br><span class="line">Element[3]=8</span><br><span class="line">Element[4]=2</span><br><span class="line">Element[5]=4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//构造顺序表记录参数(顺序表的首地址 顺序表的容量 顺序表的有效元素的下标)</span><br><span class="line">typedef struct sequenceList &#123;</span><br><span class="line">    dataType_t *Addr;       //顺序表的首地址</span><br><span class="line">    unsigned int size;      //顺序表的容量</span><br><span class="line">    int last;               //顺序表的有效元素的下标</span><br><span class="line">&#125; sqList_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//1 创建顺序表并对顺序表进行初始化</span><br><span class="line">sqList_t *sqList_Create(unsigned int size)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 利用calloc为顺序表的管理结构体申请堆内存</span><br><span class="line">    sqList_t *manager = (sqList_t*)calloc(1,sizeof (manager));</span><br><span class="line"></span><br><span class="line">    if(NULL == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for manager is failed&quot;);</span><br><span class="line">        exit(-1);       //程序终止</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 为所有元素申请堆内存 calloc,并完成错误处理</span><br><span class="line">    manager-&gt;Addr = (dataType_t*)calloc(size,sizeof(dataType_t));</span><br><span class="line"></span><br><span class="line">    if(NULL == manager-&gt;Addr)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for element is failed&quot;);</span><br><span class="line">        free(manager);  //释放内存</span><br><span class="line">        exit(-1);       //程序终止</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.3 对管理顺序表的结构体进行初始化（元素容量 最后元素下标）</span><br><span class="line">    manager-&gt;size = size; //对顺序表的容量进行初始化</span><br><span class="line">    manager-&gt;last = -1;   //由于顺序表为空，则最后元素下标初值为-1</span><br><span class="line"></span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//判断顺序表是否以满</span><br><span class="line">bool sqList_IsFull(sqList_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;last+1 == manager-&gt;size) ? true : false;</span><br><span class="line">//        if(manager-&gt;last+1 == manager-&gt;size)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return ture;</span><br><span class="line">//    &#125;</span><br><span class="line">//    return false;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//2 向顺序表的尾部插入元素</span><br><span class="line">bool sqList_endAdd (sqList_t *manager,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 判断顺序表是否以满</span><br><span class="line">    if(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;sequenceList is Full!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 若顺序表有空闲空间，则把新元素添加到顺序表尾部</span><br><span class="line">/*    manager-&gt;last++;</span><br><span class="line">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span><br><span class="line">    manager-&gt;Addr[++manager-&gt;last] = data;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//3 向顺序表的头部插入元素</span><br><span class="line">bool sqList_headAdd (sqList_t *manager,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 判断顺序表是否以满</span><br><span class="line">    if(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;sequenceList is Full!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 若顺序表有空闲空间，则把新元素添加到顺序表头部 顺序表中所以元素向后移动1个单位</span><br><span class="line">/*    manager-&gt;last++;</span><br><span class="line">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span><br><span class="line">    for(int i = manager-&gt;last;i &gt;= 0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i+1] = manager-&gt;Addr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.3 把新元素放到顺序表的头部,并且更新管理结构体中的元素下标+1</span><br><span class="line">    manager-&gt;Addr[0] = data;</span><br><span class="line">    manager-&gt;last++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//判断顺序表是否为空</span><br><span class="line">bool sqList_IsEmpty(sqList_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;last == -1) ? true : false;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//4 向顺序表删除元素</span><br><span class="line">bool sqList_delAdd (sqList_t *manager,dataType_t destVal)</span><br><span class="line">&#123;</span><br><span class="line">    int temp=-1;     //记录需要删除的下标</span><br><span class="line"></span><br><span class="line">    //4.1 判断顺序表是否为空</span><br><span class="line">    if(sqList_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;SequenceList is Empty!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 需要查找目标值是否在顺序表中</span><br><span class="line">    for(int i=0;i &lt;= manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果目标值与顺序表中的值相同</span><br><span class="line">        if(destVal == manager-&gt;Addr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            temp=i;     //把目标元素的下标备份到变量temp中</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.3 如果顺序表中没有目标值的元素则终止函数</span><br><span class="line">    if(temp==-1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;destval [%d] is not found\n&quot;,destVal);</span><br><span class="line">        return  false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.4 如果顺序表中有目标值的元素，则将该元素的后继元素向前移动一位</span><br><span class="line">    for (int i = temp; i &lt; manager-&gt;last; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i] = manager-&gt;Addr[i+1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.5 由于删掉一个元素，则顺序表有效元素下标减一</span><br><span class="line">    manager-&gt;last--;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//5 遍历顺序表中的元素</span><br><span class="line">void sqList_print (sqList_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;=manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Element[%d]=%d\n&quot;,i,manager-&gt;Addr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //1 创建顺序表</span><br><span class="line">    sqList_t *manager = sqList_Create(10);</span><br><span class="line"></span><br><span class="line">    //2 向顺序表尾部插入新元素</span><br><span class="line">    sqList_endAdd (manager,5);</span><br><span class="line">    sqList_endAdd (manager,2);</span><br><span class="line">    sqList_endAdd (manager,1);</span><br><span class="line">    sqList_endAdd (manager,4);</span><br><span class="line">    sqList_endAdd (manager,6);</span><br><span class="line"></span><br><span class="line">    //3 遍历顺序表</span><br><span class="line">    sqList_print (manager);     //5 2 1 4 6</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //4 向顺序表头部插入新元素</span><br><span class="line">    sqList_headAdd (manager,8);</span><br><span class="line">    sqList_headAdd (manager,4);</span><br><span class="line">    sqList_headAdd (manager,8);</span><br><span class="line">    sqList_headAdd (manager,8);</span><br><span class="line"></span><br><span class="line">    //5 遍历顺序表</span><br><span class="line">    sqList_print (manager);     //8 8 4 8 5 2 1 4 6</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //6 删除顺序表中元素</span><br><span class="line">    sqList_delAdd (manager,20);</span><br><span class="line">    sqList_delAdd (manager,5);</span><br><span class="line">    sqList_delAdd (manager,1);</span><br><span class="line">    sqList_delAdd (manager,6);</span><br><span class="line"></span><br><span class="line">    //7 遍历顺序表</span><br><span class="line">    sqList_print (manager);     //8 8 4 8 2 4</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 一 顺序表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构三（双向链表DoubleLinkedList）</title>
      <link href="/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/"/>
      <url>/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个双向链表实现对双向链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历双向链表</p><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表" title="双向链表"></p><p>More info: <a href="https://github.com/gybpersist/DoubleLinkedList">DoubleLinkedList</a></p><h2 id="构造双向链表（DoubleLinkedList）"><a href="#构造双向链表（DoubleLinkedList）" class="headerlink" title="构造双向链表（DoubleLinkedList）"></a>构造双向链表（DoubleLinkedList）</h2><h3 id="构造双向链表的结点-双向链表中所有结点的数据类型应该是相同的"><a href="#构造双向链表的结点-双向链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造双向链表的结点 双向链表中所有结点的数据类型应该是相同的"></a>构造双向链表的结点 双向链表中所有结点的数据类型应该是相同的</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">typedef struct DoubleLinkedList &#123;</span><br><span class="line">    dataType_t data;                 //双向链表的数据域</span><br><span class="line">    struct DoubleLinkedList *prev;      //双向链表的后继指针域</span><br><span class="line">    struct DoubleLinkedList *next;      //双向链表的前驱指针域</span><br><span class="line">&#125; DoubleLList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（DoubleLList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（DoubleLList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（DoubleLList_Create）"></a>创建一个空链表，空链表应该有一个头结点（DoubleLList_Create）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t* DoubleLList_Create(void)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 创建一个头结点并给头结点申请内存</span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)calloc(1,sizeof (DoubleLList_t));</span><br><span class="line">    if(Head == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for Head is Failed!\n&quot;);</span><br><span class="line">        exit(-1);       //退出程序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 对头结点进行初始化</span><br><span class="line">    Head-&gt;prev = NULL;</span><br><span class="line">    Head-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //1.3 把头结点地地址返回</span><br><span class="line">    return Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleLList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleLList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleLList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleLList_NewNode）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t *DoubleLList_NewNode(dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 创建一个新结点并给新结点申请内存</span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) calloc(1, sizeof(DoubleLList_t));</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 对新结点进行初始化（数据域 指针域2个）</span><br><span class="line">    NewNode-&gt;prev = NULL;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //2.3 把新结点地地址返回</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（DoubleLList-HeadInsert）"><a href="#头插（DoubleLList-HeadInsert）" class="headerlink" title="头插（DoubleLList_HeadInsert）"></a>头插（DoubleLList_HeadInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleLList_HeadInsert(DoubleLList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.3 如果链表为非空，则把新结点插入到链表头部</span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line">    NewNode-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（DoubleLList-TailInsert）"><a href="#尾插（DoubleLList-TailInsert）" class="headerlink" title="尾插（DoubleLList_TailInsert）"></a>尾插（DoubleLList_TailInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleLList_TailInsert(DoubleLList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.3 如果链表为非空，则把新结点插入到链表尾部</span><br><span class="line">    //对链表的头结点进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line">    while (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（DoubleLList-DestInsert）"><a href="#指定插入（DoubleLList-DestInsert）" class="headerlink" title="指定插入（DoubleLList_DestInsert）"></a>指定插入（DoubleLList_DestInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleLList_DestInsert(DoubleLList_t *Head,dataType_t destval,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span><br><span class="line">    //对链表的首结点进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != NULL &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        //把结点的直接后继作为新的结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        if(Phead == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.4 说明找到目标结点，则把新结点加入到目标结点后面</span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（DoubleLList-Print）"><a href="#遍历链表（DoubleLList-Print）" class="headerlink" title="遍历链表（DoubleLList_Print）"></a>遍历链表（DoubleLList_Print）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleLList_Print(DoubleLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //对链表的头结点的地址进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    //判断当前链表是否为空，为空则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Current linkedList is empty!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断当前链表不为空则继续遍历</span><br><span class="line">    //记录第几个</span><br><span class="line">    int i=0;</span><br><span class="line">    while (Phead-&gt;next != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        //输出头结点的直接后继的数据域</span><br><span class="line">        printf(&quot;Date[%d] = %d\n&quot;,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除首结点（DoubleLList-HeadDel）"><a href="#头删-删除首结点（DoubleLList-HeadDel）" class="headerlink" title="头删 删除首结点（DoubleLList_HeadDel）"></a>头删 删除首结点（DoubleLList_HeadDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleLList_HeadDel(DoubleLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //7.1 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7.2 对链表的首结点进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //7.3 链表非空 删除首结点</span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">    //7.4 原先首结点的 next指向NULL，并释放首结点的内存</span><br><span class="line">    Phead-&gt;next = NULL;</span><br><span class="line">    Phead-&gt;prev = NULL;</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（DoubleLList-TailDel）"><a href="#尾删-删除尾结点（DoubleLList-TailDel）" class="headerlink" title="尾删 删除尾结点（DoubleLList_TailDel）"></a>尾删 删除尾结点（DoubleLList_TailDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleLList_TailDel(DoubleLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //8.1 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //8.2 记录当前结点的地址</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //记录当前结点的直接前驱</span><br><span class="line">    DoubleLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    //8.3 链表非空 删除尾结点</span><br><span class="line">    while (Phead-&gt;next != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DoubleLList_t *Head = DoubleLList_Create();            //创建链表</span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadInsert(Head,5);            //头插</span><br><span class="line">    DoubleLList_HeadInsert(Head,8);</span><br><span class="line">    DoubleLList_HeadInsert(Head,1);</span><br><span class="line">    DoubleLList_HeadInsert(Head,6);</span><br><span class="line">    DoubleLList_HeadInsert(Head,3);</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        //3 6 1 8 5</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailInsert(Head,4);               //尾插</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        //3 6 1 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    DoubleLList_DestInsert(Head,1,9);     //destval后面插入</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         //遍历链表 3 6 1 9 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadDel(Head);                        //头删</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         //遍历链表 6 1 9 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailDel(Head);                        //尾删</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         //遍历链表 6 1 9 8 5</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line"></span><br><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line">Date[6] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 9</span><br><span class="line">Date[5] = 8</span><br><span class="line">Date[6] = 5</span><br><span class="line">Date[7] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 6</span><br><span class="line">Date[2] = 1</span><br><span class="line">Date[3] = 9</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line">Date[6] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 6</span><br><span class="line">Date[2] = 1</span><br><span class="line">Date[3] = 9</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//构造双向链表的结点 双向链表中所以结点的数据类型应该是相同的</span><br><span class="line">typedef struct DoubleLinkedList &#123;</span><br><span class="line">    dataType_t data;                 //双向链表的数据域</span><br><span class="line">    struct DoubleLinkedList *prev;      //双向链表的后继指针域</span><br><span class="line">    struct DoubleLinkedList *next;      //双向链表的前驱指针域</span><br><span class="line">&#125; DoubleLList_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//1 创建一个空链表，空链表应该有一个头结点</span><br><span class="line">DoubleLList_t* DoubleLList_Create(void)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 创建一个头结点并给头结点申请内存</span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)calloc(1,sizeof (DoubleLList_t));</span><br><span class="line">    if(Head == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for Head is Failed!\n&quot;);</span><br><span class="line">        exit(-1);       //退出程序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 对头结点进行初始化</span><br><span class="line">    Head-&gt;prev = NULL;</span><br><span class="line">    Head-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //1.3 把头结点地地址返回</span><br><span class="line">    return Head;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">DoubleLList_t *DoubleLList_NewNode(dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 创建一个新结点并给新结点申请内存</span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) calloc(1, sizeof(DoubleLList_t));</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 对新结点进行初始化（数据域 指针域2个）</span><br><span class="line">    NewNode-&gt;prev = NULL;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //2.3 把新结点地地址返回</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//3 在链表中 头插</span><br><span class="line">bool DoubleLList_HeadInsert(DoubleLList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = NULL; // 新节点是链表最后一个节点，next 指针置为 NULL</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.3 如果链表为非空，则把新结点插入到链表头部</span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//4 在链表中 尾部插</span><br><span class="line">bool DoubleLList_TailInsert(DoubleLList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.3 如果链表为非空，则把新结点插入到链表尾部</span><br><span class="line">    //对链表的头结点进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line">    while (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//5 在链表中 指定插入</span><br><span class="line">bool DoubleLList_DestInsert(DoubleLList_t *Head,dataType_t destval,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span><br><span class="line">    //对链表的首结点进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != NULL &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        //把结点的直接后继作为新的结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        if(Phead == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.4 说明找到目标结点，则把新结点加入到目标结点后面</span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//6 遍历链表</span><br><span class="line">bool DoubleLList_Print(DoubleLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //对链表的头结点的地址进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    //判断当前链表是否为空，为空则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Current linkedList is empty!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断当前链表不为空则继续遍历</span><br><span class="line">    //记录第几个</span><br><span class="line">    int i=0;</span><br><span class="line">    while (Phead-&gt;next != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        //输出头结点的直接后继的数据域</span><br><span class="line">        printf(&quot;Date[%d] = %d\n&quot;,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//7 头删 删除首结点</span><br><span class="line">bool DoubleLList_HeadDel(DoubleLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //7.1 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7.2 对链表的首结点进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //7.3 链表非空 删除首结点</span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">    //7.4 原先首结点的 next指向NULL，并释放首结点的内存</span><br><span class="line">    Phead-&gt;next = NULL;</span><br><span class="line">    Phead-&gt;prev = NULL;</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//8 尾删 删除尾结点</span><br><span class="line">bool DoubleLList_TailDel(DoubleLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //8.1 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //8.2 记录当前结点的地址</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //记录当前结点的直接前驱</span><br><span class="line">    DoubleLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    //8.3 链表非空 删除尾结点</span><br><span class="line">    while (Phead-&gt;next != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DoubleLList_t *Head = DoubleLList_Create();            //创建链表</span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadInsert(Head,5);            //头插</span><br><span class="line">    DoubleLList_HeadInsert(Head,8);</span><br><span class="line">    DoubleLList_HeadInsert(Head,1);</span><br><span class="line">    DoubleLList_HeadInsert(Head,6);</span><br><span class="line">    DoubleLList_HeadInsert(Head,3);</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        //3 6 1 8 5</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailInsert(Head,4);               //尾插</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        //3 6 1 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    DoubleLList_DestInsert(Head,1,9);     //destval后面插入</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         //遍历链表 3 6 1 9 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadDel(Head);                        //头删</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         //遍历链表 6 1 9 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailDel(Head);                        //尾删</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         //遍历链表 6 1 9 8 5</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 三 双向链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构—双向链表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
