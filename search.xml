<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>汇总</title>
      <link href="/2025/05/21/%E6%B1%87%E6%80%BB/%E6%B1%87%E6%80%BB/"/>
      <url>/2025/05/21/%E6%B1%87%E6%80%BB/%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="第01章-C语言入门"><a href="#第01章-C语言入门" class="headerlink" title="第01章_C语言入门"></a>第01章_C语言入门</h1><h2 id="本章专题脉络"><a href="#本章专题脉络" class="headerlink" title="本章专题脉络"></a>本章专题脉络</h2><p> <img src="/img/images/%E7%AC%AC1%E7%AB%A0_C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8.png" alt="第1章_C语言入门" title="第1章_C语言入门"></p><h2 id="1、初识计算机语言"><a href="#1、初识计算机语言" class="headerlink" title="1、初识计算机语言"></a>1、初识计算机语言</h2><h3 id="1-1-计算机语言是什么"><a href="#1-1-计算机语言是什么" class="headerlink" title="1.1 计算机语言是什么"></a>1.1 计算机语言是什么</h3><ul><li><p><strong>人类语言</strong>：是人与人之间用于沟通的一种方式。例如：中国人与中国人用普通话沟通。而中国人要和英国人交流，可以使用普通话或英语。</p></li><li><p><strong>计算机编程语言</strong>，就是人与计算机交流的方式。人们可以使用<code>编程语言</code>对计算机下达<code>命令</code>，让计算机完成人们需要的功能。</p><ul><li>计算机语言有很多种。如：C 、C++、Java、Go、JavaScript、Python，Scala等。</li></ul></li></ul><blockquote><p>体会：语言 &#x3D; 语法 + 逻辑</p></blockquote><h3 id="1-2-计算机语言简史"><a href="#1-2-计算机语言简史" class="headerlink" title="1.2 计算机语言简史"></a>1.2 计算机语言简史</h3><ul><li><p><strong>第一代：机器语言（相当于人类的石器时代）</strong></p><ul><li><p>1946年2月14日，世界上第一台计算机<code>ENAC</code>诞生，使用的是最原始的<code>穿孔卡片</code>。这种卡片上使用的是用<code>二进制代码</code>表示的语言，与人类语言差别极大，这种语言就称为<code>机器语言</code>。比如一段典型的机器码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.0000,0000,000000010000 代表 LOAD A, 16</span><br><span class="line">2.0000,0001,000000000001 代表 LOAD B, 1</span><br><span class="line">3.0001,0001,000000010000 代表 STORE B, 16</span><br></pre></td></tr></table></figure></li><li><p>这种语言本质上是计算机能识别的<code>唯一语言</code>，人类很难理解。可以大胆想象”<code>此时的程序员99.9%都是异类！</code>“</p><p><img src="/images/image-20220309223406537.png" alt="image-20220309223406537"></p></li></ul></li><li><p><strong>第二代：汇编语言（相当于人类的青铜&amp;铁器时代）</strong></p><ul><li><p>使用英文缩写的<code>助记符</code>来表示基本的操作，这些助记符构成了汇编语言的基础。比如：<code>LOAD</code>、<code>MOVE</code>等，使人更容易使用。因此，汇编语言也称为<code>符号语言</code>。</p></li><li><p>优点：能编写<code>高效率</code>的程序。</p></li><li><p>缺点：汇编语言是<code>面向机器的</code>，不同计算机会有不同的汇编语言，程序不易移植。</p><p><img src="/images/1689152350231.png" alt="1689152350231"></p></li><li><p>目前仍然应用于工业电子编程领域、软件的加密解密、计算机病毒分析等。</p></li></ul></li><li><p><strong>第三代：高级语言（相当于人类的信息时代）</strong></p><ul><li><p>高级语言，是一种<code>接近于人们使用习惯</code>的程序设计语言。它允许程序员使用<code>接近日常英语</code>的指令来编写程序，程序中的符号和算式也与<code>日常用的数学式子</code>差不多，接近于自然语言和数学语言，容易为人们掌握。比如：</p><p><img src="/images/1689152910950.png" alt="1689152910950"></p></li><li><p>高级语言<code>独立于计算机硬件</code>，有一定的通用性；计算机不能直接识别和执行用高级语言编写的程序，需要使用<strong>编译器或者解释器</strong>，<code>转换为机器语言</code>才能被识别和执行。</p><p><img src="/images/1689153225780.png" alt="1689153225780"></p></li><li><p>使用普遍的高级语言有Fortran、ALGOL、Basic、COBOL、LISP、Pascal、PROLOG、C、C++、VC、VB、Delphi、Java等。</p></li></ul></li></ul><h2 id="2、初识C语言"><a href="#2、初识C语言" class="headerlink" title="2、初识C语言"></a>2、初识C语言</h2><h3 id="2-1-C语言的由来"><a href="#2-1-C语言的由来" class="headerlink" title="2.1 C语言的由来"></a>2.1 C语言的由来</h3><p><strong>C 语言最初是作为 Unix 系统的开发工具而发明的。</strong></p><p>1969年，美国贝尔实验室的肯·汤普森（Ken Thompson）与丹尼斯·里奇（Dennis Ritchie）一起开发了Unix 操作系统。Unix 是用<code>汇编语言</code>写的，依赖于计算机硬件。为了程序的<code>可读性</code>和<code>可移植性</code>，他们决定使用高级语言重写。但是，当时的高级语言无法满足他们的要求，汤普森就在 BCPL 语言的基础上发明了 <code>B 语言</code>。</p><p>1972年，丹尼斯·里奇（Dennis Ritchie）在 B 语言的基础上重新设计了一种新语言，这种新语言取代了 B 语言，称为<code> C 语言</code>。</p><p>1973年，<code>整个 Unix 系统都使用 C 语言重写</code>。</p><p><img src="/images/image-20230821142911092.png" alt="image-20230821142911092"></p><p>此后，这种语言快速流传，广泛用于各种操作系统和系统软件的开发。如UNIX、MS-DOS、Microsoft Windows及Linux等。</p><p><img src="/images/image-20230808143350533.png" alt="image-20230808143350533"></p><p>1988年，美国国家标准协会（ANSI）正式将<code> C语言标准化</code>，标志着 C 语言开始稳定和规范化。</p><h3 id="2-2-为什么要学习C语言"><a href="#2-2-为什么要学习C语言" class="headerlink" title="2.2 为什么要学习C语言"></a>2.2 为什么要学习C语言</h3><p>1、<strong>C语言具有可移植性好、跨平台的特点</strong>，用C编写的代码可以在不同的操作系统和硬件平台上编译和运行。</p><ul><li>C 语言的原始设计目的，是将 Unix 系统移植到其他计算机架构，这使得它从一开始就非常注重可移植性。</li></ul><p>2、**C语言在许多领域应用广泛。**掌握C语言可以让你有更多就业机会。</p><ul><li><code>操作系统</code>：C 广泛用于开发操作系统，如 Unix、Linux 和 Windows。</li><li><code>嵌入式系统</code>：C 是一种用于开发嵌入式系统（如微控制器、微处理器和其他电子设备）的流行语言。</li><li><code>系统软件</code>：C用于开发设备驱动程序、编译器和汇编器等系统软件。</li><li><code>网络</code>：C 语言广泛用于开发网络应用程序，例如 Web 服务器、网络协议和网络驱动程序。</li><li><code>数据库系统</code>：C 用于开发数据库系统，例如 Oracle、MySQL 和 PostgreSQL。</li><li><code>游戏</code>：由于 C 能够处理低级硬件交互，因此经常用于开发计算机游戏。</li><li><code>人工智能</code>：C 用于开发人工智能和机器学习应用程序，例如神经网络和深度学习算法。</li><li><code>科学应用</code>：C 用于开发科学应用程序，例如仿真软件和数值分析工具。</li><li><code>金融应用</code>：C用于开发股票市场分析和交易系统等金融应用。</li></ul><p>3、C 语言能够直接对硬件进行操作、管理内存、跟操作系统对话，这使得它是一种非常接近底层的语言，非常适合写需要<strong>跟硬件交互、有极高性能要求的程序</strong>。</p><p>4、<strong>学习C语言有助于快速上手其他编程语言</strong>，比如C++（原先是C语言的一个扩展，在C语言的基础上嫁接了面向对象编程）、C#、Java、PHP、Javascript、Perl等。这些语言都继承或深受C语言的影响和启发。</p><p>5、C 语言长盛不衰。至今，<strong>依然是最广泛使用、最流行的编程语言之一</strong>。包括很多大学将C语言作为计算机教学的入门语言，拥有庞大而活跃的用户社区，这意味着有许多资源和库可供开发人员使用。</p><h3 id="2-3-计算机语言排行榜"><a href="#2-3-计算机语言排行榜" class="headerlink" title="2.3 计算机语言排行榜"></a>2.3 计算机语言排行榜</h3><p>TIOBE （<a href="https://www.tiobe.com/tiobe-index/%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%81%E8%A1%8C%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%8E%92%E8%A1%8C%EF%BC%8C%E6%AF%8F%E6%9C%88%E6%9B%B4%E6%96%B0%E3%80%82%E6%8E%92%E5%90%8D%E6%9D%83%E9%87%8D%E5%9F%BA%E4%BA%8E%E4%B8%96%E7%95%8C%E8%8C%83%E5%9B%B4%E5%86%85">https://www.tiobe.com/tiobe-index/）是一个流行编程语言排行，每月更新。排名权重基于世界范围内</a> 工程师数量，Google、Bing、Yahoo! 、Wikipedia、Amazon、Youtube和百度这些主流的搜索引擎，也将作为排名权重的参考指标。</p><p><img src="/images/image-20230821142412443.png" alt="image-20230821142412443"></p><p>计算机走势图：</p><p><img src="/images/image-20230821142441945.png" alt="image-20230821142441945"></p><h3 id="2-4-网友一言话C"><a href="#2-4-网友一言话C" class="headerlink" title="2.4 网友一言话C"></a>2.4 网友一言话C</h3><p><a href="https://www.nowcoder.com/stack/209">https://www.nowcoder.com/stack/209</a></p><p><img src="/images/image-20230819162927908.png" alt="image-20230819162927908"></p><h3 id="2-5-C语言的版本选择"><a href="#2-5-C语言的版本选择" class="headerlink" title="2.5 C语言的版本选择"></a>2.5 C语言的版本选择</h3><p>随着微型计算机的日益普及，出现了许多C语言版本。</p><p><strong>版本1：K＆R C</strong></p><p>K&amp;R C 指的是 C 语言的原始版本。1978年，C 语言的发明者布莱恩·柯林（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）合写了一本著名的教材《C 编程语言》（The C programming language）。</p><p>由于 C 语言还没有成文的语法标准，这本书就成了公认标准，以两位作者的姓氏首字母作为版本简称“K&amp;R C”。</p><p><strong>版本2：ANSI C（又称 C89 或 C90）</strong></p><p>C 语言的原始版本非常简单，对很多情况的描述非常模糊，加上 C 语法依然在快速发展，要求将 C 语言标准化的呼声越来越高。</p><p>1989年，美国国家标准协会（ANSI）制定了一套 C 语言标准，并于次年被国际标准化组织（ISO）通过。它被称为“ANSI C”，也可以按照发布年份，称为“C89 或 C90”。</p><p><strong>版本3：C99</strong></p><p>C 语言标准的第一次<code>大型修订</code>，发生在1999年，增加了许多语言特性，比如双斜杠（ &#x2F;&#x2F; ）的注释语法，可变长度数组、灵活的数组成员、复数、内联函数和指定的初始值设定项。这个版本称为 C99，<code>是目前最流行的 C 版本</code>。</p><p><strong>版本4：C11</strong></p><p>2011年，标准化组织再一次对C 语言进行修订，增加了_Generic、static_assert 和原子类型限定符。这个版本称为C11。</p><blockquote><p>需要强调的是，修订标准的原因不是因为原标准不能用，而是需要跟进新的技术。</p></blockquote><p><strong>版本5：C17</strong></p><p>C11 标准在2017年进行了修补，但发布是在2018年。新版本只是解决了 C11 的一些缺陷，没有引入任何新功能。这个版本称为 C17。</p><p><strong>版本6：C23</strong></p><p>2023年预计发布，计划进一步增强安全性，消除实现定义的行为，引入模块化语言概念等新特性，使C语言在安全和可靠性方面有重大提高。</p><h2 id="3、第一个C程序的编写-编译-运行"><a href="#3、第一个C程序的编写-编译-运行" class="headerlink" title="3、第一个C程序的编写-&gt;编译-&gt;运行"></a>3、第一个C程序的编写-&gt;编译-&gt;运行</h2><h3 id="3-1-步骤1：HelloWorld的编写"><a href="#3-1-步骤1：HelloWorld的编写" class="headerlink" title="3.1 步骤1：HelloWorld的编写"></a>3.1 步骤1：HelloWorld的编写</h3><p>C 语言的源代码文件，以<strong>后缀名 .c 结尾</strong>。下面是一个简单的 C 程序 <code>Hello.c</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>              </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>                  </span><br><span class="line">&#123;                               </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,world!!\n&quot;</span>); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-步骤2：编译器的安装与配置"><a href="#3-2-步骤2：编译器的安装与配置" class="headerlink" title="3.2 步骤2：编译器的安装与配置"></a>3.2 步骤2：编译器的安装与配置</h3><p>C 语言是一种<code>编译型语言</code>，源码都是<code>文本文件</code>，本身无法执行。必须通过编译器，生成二进制的可执行文件，才能执行。</p><p>目前，最常见的 C 语言编译器是自由软件基金会推出的 <code>GCC 编译器</code>，可以免费使用。Linux 和 Mac 系统可以直接安装 GCC，Windows 系统可以安装 <code>MinGW</code>。</p><blockquote><p>补充知识：MinGW和GCC的区别：</p><p>GCC是一个跨平台的编译器集合，可用于多种操作系统和处理器架构，包括Windows；而MinGW是GCC在Windows平台上的移植版本，主要用于在Windows上本地编译C和C++代码。</p></blockquote><p>在Windows下，MinGW的详细安装和配置见<code>《第01章附录：MinGW编译器的安装和配置.md》</code>。</p><h3 id="3-3-步骤3：编译和运行"><a href="#3-3-步骤3：编译和运行" class="headerlink" title="3.3 步骤3：编译和运行"></a>3.3 步骤3：编译和运行</h3><p>编译器将代码从文本翻译成二进制指令的过程，就称为编译阶段，又称为“编译时”（compile time），跟运行阶段（又称为“运行时”）相区分。</p><p>假设你已经安装好了 GCC 编译器，可以通过<code>win+r</code>打开cmd命令行，在Hello.c文件所在目录下执行下面的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc Hello.c</span><br></pre></td></tr></table></figure><p><img src="/images/image-20230821203629981.png" alt="image-20230821203629981"></p><p>上面命令使用 gcc 编译器，将源文件 Hello.c 编译成二进制代码。</p><p>运行这个命令以后，默认会在当前目录下生成一个编译产物文件 a.exe。执行该文件，就会在屏幕上输出 Hello World 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; a.exe</span><br><span class="line">hello,world!!</span><br></pre></td></tr></table></figure><p><img src="/images/image-20230821203807040.png" alt="image-20230821203807040"></p><p><strong>GCC 的 -o 参数（output 的缩写）可以指定编译产物的文件名。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -o Hello Hello.c</span><br></pre></td></tr></table></figure><img src="images/image-20230821204057346.png" alt="image-20230821204057346" style="zoom:80%;" /><p>上面命令的 <code>-o Hello</code> 指定，编译得到的可执行文件名为 Hello.exe ，取代默认的 a.exe。执行该文件，也会得到同样的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Hello.exe</span><br><span class="line">hello,world!!</span><br></pre></td></tr></table></figure><p><img src="/images/image-20230821204306119.png" alt="image-20230821204306119"></p><p><strong>GCC 的 <code>-std= 参数</code>（standard 的缩写）还可以指定按照哪个 C 语言的标准进行编译。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -std=c99 Hello.c</span><br></pre></td></tr></table></figure><p>上面命令指定按照 C99 标准进行编译。</p><h2 id="4、IDE的使用"><a href="#4、IDE的使用" class="headerlink" title="4、IDE的使用"></a>4、IDE的使用</h2><p>IDE(Integrated Development Environment，集成开发环境)：相较于文本开发工具，IDE可以把代码编写，编译，执行，调试等多种功能综合到一起的开发工具。</p><h3 id="4-1-开发工具介绍"><a href="#4-1-开发工具介绍" class="headerlink" title="4.1 开发工具介绍"></a>4.1 开发工具介绍</h3><h4 id="方式1：本地安装的IDE工具"><a href="#方式1：本地安装的IDE工具" class="headerlink" title="方式1：本地安装的IDE工具"></a>方式1：本地安装的IDE工具</h4><p><strong>1. Code::Block</strong></p><p>Code::Block是一个免费的跨平台IDE，它支持C、C++和Fortan程序的开发。Code::Block的最大特点是它支持通过插件的方式对IDE自身功能进行扩展，这使得Code::Block具有很强的灵活性，方便用户使用。</p><p>官网地址：<a href="https://www.codeblocks.org/">https://www.codeblocks.org</a></p><p><strong>2. Microsoft Visual C++ 2010</strong></p><p>Visual C++ 2010，简称VC2010，是由微软开发的独立的、免费的 C&#x2F;C++ 编译工具，与Visual Basic等并列，最后微软将它们整合在一起组成了Visual Studio。</p><p>Visual C++从发布起到现在已经有10个大版本了，这里介绍的Visual C++ 2010就是Visual C++ 10，简称VC10。上朔10多年发布的Visual C++ 6.0，被称为史上最经典的VC，现在有很多企业还在用它，大量的教材基于这个版本的VC来写的。但VC6比较弱，被淘汰是迟早的。</p><p><strong>3. Microsoft Visual Studio</strong></p><p>Visual Studio（简称 VS）是由微软公司发布的集成开发环境。它包括了整个软件生命周期中所需要的大部分工具，如UML工具、代码管控工具、集成开发环境（IDE）等。</p><p>Visual Studio 支持 C&#x2F;C++、C#、F#、VB 等多种程序语言的开发和测试，可以用于生成Web应用程序，也可以生成桌面应用程序，功能十分强大。但下载和安装很可能耗时数小时，还可能会塞满磁盘。</p><p>Visual Studio 2019有三种版本：社区版(免费，不支持企业使用)，专业版(第一年1199美元&#x2F; 799美元续订)和企业版(第一年5999美元&#x2F;2569美元续订)。企业版拥有面向架构师的功能、高级调试和测试，这些功能是另两种SKU所没有的。</p><p>Visual Studio旨在成为世界上最好的IDE（集成开发环境），目前最新版本为 Visual Studio 2023。</p><blockquote><p>这就好像Office 2007是由Word 2007、Excel 2007、Access 2007等等组成的一个道理。其中Visual C++就是Visual Studio的一个重要的组成部分。</p></blockquote><p>官网地址：<a href="https://visualstudio.microsoft.com/">https://visualstudio.microsoft.com</a></p><p><strong>4. CLion</strong></p><p>CLion是一款由JetBrains推出的跨平台C&#x2F;C++集成开发环境（IDE），它具有智能编辑器、CMake构建支持、调试器、单元测试、代码分析等功能,可以极大提高C&#x2F;C++开发效率。</p><p>官网地址：<a href="https://www.jetbrains.com/clion">https://www.jetbrains.com/clion</a></p><h4 id="方式2：可在线使用的工具"><a href="#方式2：可在线使用的工具" class="headerlink" title="方式2：可在线使用的工具"></a>方式2：可在线使用的工具</h4><p>CodingGround: <a href="https://tutorialspoint.com/compile_c_online.php">https://tutorialspoint.com/compile_c_online.php</a></p><p><img src="/images/image-20230821153059391.png" alt="image-20230821153059391"></p><p>OnlineGDB: <a href="https://onlinegdb.com/online_c_compiler">https://onlinegdb.com/online_c_compiler</a></p><p><img src="/images/image-20230821153146970.png" alt="image-20230821153146970"></p><p>Lightly：<a href="https://cde2f3ce.lightly.teamcode.com/">https://cde2f3ce.lightly.teamcode.com/</a></p><p><img src="/images/image-20230821153237900.png" alt="image-20230821153237900"></p><h3 id="4-2-CLion的下载与安装"><a href="#4-2-CLion的下载与安装" class="headerlink" title="4.2 CLion的下载与安装"></a>4.2 CLion的下载与安装</h3><p>详细见<code>《第01章附录：C开发利器：CLion的使用.md》</code>。</p><h3 id="4-3-CLion中HelloWorld的执行"><a href="#4-3-CLion中HelloWorld的执行" class="headerlink" title="4.3 CLion中HelloWorld的执行"></a>4.3 CLion中HelloWorld的执行</h3><p>1）选择”New Project”：</p><img src="images/1692686679397.png" alt="1692686679397" style="zoom:80%;" /><p>2）指定创建C可执行文件、工程目录，图中的“untitled1”需要修改为自己的工程名称。如下所示：</p><img src="images/1692687949240.png" alt="1692687949240" style="zoom:80%;" /><p>3）选择C可执行文件，修改工程名称为demo1</p><img src="images/1692687854607.png" alt="1692687854607" style="zoom:80%;" /><p>4）点击“Create”进行下一步，如图所示</p><img src="images/1692688033686.png" alt="1692688033686" style="zoom:80%;" /><p>5）此处选择编译器，默认MinGW即可，点击“OK”按钮，如图所示，默认创建了main.c文件。</p><img src="images/1692688090496.png" alt="1692688090496" style="zoom:60%;" /><p>6）点击执行按钮，如下所示</p><img src="images/1692688278731.png" alt="1692688278731" style="zoom: 60%;" /><h3 id="4-4-C-程序运行机制"><a href="#4-4-C-程序运行机制" class="headerlink" title="4.4 C 程序运行机制"></a>4.4 C 程序运行机制</h3><p><strong>过程1：编辑</strong></p><p>编写C语言源程序代码，并以文件的形式存储到磁盘中。源程序文件以“<code>.c</code>”作为扩展名。</p><p><strong>过程2：编译</strong></p><p>将C语言源程序转换为<code>目标程序(或目标文件)</code>。如果程序没有错误，没有任何提示，就会生成一个扩展名为“<code>.obj</code>”的二进制文件。C语言中的每条可执行语句经过编译后最终都将被转换成二进制的机器指令。</p><p><strong>过程3：链接&#x2F;连接</strong></p><p>将编译形成的目标文件“.obj”和库函数及其他目录文件连接&#x2F;链接，形成统一的<code>可执行的</code>二进制文件“<code>.exe</code>”。</p><blockquote><p>为什么需要链接库文件呢？</p><p>因为我们的C程序中会使用 C程序库的内容，比如&lt;stdio.h&gt; 、&lt;stdlib.h&gt; 中的函数printf()、system()等，这些函数不是程序员自己写的，而是C程序库中提供的，因此需要链接。链接后，生成的.exe 文件，比obj 文件大了很多。</p></blockquote><p><strong>过程4：运行</strong></p><p>有了可执行的exe文件，我们可以在控制台下直接运行此exe文件。</p><p><img src="/images/image-20230810153413126.png" alt="image-20230810153413126"></p><blockquote><p>注意：</p><p>对修改后的xxx.c源文件需要<strong>重新编译、链接</strong>，生成新的exe文件后，再执行，才能生效。</p></blockquote><p>练习：</p><blockquote><p>计算机高级语言程序的运行方法有编译执行和解释执行两种，以下叙述中正确的是（　　）。<br>A．C语言程序仅可以编译执行<br>B．C语言程序仅可以解释执行<br>C．C语言程序既可以编译执行，又可以解释执行<br>D．以上说法都不对</p><p>【答案】A</p><p>【解析】编译执行是指程序执行前需要一个专门的编译过程把程序编译成机器语言的文件，再次运行时不需要重新翻译，执行效率高；解释执行是指每个语句都是执行的时候才翻译，执行效率低。用C语言编写的程序必须经过编译器编译后，转换为二进制的机器指令来运行。</p></blockquote><p>练习：</p><blockquote><p>以下叙述中错误的是（　　）。<br>A．C语言的可执行程序是由一系列机器指令构成的<br>B．用C语言编写的源程序不能直接在计算机上运行<br>C．通过编译得到的二进制目标程序需要链接才可以运行<br>D．在没有安装C语言集成开发环境的机器上不能运行C源程序生成的exe文件</p><p>【答案】D</p><p>【解析】A项正确，C语言的可执行程序是由一系列机器指令组成的；BC项正确，用C语言编写的源程序必须经过编译，生成二进制目标代码，再经过连接才能运行；D项错误，C语言经过编译链接后的二进制目标代码可以脱离C语言集成开发环境独立运行。答案选择D选项。</p></blockquote><h2 id="5、注-释-comment"><a href="#5、注-释-comment" class="headerlink" title="5、注 释(comment)"></a>5、注 释(comment)</h2><img src="images/image-20220610113151774.png" alt="image-20220610113151774" style="zoom: 67%;" /><ul><li><p>什么是注释？</p><ul><li>源文件中用于<code>解释</code>、<code>说明</code>程序的文字就是注释。</li><li>注释只是给人看的，程序执行时，<code>编译器会忽略注释</code>，注释对代码执行没有影响</li></ul></li><li><p>注释是一个程序员必须要具有的良好编程习惯。实际开发中，程序员可以先将自己的<code>思想</code>通过注释整理出来，再用<code>代码</code>去体现。</p><blockquote><p>程序员最讨厌两件事：</p><ul><li><p>一件是自己写代码被要求加注释</p></li><li><p>另一件是接手别人代码，发现没有注释</p></li></ul></blockquote></li><li><p>不加注释的危害</p><p><img src="/images/%E6%96%B0%E6%9D%A5%E7%9A%84%E8%8F%9C%E9%B8%9F%E7%A8%8B%E5%BA%8F%E5%91%98%E9%97%AF%E7%A5%B8%E4%BA%86%E3%80%82%E3%80%82%E3%80%82%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%A5%BD%E5%A4%9A%E5%B9%B4%E9%83%BD%E6%B2%A1%E4%BA%BA%E6%95%A2%E5%8A%A8%E8%BF%87%E7%9A%84.gif"></p></li><li><p>C语言中的注释类型：</p><ul><li><strong>单行注释</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure><ul><li><strong>多行注释(或块注释)</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是第一行注释</span></span><br><span class="line"><span class="comment">  这是第二行注释</span></span><br><span class="line"><span class="comment">  这是第三行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 我是被注释的文字 */</span></span><br></pre></td></tr></table></figure></li><li><p>举例</p><ul><li>举例1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>              <span class="comment">//这是编译预处理指令</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>                  <span class="comment">//定义主函数</span></span><br><span class="line">&#123;                               <span class="comment">//函数开始的标志</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);    <span class="comment">//输出所指定的一行信息</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                   <span class="comment">//函数执行完毕时返回函数值0</span></span><br><span class="line">&#125;                               <span class="comment">//函数结束的标志</span></span><br></pre></td></tr></table></figure><ul><li>举例2</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>; <span class="comment">// 这里定义了一个变量</span></span><br></pre></td></tr></table></figure><ul><li>举例3</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>); </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">printf(&quot;2&quot;);</span></span><br><span class="line"><span class="comment">printf(&quot;3&quot;);  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;4&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>举例4</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">char</span>* s <span class="comment">/* file name */</span>, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure></li><li><p>注意：</p><ol><li><p>多行注释不能嵌套使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我是注释信息1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我是注释信息2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">我是注释信息<span class="number">3</span></span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p>双引号内使用注释，会被当做普通字符串看待，失去注释作用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;// hello /* atguigu */ &quot;</span>);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>一个段子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">A：嘿 <span class="comment">//是什么意思啊？</span></span><br><span class="line">B：嘿.</span><br><span class="line">A：呃 我问你<span class="comment">//是什么意思？</span></span><br><span class="line">B：问吧.</span><br><span class="line">A：我刚才不是问了么？</span><br><span class="line">B：啊？</span><br><span class="line">A：你再看看记录...</span><br><span class="line">B：看完了.</span><br><span class="line">A：......所以<span class="comment">//是啥？</span></span><br><span class="line">B：所以什么？</span><br><span class="line">A：你存心耍我呢吧？</span><br><span class="line">B：没有啊 你想问什么？</span><br><span class="line">……</span><br><span class="line">不断循环之后，A一气之下和B绝交，自己苦学程序。</span><br><span class="line">N年之后，A终于修成正果，回想起B，又把聊天记录翻出来看，这时，他突然发现B没有耍他……</span><br><span class="line">而他自己也不知道当年他问B的究竟是什么问题……</span><br></pre></td></tr></table></figure></li></ul><p>练习：</p><blockquote><p>以下叙述中错误的是（　　）。<br>A．C语言中的每条可执行语句和非执行语句最终都将被转换成二进制的机器指令<br>B．C程序经过编译、链接步骤之后才能形成一个真正可执行的二进制机器指令文件<br>C．用C语言编写的程序称为源程序，它以ASCII代码形式存放在一个文本文件中<br>D．C语言源程序经编译后生成后缀为.obj的目标程序</p><p>【答案】A</p><p>【解析】A项错误，注释语句不会被翻译成二进制的机器指令。C源程序经过C编译程序编译之后生成后缀为.obj的二进制文件（称为目标文件），然后由“链接程序”（Link）的软件把.obj文件与各种库函数连接起来生成一个后缀为.exe的可执行文件。答案选择A选项。</p></blockquote><h2 id="6、HelloWorld的剖析"><a href="#6、HelloWorld的剖析" class="headerlink" title="6、HelloWorld的剖析"></a>6、HelloWorld的剖析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>              </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>                  </span><br><span class="line">&#123;                               </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-规范的代码风格"><a href="#6-1-规范的代码风格" class="headerlink" title="6.1 规范的代码风格"></a>6.1 规范的代码风格</h3><p><strong>正确的缩进和空白</strong></p><ol><li><p>使用一次tab操作，实现缩进，默认整体向右边移动。相反，使用shift+tab整体向左移</p></li><li><p>运算符两边习惯性各加一个空格。比如：<code>2 + 4 * 5</code>。</p></li><li><p>可以使用代码格式化快捷键 ctrl+alt+L。(在CLion中使用)</p></li></ol><p><strong>代码块的风格</strong></p><p>1）行尾风格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;                                      </span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>2）次行风格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;                                      </span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>正确的注释和注释风格：</strong></p><p>1）如果注释一个函数，可以使用多行注释(或块注释)。</p><p>2）如果注释函数中的某一行语句，可以使用单行注释。</p><h3 id="6-2-代码细节剖析"><a href="#6-2-代码细节剖析" class="headerlink" title="6.2 代码细节剖析"></a>6.2 代码细节剖析</h3><h4 id="①-main"><a href="#①-main" class="headerlink" title="① main()"></a>① main()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>每一个程序(或工程)可以定义很多函数(后面讲)，但有且只有一个main()函数，作为程序执行的入口，在 main()函数结尾结束整个程序的运行。</li><li>空括号()，表示 main 不接受任何参数。</li><li>写在main之前的“int”称为关键字，代表数据类型是整型。它是main()的返回值类型。即在执行main()函数后会得到一个整型值(即函数值)。</li><li>C 语言约定： <code>return 0</code>，表示main()函数终止运行，且运行成功；如果返回其它非零整数，就表示运行失败。默认情况下，如果 main() 里面省略 <code>return 0</code> 这一行，编译器会自动加上，但是为了保持统一的代码风格，不建议省略。</li></ul><h4 id="②-函数体"><a href="#②-函数体" class="headerlink" title="② 函数体"></a>② 函数体</h4><ul><li><p>一对花括号{}定义了函数的主体，所有函数都必须以大括号开头和结尾，成对出现。</p></li><li><p>C 程序中的函数体指的是作为该函数一部分的语句。它可以是任何操作，比如搜索、排序、打印等。</p></li><li><p>每一个执行语句后面都会有一个英文分号“;”作为语句结束的标志。</p></li><li><p>一行内可写几条语句，一条语句也可写在几行上。</p></li></ul><h4 id="③-printf"><a href="#③-printf" class="headerlink" title="③ printf()"></a>③ printf()</h4><p>printf()函数是产生格式化输出的函数，作用是将参数文本输出到屏幕。它名字里面的 f 代表 format (格式化)，表示可以指定输出文本的格式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">//将字符串输出到控制台，行尾不换行</span></span><br></pre></td></tr></table></figure><p>为了让光标移到下一行的开头，可以在输出文本的结尾，添加一个换行符 \n 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="④-标准库、头文件"><a href="#④-标准库、头文件" class="headerlink" title="④ 标准库、头文件"></a>④ 标准库、头文件</h4><p>printf() 是在标准库的头文件 <code>stdio.h</code> 中定义的。要想在程序中使用这个函数，必须在源文件头部引入这个头文件。即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>何为标准库？</strong></p><p>程序需要用到的功能，不一定需要自己编写，C 语言可能已经自带了。程序员只要去调用这些自带的功能就可以了。C 语言自带的所有这些功能，统称为<code>“标准库”(standard library)</code>，包含C 内置函数、常量和头文件。</p><p>因为它们是写入标准的，到底包括哪些功能，应该怎么使用，都是规定好的，我们直接调用即可。</p><p><strong>何为头文件？</strong></p><p>不同的功能定义在不同的文件里，这些文件统称为<code>“头文件”(header file)</code>。如果系统自带某一个功能，就一定会自带描述这个功能的头文件，比如 printf() 的头文件就是系统自带的 <code>stdio.h</code> 。头文件的后缀通常是 <code>.h</code> 。</p><p><strong>预处理命令：#include命令</strong></p><p>如果要使用某个功能，就必须先加载其对应的头文件，加载使用的是 <code>#include</code> 命令，声明在各文件模块的开头。C语言中以 # 号开头的命令称为<code>预处理命令</code>。顾名思义，在编译器对当前C程序进行编译前执行预处理操作。</p><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;头文件名&gt;</span></span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>   </span></span><br></pre></td></tr></table></figure><blockquote><p>注意，加载头文件的 #include 语句不需要分号结尾</p></blockquote><p>对比写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>： <span class="comment">//编译系统在系统头文件所在目录搜索</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span>： <span class="comment">//编译系统首先在当前的源文件目录中查找 stdio.h，找不到的话，再转向系统头文件所在目录搜索。</span></span></span><br></pre></td></tr></table></figure><p><code>stdio.h</code>是系统提供的一个文件名，<code>stdio</code>是standard input &amp; output的缩写。</p><p>结论：</p><ul><li>引用系统头文件，两种形式都会可以，<code>#include &lt;&gt; </code>效率高。</li></ul><ul><li>引用用户头文件，只能使用 <code>#include &quot;&quot;</code>。</li></ul><p><strong>常用的C头文件</strong></p><ul><li><code>stdio.h</code>——定义核心输入和输出函数<ul><li>printf()、scanf()、getchar()、putchar()</li></ul></li><li><code>stdlib.h</code>——定义数值转换函数、伪随机网络生成器和内存分配</li><li><code>string.h</code>——定义字符串处理函数</li><li><code>stdint.h</code>——定义精确宽度的整数类型</li><li><code>math.h</code>——定义常用的数学函数<ul><li>sin()、sqrt()</li></ul></li><li><code>stddef.h</code>——定义了几个有用的类型和宏</li></ul><p>练习：</p><blockquote><p>以下叙述中正确的是（　）。<br>A．C程序中的注释只能出现在程序的开始位置和语句的后面<br>B．C程序书写格式严格，要求一行内只能写一个语句<br>C．C程序书写格式自由，一个语句可以写在多行上<br>D．用C语言编写的程序只能放在一个程序文件中</p><p>【答案】C</p><p>【解析】C程序的注释可以出现在C程序的任何位置，注释符号：“&#x2F;&#x2F;”或“&#x2F;<em>…</em>&#x2F;”，选项A错误。C程序中，一行内可写多个语句，每条语句用分号“；”结束，选项B错误，选项C正确。用C语言编写的程序可以放在多个程序文件中，用#include命令行实现文件包含功能，选项D错误。答案选择C选项。</p></blockquote><blockquote><p> 【中央财经大学2018研】以下叙述错误的是（　）。<br> A．在程序中凡是以“#”开始的语句行都是预处理命令行<br> B．预处理命令行的最后不能以分号表示结束<br> C．#include MAX是合法的宏定义命令行<br> D．C程序对预处理命令行的处理是在程序执行的过程中进行的</p><p> 【答案】D</p><p> 【解析】在C语言中，凡是以“#”开头的行都称为编译预处理命令行，为了区别C语句，后面是不加分号的。编译预处理是在编译程序对C源程序进行编译前执行的，而不是在程序执行过程中进行的。</p></blockquote><p><strong>注意：</strong></p><blockquote><p>学习编程最容易犯的错是<code>语法错误</code>。C语言要求必须按照语法规则编写代码。如果你的程序违反了语法规则，例如：忘记了分号、大括号、引号 或者拼错了单词等，C编译器都会报语法错误。<code>尝试着去看懂编译器会报告的错误信息</code>。</p></blockquote><h2 id="7、关于输出"><a href="#7、关于输出" class="headerlink" title="7、关于输出"></a>7、关于输出</h2><h3 id="7-1-printf-标准格式"><a href="#7-1-printf-标准格式" class="headerlink" title="7.1 printf()标准格式"></a>7.1 printf()标准格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(格式控制字符串,输出列表);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20230822164051224.png" alt="image-20230822164051224"></p><p>其中，</p><ul><li><p><code>&quot;格式控制字符串&quot;</code>是用双引号括起来的一个字符串。包括：</p><ul><li>普通字符：普通字符即需要在输出时原样输出的字符。</li><li>占位符：由“%”和格式字符组成。这个位置可以用其它值代入。</li></ul></li><li><p><code>&quot;输出列表&quot;</code>是程序需要输出的一些数据，可以是常量、变量或表达式。用于替换占位符的位置。</p></li></ul><blockquote><p>注意：printf() 参数与占位符是一一对应关系。如果参数个数少于对应的占位符， printf() 可能会输出内存中的任意值。</p></blockquote><h3 id="7-2-占位符"><a href="#7-2-占位符" class="headerlink" title="7.2 占位符"></a>7.2 占位符</h3><p>占位符的第一个字符是 <code>%</code> ，第二个字符表示占位符的类型。</p><p>printf() 的占位符有许多种类，与 C 语言的数据类型相对应。</p><p>下面按照字母顺序，列出占位符如下，方便查阅(红色为常用的)：</p><blockquote><p>%a ：浮点数(仅C99有效)<br>%A ：浮点数(仅C99有效)<br><strong>%c ：char型数据</strong><br><strong>%d ：十进制整数(int)</strong><br>%e ：使用科学计数法的浮点数，指数部分的 e 为小写<br>%E ：使用科学计数法的浮点数，指数部分的 E 为大写<br>%i ：整数，基本等同于 %d<br><strong>%f ：浮点数(float)</strong><br>%g ：6个有效数字的浮点数。整数部分一旦超过6位，就会自动转为科学计数法，指数部分的 e 为小写<br>%G ：等同于 %g ，唯一的区别是指数部分的 E 为大写<br>%hd ：十进制 short int 类型<br>%ho ：八进制 short int 类型<br>%hx ：十六进制 short int 类型<br>%hu ：unsigned short int 类型<br><strong>%ld ：十进制整数(long)</strong><br>%lo ：八进制 long int 类型<br>%lx ：十六进制 long int 类型<br>%lu ：unsigned long int 类型<br>%lld ：十进制 long long int 类型<br>%llo ：八进制 long long int 类型<br>%llx ：十六进制 long long int 类型<br>%llu ：unsigned long long int 类型<br>%le ：科学计数法表示的 long double 类型浮点数<br><strong>%lf ：十进制浮点数(double)</strong><br>%n ：已输出的字符串数量。该占位符本身不输出，只将值存储在指定变量之中<br>%o ：八进制整数<br><strong>%p ：指针</strong><br><strong>%s ：字符串</strong><br><strong>%u ：十进制无符号整数（unsigned int）</strong><br>%x ：十六进制整数<br>%zd ： size_t 类型<br>%% ：输出一个百分号</p></blockquote><h3 id="7-3-举例"><a href="#7-3-举例" class="headerlink" title="7.3 举例"></a>7.3 举例</h3><p><strong>举例1：%d</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;count is %d\n&quot;</span>,num);  <span class="comment">//输出：count is 10  </span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;There are %i students\n&quot;</span>, <span class="number">5</span>);   <span class="comment">//输出：There are 5 students</span></span><br></pre></td></tr></table></figure><p><strong>举例2：%lf 和 %f</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f = <span class="number">3.1415926535f</span>;    <span class="comment">// 单精度浮点数</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">3.1415926535</span>;  <span class="comment">// 双精度浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 %f 输出单精度浮点数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Float: %f\n&quot;</span>, f);  <span class="comment">//Float: 3.141593</span></span><br><span class="line"><span class="comment">// 使用 %lf 输出双精度浮点数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Double: %lf\n&quot;</span>, d); <span class="comment">//Double: 3.141593</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 %f 输出单精度浮点数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Float: %.8f\n&quot;</span>, f);  <span class="comment">//Float: 3.14159274</span></span><br><span class="line"><span class="comment">// 使用 %lf 输出双精度浮点数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Double: %.8lf\n&quot;</span>, d); <span class="comment">//Double: 3.14159265</span></span><br></pre></td></tr></table></figure><p><strong>举例3：%c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> level = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this score level is:%c\n&quot;</span>,level); <span class="comment">//输出：this score level is:A</span></span><br></pre></td></tr></table></figure><p><strong>举例4：%s</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s是我最喜欢的冷门歌手.\n&quot;</span>,<span class="string">&quot;孙燕姿&quot;</span>); <span class="comment">//输出：孙燕姿是我最喜欢的冷门歌手.</span></span><br></pre></td></tr></table></figure><p><strong>举例5：多个占位符</strong></p><p>输出文本里面可以使用多个占位符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s有%d部手机\n&quot;</span>, <span class="string">&quot;老板&quot;</span>, <span class="number">2</span>); <span class="comment">//输出：老板有2部手机</span></span><br></pre></td></tr></table></figure><h3 id="7-4-输出格式"><a href="#7-4-输出格式" class="headerlink" title="7.4 输出格式"></a>7.4 输出格式</h3><p>printf() 可以定制占位符的输出格式。</p><p><strong>格式1：限定宽度</strong></p><p>printf() 允许限定占位符的最小宽度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%5d\n&quot;</span>, <span class="number">123</span>); <span class="comment">// 输出为 &quot;  123&quot; </span></span><br></pre></td></tr></table></figure><p>说明：%5d 表示这个占位符的宽度至少为5位。如果不满5位，对应的值的前面会添加空格。</p><p>输出的值默认是右对齐，即输出内容前面会有空格；如果希望改成左对齐，在输出内容后面添加空格，可以在占位符的 % 的后面插入一个 - 号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-5d\n&quot;</span>, <span class="number">123</span>); <span class="comment">// 输出为 &quot;123  &quot;</span></span><br></pre></td></tr></table></figure><p>对于小数，这个限定符会限制所有数字的最小显示宽度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%12f\n&quot;</span>, <span class="number">123.45</span>); <span class="comment">// 输出 &quot;  123.450000&quot;</span></span><br></pre></td></tr></table></figure><p>%12f 表示输出的浮点数最少要占据12位。由于小数的默认显示精度是小数点后6位，所以123.45 输出结果的头部会添加2个空格。</p><p><strong>格式2：总是显示正负号</strong></p><p>默认情况下， printf() 不对正数显示 + 号，只对负数显示 - 号。如果想让正数也输出 + 号，可以在占位符的 % 后面加一个 + 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%+d\n&quot;</span>, <span class="number">11</span>); <span class="comment">// 输出 +11</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%+d\n&quot;</span>, <span class="number">-11</span>); <span class="comment">// 输出 -11</span></span><br></pre></td></tr></table></figure><p><strong>格式3：限定小数位数</strong></p><p>输出小数时，有时希望限定小数的位数。举例来说，希望小数点后面只保留两位，占位符可以写成 %.2f 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Number is %.2f\n&quot;</span>, <span class="number">0.8</span>); <span class="comment">// 输出 Number is 0.80</span></span><br></pre></td></tr></table></figure><p>这种写法可以与限定宽度占位符，结合使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%6.2f\n&quot;</span>, <span class="number">0.8</span>); <span class="comment">// 输出为 &quot;  0.80&quot;</span></span><br></pre></td></tr></table></figure><p>说明：%6.2f 表示输出字符串最小宽度为6，小数位数为2。整体长度不足 6 位时，右对齐显示。</p><p>最小宽度和小数位数这两个限定值，都可以用 * 代替，通过 printf() 的参数传入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%*.*f\n&quot;</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">0.8</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%6.2f\n&quot;</span>, <span class="number">0.8</span>);</span><br></pre></td></tr></table></figure><blockquote><p> 【华南理工大学2018研】十六进制形式输出整数的格式说明符是（　）。</p><p> A．%u<br> B．%ld<br> C．%x<br> D．%o</p><p> 【答案】C</p><p> 【解析】A表示输出的是无符号整型；B表示输出的是有符号长整型；D表示输出的是八进制。</p></blockquote><h2 id="8、练习"><a href="#8、练习" class="headerlink" title="8、练习"></a>8、练习</h2><p>练习1：开发一个 ILoveC.c 程序，可以输出 “某某 is studying c!”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;谷小妹 is studying C!\n&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;%s is studying C!\n&quot;,&quot;谷小妹&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习2：控制台打印：5 + 3 &#x3D; 8</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, <span class="number">5</span>, <span class="number">3</span>, (<span class="number">5</span> + <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//函数结束</span></span><br></pre></td></tr></table></figure><h2 id="附录：C-C-Single-File-Execution插件的安装"><a href="#附录：C-C-Single-File-Execution插件的安装" class="headerlink" title="附录：C&#x2F;C++ Single File Execution插件的安装"></a>附录：C&#x2F;C++ Single File Execution插件的安装</h2><p><strong>1、为何安装C&#x2F;C++ Single File Execution插件？</strong></p><p>前面已经创建了一个demo1工程，项目文件夹内存在一个代码文件，名为<code>main.c</code>。如果再创建一个C源文件，内部如果也包含main()函数，则会报错！因为默认C工程下只能有一个main()函数。如何解决此问题呢？</p><p>2、安装并测试</p><p>1）在 File - Settings - Plugins 中搜索 <code>C/C++ Single File Execution</code> 插件并安装</p><p><img src="/images/image-20230823145107293.png" alt="image-20230823145107293"></p><p>2）在需要运行的代码中右键，点击 Add executable for single c&#x2F;cpp file</p><p><img src="/images/1692774502830.png" alt="1692774502830"></p><p>3）此时可以在 Cmakelists.text 文件中看到多出的这一行代码，这就是插件帮我们完成的事情</p><p><img src="/images/1692774556495.png" alt="1692774556495"></p><p>4）右键项目文件夹，点击 Reload CMake Project 进行刷新</p><p><img src="/images/1692774575597.png" alt="1692774575597"></p><p>5）此时右上角标签处已经增加了我们的文件选项，选择需要的标签</p><p><img src="/images/1692774598633.png" alt="1692774598633"></p><p>6）点击小三角，或右键代码处点击 Run 选项，即可运行代码。</p><p><img src="/images/1692774678384.png" alt="1692774678384"></p><p>7）在该工程下创建main2.c文件，文件中的代码如下所示，执行上面相同的步骤。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World2!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现一个工程中允许存在多个main方法了，而且可以独立允许。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 汇总 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言 五</title>
      <link href="/2025/05/21/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E4%BA%94/"/>
      <url>/2025/05/21/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p>  --><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#%E6%95%B0%E7%BB%84"><strong>数组</strong></a><br><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5">数组的概念</a><br><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C">数组的操作</a><br><a href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89">字符数组（字符串）</a><br><a href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">多维数组</a>        </p> <p id = "数组"></p> <h2 id="10-数组"><a href="#10-数组" class="headerlink" title="10 数组"></a>10 数组</h2> <p id = "数组的概念"></p> <h3 id="10-1-数组的概念"><a href="#10-1-数组的概念" class="headerlink" title="10.1 数组的概念"></a>10.1 数组的概念</h3><h4 id="①-数组四要素"><a href="#①-数组四要素" class="headerlink" title="① 数组四要素"></a>① 数组四要素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组名：本质上是标识符常量，需要符合标识符规范。</span><br><span class="line">元素：数组中的成员，同一个数组中的元素必须是相同的数据类型。</span><br><span class="line">下标：也称为索引、角标，就是元素的数字编号，是从0开始的连续数字；通过下标可以访问到数组中的某一个元素。</span><br><span class="line">长度：元素的个数。</span><br></pre></td></tr></table></figure><h4 id="②-C-语言数组特点（不用背）"><a href="#②-C-语言数组特点（不用背）" class="headerlink" title="② C 语言数组特点（不用背）"></a>② C 语言数组特点（不用背）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）创建数组时会在内存中开辟一整块连续的空间，占据的空间的大小，取决于数组的长度和数组中元素的类型。</span><br><span class="line">（2）数组中的元素在内存中是依次紧密排列的且有序的。</span><br><span class="line">（3）数组一旦初始化完成，其长度就是确定的，数组的长度一旦确定，就不能修改。</span><br><span class="line">（4）我们可以直接通过索引（下标）获取指定位置的元素，速度很快。</span><br></pre></td></tr></table></figure> <p id = "数组的操作"></p> <h3 id="10-2-数组的操作"><a href="#10-2-数组的操作" class="headerlink" title="10.2 数组的操作"></a>10.2 数组的操作</h3><h4 id="①-如何定义数组"><a href="#①-如何定义数组" class="headerlink" title="① 如何定义数组"></a>① 如何定义数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1）方式一：先指定元素的个数和类型，再进行初始化（先声明，再初始化赋值）</span></span><br><span class="line"><span class="type">int</span> arr1[<span class="number">4</span>];</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">arr1[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">arr1[<span class="number">2</span>] = <span class="number">300</span>;</span><br><span class="line">arr1[<span class="number">3</span>] = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2）方式二：指定元素的类型和个数并同时进行初始化(声明并同时初始化赋值)</span></span><br><span class="line"><span class="type">double</span> arr2[<span class="number">5</span>] = &#123;</span><br><span class="line">    <span class="number">1.5</span>,</span><br><span class="line">    <span class="number">2.5</span>,</span><br><span class="line">    <span class="number">3.5</span>,</span><br><span class="line">    <span class="number">4.5</span>,</span><br><span class="line">    <span class="number">5.5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3）方式三：指定元素的类型，不指定元素个数，同时进行初始化(声明时不指定长度，必须同时进行初始化赋值);</span></span><br><span class="line"><span class="type">short</span> arr3[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="②-访问数组元素"><a href="#②-访问数组元素" class="headerlink" title="② 访问数组元素"></a>② 访问数组元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[下标]</span><br></pre></td></tr></table></figure><h4 id="③-数组越界"><a href="#③-数组越界" class="headerlink" title="③ 数组越界"></a>③ 数组越界</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">合理的下标范围：0 ~ 长度-1; 如果使用不在合理范围内的下标，越界访问，访问的是数组之外的内存区域。</span><br></pre></td></tr></table></figure><h4 id="④-数组长度计算"><a href="#④-数组长度计算" class="headerlink" title="④ 数组长度计算"></a>④ 数组长度计算</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总的存储空间大小 / 单个元素的存储空间大小</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> 数组名 / <span class="keyword">sizeof</span> 数组名[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">sizeof</span> 数组名 / <span class="keyword">sizeof</span> (元素的数据类型关键字)</span><br></pre></td></tr></table></figure><h4 id="⑤-遍历数组"><a href="#⑤-遍历数组" class="headerlink" title="⑤ 遍历数组"></a>⑤ 遍历数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用计数循环，让循环变量作为下标</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; 数组长度; i++)</span><br><span class="line">&#123;</span><br><span class="line">    数组名[i];<span class="comment">// 读写数组元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p id = "字符数组（字符串）"></p> <h3 id="10-3-字符数组（字符串）"><a href="#10-3-字符数组（字符串）" class="headerlink" title="10.3 字符数组（字符串）"></a>10.3 字符数组（字符串）</h3><h4 id="①-字符串的本质"><a href="#①-字符串的本质" class="headerlink" title="① 字符串的本质"></a>① 字符串的本质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字符串就是由字符组成的数组</span><br><span class="line">特点：</span><br><span class="line">① 有专门的占位符 %s</span><br><span class="line">② 字符串结尾，会自动添加一个 \0 作为字符串结束的标志，所以字符数组最后一个元素必须是 \0。</span><br></pre></td></tr></table></figure><h4 id="②-如何定义字符串"><a href="#②-如何定义字符串" class="headerlink" title="② 如何定义字符串"></a>② 如何定义字符串</h4><p><strong>普通方式初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 手动添加字符串结束标记（\0）</span></span><br><span class="line"><span class="type">char</span> str1[<span class="number">9</span>] = &#123;<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; </span><br><span class="line"><span class="type">char</span> str2[] = &#123;<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 自动添加字符串结束标记(只要长度给的够大)</span></span><br><span class="line"><span class="type">char</span> str3[<span class="number">5</span>] = &#123;<span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;; </span><br><span class="line"><span class="type">char</span> str4[<span class="number">15</span>] = &#123;<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;n&#x27;</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 不会自动添加字符串结束标记</span></span><br><span class="line"><span class="type">char</span> str5[<span class="number">4</span>] = &#123;<span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> str6[] = &#123;<span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>简写方式初始化：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一： 定义字符串  可以自动添加结束标记</span></span><br><span class="line"><span class="type">char</span> str1[] = &#123;<span class="string">&quot;Shanghai&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 方式一： 定义字符串  可以自动添加结束标记</span></span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;Beijing&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="③-字符串的访问和遍历"><a href="#③-字符串的访问和遍历" class="headerlink" title="③ 字符串的访问和遍历"></a>③ 字符串的访问和遍历</h4><p><strong>字符串长度计算：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sizeof： 字符串的内存存储大小就是字符串的长度，字符串的每个元素都是1字节</span><br><span class="line">strlen():  位于标准库头文件 &lt;string.h&gt; 中， 从第一个字符开始计数一直到字符串结束标记（不包括结束标记） </span><br></pre></td></tr></table></figure><p><strong>占位符：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s ：可以用来输出字符串。</span><br></pre></td></tr></table></figure> <p id = "多维数组"></p> <h3 id="10-4-多维数组"><a href="#10-4-多维数组" class="headerlink" title="10.4 多维数组"></a>10.4 多维数组</h3><h4 id="①-多维数组的概念"><a href="#①-多维数组的概念" class="headerlink" title="① 多维数组的概念"></a>① 多维数组的概念</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 如果数组的元素还是数组，这样的数组就称为多维数组。</span><br><span class="line">2. 多维数组分为二维数组、三维数组等</span><br><span class="line">3. 二维数组相关概念：行数、列数、行下标、列下标</span><br></pre></td></tr></table></figure><h4 id="②-二维数组的定义"><a href="#②-二维数组的定义" class="headerlink" title="② 二维数组的定义"></a>② 二维数组的定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 先声明再初始化赋值   标识符arr1的类型是 int [3][2]</span></span><br><span class="line"><span class="type">int</span> arr1[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">arr1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">arr1[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">arr1[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">arr1[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">arr1[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1000</span>;</span><br><span class="line">arr1[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义二维数组：同时声明并初始化赋值，双层大括号</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;,</span><br><span class="line">    &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 定义二维数组：同时声明并初始化赋值; 一层大括号，可以自动分配</span></span><br><span class="line"><span class="type">int</span> arr3[<span class="number">2</span>][<span class="number">4</span>] = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 定义二维数组：同时声明并初始化赋值;一层大括号, 可以自动分配，省略行数</span></span><br><span class="line"><span class="type">int</span> arr4[][<span class="number">3</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="③-二维数组的访问和遍历"><a href="#③-二维数组的访问和遍历" class="headerlink" title="③ 二维数组的访问和遍历"></a>③ 二维数组的访问和遍历</h4><p><strong>长度计算：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行数： sizeof 数组名 / sizeof 数组名[0]</span><br><span class="line">列数： sizeof 数组名[0] / sizeof 数组名[0][0]</span><br></pre></td></tr></table></figure><p><strong>访问内层元素：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[行下标][行下标]</span><br></pre></td></tr></table></figure><h4 id="④-二维数组的内存形式"><a href="#④-二维数组的内存形式" class="headerlink" title="④ 二维数组的内存形式"></a>④ 二维数组的内存形式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存中，各元素是连续存放的，先顺序存放第一行的元素，再存放第二行的元素。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> C语言 五 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言 四</title>
      <link href="/2025/05/20/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E5%9B%9B/"/>
      <url>/2025/05/20/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p>  --><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><strong>流程控制</strong></a><br><a href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">循环控制语句</a><br><a href="#while">while</a><br><a href="#do_while">do while</a><br><a href="#for">for</a><br><a href="#%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">跳转控制语句</a><br><a href="#break">break</a><br><a href="#continue">continue</a><br><a href="#goto">goto</a><br><a href="#%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95"><strong>断点调试</strong></a>       </p> <p id = "流程控制"></p> <h2 id="7-流程控制"><a href="#7-流程控制" class="headerlink" title="7 流程控制"></a>7 流程控制</h2><p id = "循环控制语句"></p>  <h3 id="7-2-循环控制语句"><a href="#7-2-循环控制语句" class="headerlink" title="7.2 循环控制语句"></a>7.2 循环控制语句</h3><p id = "while"></p> <h4 id="①-while-循环"><a href="#①-while-循环" class="headerlink" title="① while 循环"></a>① while 循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件表达式)</span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>**死循环（不会结束的循环）：**条件表达式永远成立！</p><p>**可以结束的循环：**条件表达式不能永远成立，且随着循环次数增加越来越趋向于不成立。</p></blockquote><p id = "do_while"></p> <h4 id="②-do-while-循环"><a href="#②-do-while-循环" class="headerlink" title="② do while 循环"></a>② do while 循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125; <span class="keyword">while</span> (条件表达式);</span><br></pre></td></tr></table></figure><blockquote><p><strong>while 和 do while 区别：</strong></p><p>do while 循环结构，循环体语句第一次执行未经过条件判断，但以后的每一次循环体语句的执行还是会先经过条件判断。</p></blockquote><p id = "for"></p> <h4 id="③-for-循环"><a href="#③-for-循环" class="headerlink" title="③ for 循环"></a>③ for 循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (循环变量初始化; 条件表达式; 循环变量变化)</span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>总结：</strong></p><p>循环变量初始化： 循环之前执行，执行一次。</p><p>条件表达式：每次执行循环体语句先判断，同 while 一致； 执行次数比循环次数多1次。</p><p>循环变量变化：循环体语句(大括号中的语句)后面执行，执行次数同循环次数一致。</p></blockquote><p id = "跳转控制语句"></p> <h3 id="7-3-跳转控制语句"><a href="#7-3-跳转控制语句" class="headerlink" title="7.3 跳转控制语句"></a>7.3 跳转控制语句</h3><p id = "break"></p> <h4 id="①-break"><a href="#①-break" class="headerlink" title="① break"></a>① break</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 在 switch case 结构中使用： 结束所在的 case</span><br><span class="line">2. 在循环结构（for、while、do while）中使用： 结束循环</span><br></pre></td></tr></table></figure><blockquote><p>break 跳出整个循环！</p></blockquote><p id = "continue"></p> <h4 id="②-continue"><a href="#②-continue" class="headerlink" title="② continue"></a>② continue</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在循环结构（for、while、do while）中使用： 结束本次循环</span><br></pre></td></tr></table></figure><blockquote><p>continue 跳出本次循环！</p></blockquote><p id = "goto"></p> <h4 id="③-goto"><a href="#③-goto" class="headerlink" title="③ goto"></a>③ goto</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 使用 goto 可以跳转到指定位置</span><br><span class="line">   goto 标签名;</span><br><span class="line">2. 标签名是自定义的，需要符合标识符规范</span><br><span class="line">3. 尽量避免使用！</span><br></pre></td></tr></table></figure><p id = "断点调试"></p> <h2 id="9-断点调试"><a href="#9-断点调试" class="headerlink" title="9 断点调试"></a>9 断点调试</h2><h3 id="9-1-断点调试介绍"><a href="#9-1-断点调试介绍" class="headerlink" title="9.1 断点调试介绍"></a>9.1 断点调试介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下，然后程序可以进行分析从而找到这个Bug。</span><br></pre></td></tr></table></figure><h3 id="9-2-如何设置断点"><a href="#9-2-如何设置断点" class="headerlink" title="9.2 如何设置断点"></a>9.2 如何设置断点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在代码行号的前面单击中即可添加断点，再次点击可以取消断点； 或者使用快捷键 F9，会给光标所在行添加或取消断点。</span><br><span class="line">启动调试之后，代码执行到断点会暂停。</span><br></pre></td></tr></table></figure><h3 id="9-3-断点调试应用案例-——-逐过程调试"><a href="#9-3-断点调试应用案例-——-逐过程调试" class="headerlink" title="9.3 断点调试应用案例 —— 逐过程调试"></a>9.3 断点调试应用案例 —— 逐过程调试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用逐过程断点调试查看下面代码中变量的变化情况，逐过程是从断点开始逐条语句执行，执行一条语句就暂停一次，可以点击“逐过程”按钮或使用快捷键F10执行下一条语句。</span><br></pre></td></tr></table></figure><h3 id="9-4-断点调试应用案例-——-逐断点调试"><a href="#9-4-断点调试应用案例-——-逐断点调试" class="headerlink" title="9.4 断点调试应用案例 —— 逐断点调试"></a>9.4 断点调试应用案例 —— 逐断点调试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们程序中存在多个断点时，程序执行到第一个断点开始暂停，我们想直接执行到下一个断点再次暂停，而不是逐行执行到下一个断点，我们可以单击“继续”按钮或者使用快捷键F5。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> C语言 四 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 流程控制 </tag>
            
            <tag> 断点调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言 三</title>
      <link href="/2025/05/19/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E4%B8%89/"/>
      <url>/2025/05/19/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p>  --><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><strong>运算符</strong></a><br><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E5%9F%BA%E7%A1%80">运算符基础</a><br><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</a><br><a href="#%E5%85%B3%E7%B3%BB%EF%BC%88%E6%AF%94%E8%BE%83%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6">关系（比较）运算符</a><br><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a><br><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</a><br><a href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</a><br><a href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6">三元运算符</a><br><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><strong>流程控制</strong></a><br><a href="#%E5%88%86%E6%94%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">分支控制语句</a><br><a href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</a>       </p> <p id = "运算符"></p> <h2 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6 运算符"></a>6 运算符</h2> <p id = "运算符基础"></p><h3 id="6-1-运算符基础"><a href="#6-1-运算符基础" class="headerlink" title="6.1 运算符基础"></a>6.1 运算符基础</h3><blockquote><p>**运算符：**也称为操作符，是一种特殊的符号，用以用于数据的运算、赋值和比较等。</p><p><strong>运算数：</strong> 也称为操作数，参与运算的数据，可以是变量、常量、表达式。</p><p><strong>表达式：</strong> 表达式具有值，可以是一个变量、一个常量，也可以是变量、常量和运算符的组合。</p></blockquote><blockquote><p><strong>运算符4要素：</strong> 功能、所需操作数个数、所组成表达式的值、有无副作用。</p><p><strong>运算符分类(按操作数个数)：</strong> 一元运算符、二元运算符、三元运算符。</p><p><strong>运算符分类(按功能)：</strong> 算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、其他运算符</p></blockquote> <p id = "算术运算符"></p><h3 id="6-2-算术运算符"><a href="#6-2-算术运算符" class="headerlink" title="6.2 算术运算符"></a>6.2 算术运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>+</code></td><td>正号</td><td>1</td><td>操作数的值</td><td>无</td></tr><tr><td><code>-</code></td><td>负号</td><td>1</td><td>操作数的值符号取反</td><td>无</td></tr><tr><td><code>+</code></td><td>相加</td><td>2</td><td>相加的值</td><td>无</td></tr><tr><td><code>-</code></td><td>相减</td><td>2</td><td>相减的值</td><td>无</td></tr><tr><td><code>*</code></td><td>相乘</td><td>2</td><td>相乘的值</td><td>无</td></tr><tr><td><code>/</code></td><td>相除</td><td>2</td><td>相除的值</td><td>无</td></tr><tr><td><code>%</code></td><td>取余（取模）</td><td>2</td><td>余数</td><td>无</td></tr><tr><td><code>++</code></td><td>自增</td><td>1</td><td></td><td>有</td></tr><tr><td><code>--</code></td><td>自减</td><td>1</td><td></td><td>有</td></tr></tbody></table><blockquote><p><strong>总结：</strong></p><ol><li>正号、负号</li><li>加、减、乘、除</li><li>取余（取模）<ul><li>表达式的值的符号与第一个操作数保持一致。</li><li>要求两个操作数必须都是整数。</li></ul></li><li>自增、自减<ul><li>如果操作数在前，取操作数自增自减之前的值作为表达式的值（i++&#x2F;i–）</li><li>如果运算符在前，取操作数自增自减之后的值作为表达式的值（++i&#x2F;–i）</li></ul></li></ol></blockquote><blockquote><p><strong>注意：</strong></p><ul><li>带有副作用的运算符，要求操作数必须是变量的形式。</li><li>C 语言规定，同一个表达中，不允许出现互相影响的带有副作用的子表达式（C 语言标准没有规定各个操作数的计算顺序，由编译器自行实现）。</li></ul></blockquote> <p id = "关系（比较）运算符"></p><h3 id="6-3-关系（比较）运算符"><a href="#6-3-关系（比较）运算符" class="headerlink" title="6.3 关系（比较）运算符"></a>6.3 关系（比较）运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>&gt;</code></td><td>大于</td><td>2</td><td>1或0</td><td>无</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td><td>2</td><td>1或0</td><td>无</td></tr><tr><td><code>&lt;</code></td><td>小于</td><td>2</td><td>1或0</td><td>无</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td><td>2</td><td>1或0</td><td>无</td></tr><tr><td><code>==</code></td><td>相等</td><td>2</td><td>1或0</td><td>无</td></tr><tr><td><code>!=</code></td><td>不相等</td><td>2</td><td>1或0</td><td>无</td></tr></tbody></table><blockquote><p><strong>总结：</strong></p><ol><li>比大小</li><li>判等</li></ol></blockquote> <p id = "逻辑运算符"></p><h3 id="6-4-逻辑运算符"><a href="#6-4-逻辑运算符" class="headerlink" title="6.4 逻辑运算符"></a>6.4 逻辑运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑与</td><td>2</td><td>两个条件都成立得1，否则得0</td><td>无</td></tr><tr><td><code>ll</code></td><td>逻辑或</td><td>2</td><td>只要一个条件成立就得1，都不成立得0</td><td>无</td></tr><tr><td><code>！</code></td><td>逻辑非</td><td>1</td><td>操作数非0表达式得0，操作数0表达式得1</td><td>无</td></tr></tbody></table><blockquote><p><strong>注意：</strong></p><p>逻辑与 短路：如果第一个条件不成立，第二个条件将不会执行到。</p><p>逻辑或 短路：如果第一个条件就成立，第二个条件将不会比执行。</p></blockquote> <p id = "位运算符"></p><h3 id="6-5-位运算符"><a href="#6-5-位运算符" class="headerlink" title="6.5 位运算符"></a>6.5 位运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与</td><td>2</td><td>按位相同为1，否则为0</td><td>无</td></tr><tr><td><code>l</code></td><td>按位或</td><td>2</td><td>按位只要有一个为1，都为1</td><td>无</td></tr><tr><td><code>^</code></td><td>按位异或</td><td>2</td><td>按位不同为1，否则为0</td><td>无</td></tr><tr><td><code>~</code></td><td>按位取反</td><td>1</td><td>0变1，1变0</td><td>无</td></tr><tr><td><code>&lt;&lt;</code></td><td>按位左移</td><td>2</td><td>最低位补0</td><td>无</td></tr><tr><td><code>&gt;&gt;</code></td><td>按位右移</td><td>2</td><td>注意</td><td>无</td></tr></tbody></table><blockquote><p><strong>总结：</strong></p><ul><li>按位左移和右移的快捷计算方式：</li></ul></blockquote><blockquote><p><strong>注意：</strong></p><ul><li>对于有符号数，如果最高位为1（负数），则右移时会在最高位补1。<ul><li>​                    如果最高位为0（正数），则右移时会在最高位补0。</li></ul></li></ul></blockquote> <p id = "赋值运算符"></p><h3 id="6-6-赋值运算符"><a href="#6-6-赋值运算符" class="headerlink" title="6.6 赋值运算符"></a>6.6 赋值运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>=</code></td><td>赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>+=</code></td><td>相加赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>-=</code></td><td>相减赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>*=</code></td><td>相乘赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>/=</code></td><td>相除赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>%=</code></td><td>取余赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>&amp;=</code></td><td>按位与赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>l=</code></td><td>按位或赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>^=</code></td><td>按位异或赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>&lt;&lt;=</code></td><td>左移赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>&gt;&gt;=</code></td><td>右移赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr></tbody></table><blockquote><p><strong>总结：</strong></p><p>  c +&#x3D; 3;  &#x2F;&#x2F; 等价于 c &#x3D; c + 3;  计算后c的值变为33</p><p>  c +&#x3D; b;  &#x2F;&#x2F; 等价于 c &#x3D; c + b;  计算后c的值变为53</p><p>  a +&#x3D; 1.7; &#x2F;&#x2F; 等价于 a &#x3D; a + 1.7  计算后a的值变为11</p></blockquote><blockquote><p><strong>注意：</strong></p><p>（1）赋值运算符的第一个操作数（左值）必须是变量的形式，第二个操作数可以是任何形式的表达式。</p><p>（2）赋值运算符的副作用针对第一个操作数。</p></blockquote> <p id = "三元运算符"></p><h3 id="6-7-三元运算符"><a href="#6-7-三元运算符" class="headerlink" title="6.7 三元运算符"></a>6.7 三元运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td>条件表达式? 表达式1: 表达式2；</td><td></td><td>3</td><td>注意</td><td>无</td></tr></tbody></table><blockquote><p><strong>总结：</strong></p><ol><li>a &gt; b ? 1.1 : 1.2</li><li>若a&gt;b为1.1，若a&lt;b为1.2</li></ol></blockquote><blockquote><p><strong>注意：</strong></p><p>（1）如果条件表达式为非0（真），整个表达式的值是表达式1；</p><p>（2）如果条件表达式为0（假），整个表达式的值是表达式2；</p></blockquote> <p id = "流程控制"></p><h2 id="7-流程控制"><a href="#7-流程控制" class="headerlink" title="7 流程控制"></a>7 流程控制</h2> <p id = "分支控制语句"></p> <h3 id="7-1-分支控制语句"><a href="#7-1-分支控制语句" class="headerlink" title="7.1 分支控制语句"></a>7.1 分支控制语句</h3><h4 id="①-单向分支"><a href="#①-单向分支" class="headerlink" title="① 单向分支"></a>① 单向分支</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-双向分支"><a href="#②-双向分支" class="headerlink" title="② 双向分支"></a>② 双向分支</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③-多向分支-else-if"><a href="#③-多向分支-else-if" class="headerlink" title="③ 多向分支 else if"></a>③ 多向分支 else if</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式<span class="number">1</span>)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">2</span>)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">3</span>)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">4</span>)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④-多向分支-switch-case"><a href="#④-多向分支-switch-case" class="headerlink" title="④ 多向分支 switch case"></a>④ 多向分支 switch case</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 表达式可能的值<span class="number">1</span>：</span><br><span class="line">        语句块;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 表达式可能的值<span class="number">2</span>：</span><br><span class="line">        语句块;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 表达式可能的值<span class="number">3</span>：</span><br><span class="line">        语句块;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 表达式可能的值<span class="number">4</span>：</span><br><span class="line">        语句块;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>（1）switch 后面表达式的值必须是一个整型（char、short, int, long等）或 枚举类型。</p><p>（2）case 后面的值必须是字面量常量，而不能是变量、标识符常量。</p><p>（3）default 是可选的，当没有匹配的 case 时，执行 default。</p><p>（4）break 语句可以使程序跳出 switch 语句块，如果没有break，会执行下一个case 语句块，直到遇到break或者执行到switch结尾，这个现象称为穿透。</p></blockquote><h4 id="⑤-嵌套分支"><a href="#⑤-嵌套分支" class="headerlink" title="⑤ 嵌套分支"></a>⑤ 嵌套分支</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (条件表达式)  </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (条件表达式)  </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> C语言 三 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 运算符 </tag>
            
            <tag> 流程控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言 一</title>
      <link href="/2025/05/17/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E4%B8%80/"/>
      <url>/2025/05/17/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p>  --><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#%E7%A8%8B%E5%BA%8F">程序</a><br><a href="#c%E8%AF%AD%E8%A8%80">c语言</a><br><a href="#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7">开发工具</a><br><a href="#%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a><br><a href="#c%E8%AF%AD%E8%A8%80%E6%89%A7%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B">c语言执行的流程</a><br><a href="#%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86">源文件中的组成部分</a><br><a href="#%E5%8F%98%E9%87%8F">变量</a><br><a href="#%E5%B8%B8%E9%87%8F">常量</a>        </p><p id = "程序"></p><h2 id="1-程序"><a href="#1-程序" class="headerlink" title="1 程序"></a>1 程序</h2><p>编写的编程语言(大量的代码(指令)组成)<br>  比如 xxx.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">   retun <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p id = "c语言"></p><h2 id="2-c语言"><a href="#2-c语言" class="headerlink" title="2 c语言"></a>2 c语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">概念: 是一个程序员使用的高级语言</span><br><span class="line">使用场景: 作为嵌入式开发的基础语言    </span><br></pre></td></tr></table></figure><p id = "开发工具"></p><h2 id="3-开发工具"><a href="#3-开发工具" class="headerlink" title="3 开发工具"></a>3 开发工具</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsCode: 免费,轻量级的开发工具</span><br></pre></td></tr></table></figure> <p id = "编译器"></p><h2 id="4-编译器"><a href="#4-编译器" class="headerlink" title="4 编译器"></a>4 编译器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minGW: 是一个windows系统的工具包,其中包含了c语言的编译器--&gt;gcc</span><br></pre></td></tr></table></figure> <p id = "c语言执行的流程"></p><h2 id="5-c语言执行的流程"><a href="#5-c语言执行的流程" class="headerlink" title="5 c语言执行的流程"></a>5 c语言执行的流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.编写源代码  xxx.c</span><br><span class="line">2.预处理     xxx.i  : 修理xxx.c的源文件(去除多余的注释,空格)</span><br><span class="line">3.编译       xxx.s  把预处理文件编译成汇编文件</span><br><span class="line">4.汇编       xxx.o  把汇编文件编译成二进制文件(机器码)</span><br><span class="line">5.链接       xxx.exe 把所有的可执行文件组合起来(自定义的xxx.o和库文件)</span><br><span class="line">6.执行       执行的就是windows中的可执行文件 xxx.exe</span><br></pre></td></tr></table></figure> <p id = "源文件中的组成部分"></p><h2 id="6-源文件中的组成部分"><a href="#6-源文件中的组成部分" class="headerlink" title="6 源文件中的组成部分"></a>6 源文件中的组成部分</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="meta">#<span class="keyword">include</span> 引入头文件</span></span><br><span class="line"><span class="number">2.</span><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="number">0</span>&#125; 主函数</span><br></pre></td></tr></table></figure> <p id = "变量"></p><h2 id="7-变量"><a href="#7-变量" class="headerlink" title="7 变量"></a>7 变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">变量的作用:  在内存中保存可变的数据</span><br><span class="line">     特点： 变量在内存中的数据是可以修改的</span><br><span class="line">   三要素:  1.变量的类型 2.标识符(变量的名字) 3.变量的值</span><br><span class="line">   </span><br><span class="line"> 标识符(变量,常量,函数,数组)的命名 的规则  </span><br><span class="line">  强制要求:</span><br><span class="line">     1.必须由字母、数字、下划线组成</span><br><span class="line">     2.数字不能开头</span><br><span class="line">     3.不能使用关键字 (类型关键字:int float ....)</span><br><span class="line">     4.严格区分大小写  （hello  ,Hello）</span><br><span class="line">     </span><br><span class="line">   推荐: 1.见名知意 (有效的单词)</span><br><span class="line">        2.小驼峰命名 (如果多个单词: myAge)</span><br></pre></td></tr></table></figure><p id = "常量"></p><h2 id="8-常量"><a href="#8-常量" class="headerlink" title="8 常量"></a>8 常量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">概念: 就是不能改变的量(内存中的数据不能被修改)</span><br><span class="line">作用: 定义程序中使用到的不可更改的数据  比如(PI=3.14)</span><br><span class="line">表现形式: </span><br><span class="line">1.const定义  ： 必须指定类型</span><br><span class="line"></span><br><span class="line">2.#define定义   不能指定类型</span><br><span class="line">   注意: 在预处理阶段自动把定义的常量值替换到程序中</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> C语言 一 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言 二</title>
      <link href="/2025/05/17/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E4%BA%8C/"/>
      <url>/2025/05/17/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p>  --><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a><br><a href="#%E8%BF%9B%E5%88%B6%E5%88%86%E7%B1%BB">进制分类</a><br><a href="#%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F">进制表示形式</a><br><a href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</a><br><a href="#%E5%8E%9F%E5%8F%8D%E8%A1%A5%E7%A0%81">原码 反码 补码</a><br><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a><br><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96">数据类型转化</a>        </p> <p id = "二进制"></p> <h2 id="5-二进制"><a href="#5-二进制" class="headerlink" title="5 二进制"></a>5 二进制</h2> <p id = "进制分类"></p> <h3 id="5-1-进制分类"><a href="#5-1-进制分类" class="headerlink" title="5.1 进制分类"></a>5.1 进制分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.二进制</span><br><span class="line">2.十进制</span><br><span class="line">3.十六进制</span><br></pre></td></tr></table></figure><p id = "进制表示形式"></p> <h3 id="5-2-不同进制表示形式"><a href="#5-2-不同进制表示形式" class="headerlink" title="5.2 不同进制表示形式"></a>5.2 不同进制表示形式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">十进制: 就是十进制(无特殊)</span><br><span class="line">二进制: 0b010101</span><br><span class="line">十六进制: 0x  0X  #0x  #0X</span><br></pre></td></tr></table></figure> <p id = "进制转换"></p> <h3 id="5-3-进制之间的转换"><a href="#5-3-进制之间的转换" class="headerlink" title="5.3 进制之间的转换"></a>5.3 进制之间的转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">二进制转十进制</span><br><span class="line">    方式:  从低位开始,提取每一位的数据,乘以<span class="number">2</span>的(位数<span class="number">-1</span>)次方， 结果相加</span><br><span class="line">       <span class="number">0111</span> 二进制</span><br><span class="line">       <span class="number">0</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">       <span class="number">1</span>*<span class="number">2</span>^(<span class="number">1</span><span class="number">-1</span>)=<span class="number">1</span></span><br><span class="line">       <span class="number">1</span>*<span class="number">2</span>^(<span class="number">2</span><span class="number">-1</span>)=<span class="number">2</span></span><br><span class="line">       <span class="number">1</span>*<span class="number">2</span>^(<span class="number">3</span><span class="number">-1</span>)=<span class="number">4</span></span><br><span class="line">       <span class="number">0</span>*<span class="number">2</span>^(<span class="number">3</span><span class="number">-1</span>)=<span class="number">0</span></span><br><span class="line">       <span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span>+<span class="number">0</span>=<span class="number">7</span></span><br><span class="line"></span><br><span class="line">十进制转二进制</span><br><span class="line">    方式: 使用该数不断的除以<span class="number">2</span>,直到商为零结束， 最后把每一步计算的余数倒叙组合就是二进制       </span><br><span class="line">       <span class="number">10</span>十进制 转为二进制</span><br><span class="line">        <span class="number">10</span>%<span class="number">2</span>=<span class="number">5</span> 余 <span class="number">0</span></span><br><span class="line">        <span class="number">5</span>%<span class="number">2</span>=<span class="number">2</span> 余 <span class="number">1</span></span><br><span class="line">        <span class="number">2</span>%<span class="number">2</span>=<span class="number">1</span> 余 <span class="number">0</span></span><br><span class="line">        <span class="number">1</span>%<span class="number">2</span>=<span class="number">0</span> 余 <span class="number">1</span></span><br><span class="line">        <span class="number">1010</span></span><br><span class="line"></span><br><span class="line">十六进制转为十进制</span><br><span class="line">    方式:  从低位开始,提取每一位的数据,乘以<span class="number">16</span>的(位数<span class="number">-1</span>)次方， 结果相加   </span><br><span class="line">           #<span class="number">0x12A</span></span><br><span class="line">           (A)<span class="number">10</span>*<span class="number">16</span>^<span class="number">0</span>=<span class="number">10</span></span><br><span class="line">           (<span class="number">2</span>)<span class="number">2</span>* <span class="number">16</span>^<span class="number">1</span>=<span class="number">32</span></span><br><span class="line">           (<span class="number">1</span>)<span class="number">1</span>*<span class="number">16</span>^<span class="number">2</span>=<span class="number">256</span></span><br><span class="line">          <span class="number">256</span>+<span class="number">32</span>+<span class="number">10</span>=<span class="number">298</span></span><br><span class="line">十进制转为十六进制     </span><br><span class="line">    方式: 使用该数不断的除以<span class="number">16</span>,直到商为零结束， 最后把每一步计算的余数倒叙组合就是二进制  </span><br><span class="line">             <span class="number">33</span>（十进制）</span><br><span class="line">             <span class="number">33</span>%<span class="number">16</span>=<span class="number">2</span> 余 <span class="number">1</span></span><br><span class="line">             <span class="number">2</span>%<span class="number">16</span>=<span class="number">0</span>  余 <span class="number">2</span></span><br><span class="line">            十六进制的结果: <span class="number">21</span></span><br><span class="line">   </span><br><span class="line">二进制转为十六进制</span><br><span class="line">    方式: 把二进制每<span class="number">4</span>位一组,计算十六进制          </span><br><span class="line">      <span class="number">1001</span>  <span class="number">1100</span>   </span><br><span class="line">       <span class="number">9</span>（十进制）     <span class="number">12</span>（十进制）</span><br><span class="line">      十六进制结果:  <span class="number">9</span>C  </span><br><span class="line">                </span><br><span class="line">十六进制转为二进制   </span><br><span class="line">    方式:  把每一位转成<span class="number">4</span>位一组的二进制  </span><br><span class="line">                    <span class="number">9</span>C    </span><br><span class="line">         （C）<span class="number">12</span>=<span class="number">8</span>+<span class="number">4</span>  二进制表示:  <span class="number">1010</span>  </span><br><span class="line">          (<span class="number">9</span>) <span class="number">9</span>=<span class="number">8</span>+<span class="number">1</span>  二进制表示:  <span class="number">1001</span>   </span><br><span class="line">            二进制结果: <span class="number">10011010</span>     </span><br></pre></td></tr></table></figure> <p id = "原反补码"></p> <h3 id="5-4-原码-反码-补码"><a href="#5-4-原码-反码-补码" class="headerlink" title="5.4 原码 反码 补码"></a>5.4 原码 反码 补码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">机器数: 就是二进制数据</span><br><span class="line">形式值：没有符号位   1111  最高位不是符号位</span><br><span class="line">真值： 有符号位     1111（ 最高位是符号位）</span><br><span class="line"></span><br><span class="line">原码:  真值</span><br><span class="line">反码:  </span><br><span class="line">  正数的反码就是原码</span><br><span class="line">  负数的反码符号位不变其余取反 1111---&gt; 1000</span><br><span class="line">补码：</span><br><span class="line">  正数的补码就是原码</span><br><span class="line">  负数的补码就是反码+1,符号位不变</span><br><span class="line">  </span><br><span class="line">总结:1.正数的 原码 反码 补码 一致  </span><br><span class="line">    2.计算中存储的数据都是以补码形式存在  </span><br></pre></td></tr></table></figure> <p id = "数据类型"></p> <h3 id="5-5-数据类型"><a href="#5-5-数据类型" class="headerlink" title="5.5 数据类型"></a>5.5 数据类型</h3><table><thead><tr><th>整型</th><th>浮点型</th><th>布尔类型</th></tr></thead><tbody><tr><td>char           1字节</td><td>float 4字节</td><td>宏定义(自定义布尔类): #define BOOL int</td></tr><tr><td>short          2字节</td><td>double 8字节</td><td>使用c99标准中:<em>Bool</em></td></tr><tr><td>int               4字节</td><td>long double 16字节</td><td>使用c99标准: 导入头文件<br /><br />&lt;stdbool.h&gt;</td></tr><tr><td>long           （32:4字节    64：8字节） —&gt; 现在的笔记本是使用了32位系统的转化方式(4字节)</td><td></td><td></td></tr><tr><td>long long    8字节</td><td></td><td></td></tr></tbody></table><p id = "数据类型转化"></p> <h3 id="5-6-数据类型转化"><a href="#5-6-数据类型转化" class="headerlink" title="5.6 数据类型转化"></a>5.6 数据类型转化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">自动类型转换:  窄类型转为宽类型</span><br><span class="line">1.运算过程中的自动类型转换(隐式转换)   </span><br><span class="line">比如: int a=1;short b=2  </span><br><span class="line">计算: a+b 结果是int类型</span><br><span class="line"></span><br><span class="line">2.赋值过程中的自动类型转换(隐式转换)   </span><br><span class="line">比如: float f=3.14;  自动把double类型转为了float类型</span><br><span class="line"></span><br><span class="line">3.强制类型转化</span><br><span class="line">   宽类型转为窄类型</span><br><span class="line">   案例: </span><br><span class="line">      //计算三个人的平均年龄  </span><br><span class="line">      int age1=20,age2=23,age3=24;</span><br><span class="line">      </span><br><span class="line">      //printf(&quot;%lf&quot;,(age1+age2+age3)/3.0);         // 22.333333</span><br><span class="line">      printf(&quot;%lf&quot;,(double)((age1+age2+age3)/3));   // 22.000000</span><br><span class="line">      printf(&quot;%lf&quot;,(double)(age1+age2+age3)/3);     // 22.333333</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> C语言 二 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构十一（快速排序QuickSort）</title>
      <link href="/2025/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%E4%B8%80%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FQuickSort%EF%BC%89/"/>
      <url>/2025/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%E4%B8%80%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FQuickSort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录key，key一般都是最左边，目的就是为了把key排到正确的位置，同时将key设为坑位<br>开始坑在左边，右边开始找值补坑，right找到比key小的值，放入坑位，right形成新的坑<br>现在坑在右边，左边开始找值补坑，left找到比key大的值，放入坑位，left形成新的坑<br>直到left和right相遇就结束，最后把key放到坑位，key就排到正确的位置</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%E4%B8%80%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FQuickSort%EF%BC%89/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序" title="快速排序"></p><p>More info: <a href="https://github.com/gybpersist/QuickSort">QuickSort</a></p><h2 id="快速排序（QuickSort）"><a href="#快速排序（QuickSort）" class="headerlink" title="快速排序（QuickSort）"></a>快速排序（QuickSort）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> begin,<span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份关键元素</span></span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//备份首元素下标，尾元素下标</span></span><br><span class="line">    <span class="type">int</span> left = begin,right = end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 避免元素为空</span></span><br><span class="line">    <span class="keyword">if</span>(begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//备份关键元素(把首元素先作为关键元素)</span></span><br><span class="line">        temp = buf[begin];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当左右找到相同元素是停止</span></span><br><span class="line">        <span class="keyword">while</span> (left != right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先是从右向左找 找到比关键元素大的，不交换，然后向左移动（h--）,直到找到比关键元素小的</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; buf[right] &gt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断左右两边是否指到同一个位置，不是则把 比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">                buf[left] = buf[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//然后是从左向右找 找到比关键元素小的，不交换，然后向左移动（right--）,直到找到比关键元素小的</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; buf[left] &lt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断左右两边是否指到同一个位置，不是则把 比关键元素大的元素放到关键元素位置上</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">                buf[right] = buf[left];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左右两边指到同一个位置(buf[left] = buf[right]) 把关键元素放到这个位置上</span></span><br><span class="line">        buf[left] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在基准元素归位之后，数组被分成了两个子数组：</span></span><br><span class="line">        <span class="comment">//左子数组：从begin到left - 1</span></span><br><span class="line">        <span class="comment">//右子数组：从left + 1到end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//随后，对这两个子数组分别调用QuickSort函数进行递归排序：</span></span><br><span class="line">        <span class="comment">//对左子数组进行排序</span></span><br><span class="line">        QuickSort(buf,begin,left<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右子数组进行排序</span></span><br><span class="line">        QuickSort(buf,left+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素（Prin）"><a href="#遍历元素（Prin）" class="headerlink" title="遍历元素（Prin）"></a>遍历元素（Prin）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    QuickSort(buf, <span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element:<span class="number">2</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">1</span>  <span class="number">7</span>  <span class="number">4</span></span><br><span class="line">Element:<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//记录key，key一般都是最左边，目的就是为了把key排到正确的位置，同时将key设为坑位</span></span><br><span class="line"><span class="comment">//开始坑在左边，右边开始找值补坑，right找到比key小的值，放入坑位，right形成新的坑</span></span><br><span class="line"><span class="comment">//现在坑在右边，左边开始找值补坑，left找到比key大的值，放入坑位，left形成新的坑</span></span><br><span class="line"><span class="comment">//直到left和right相遇就结束，最后把key放到坑位，key就排到正确的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> begin,<span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份关键元素</span></span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//备份首元素下标，尾元素下标</span></span><br><span class="line">    <span class="type">int</span> left = begin,right = end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 避免元素为空</span></span><br><span class="line">    <span class="keyword">if</span>(begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//备份关键元素(把首元素先作为关键元素)</span></span><br><span class="line">        temp = buf[begin];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当左右找到相同元素是停止</span></span><br><span class="line">        <span class="keyword">while</span> (left != right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先是从右向左找 找到比关键元素大的，不交换，然后向左移动（h--）,直到找到比关键元素小的</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; buf[right] &gt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断左右两边是否指到同一个位置，不是则把 比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">                buf[left] = buf[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//然后是从左向右找 找到比关键元素小的，不交换，然后向左移动（right--）,直到找到比关键元素小的</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; buf[left] &lt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断左右两边是否指到同一个位置，不是则把 比关键元素大的元素放到关键元素位置上</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">                buf[right] = buf[left];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左右两边指到同一个位置(buf[left] = buf[right]) 把关键元素放到这个位置上</span></span><br><span class="line">        buf[left] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在基准元素归位之后，数组被分成了两个子数组：</span></span><br><span class="line">        <span class="comment">//左子数组：从begin到left - 1</span></span><br><span class="line">        <span class="comment">//右子数组：从left + 1到end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//随后，对这两个子数组分别调用QuickSort函数进行递归排序：</span></span><br><span class="line">        <span class="comment">//对左子数组进行排序</span></span><br><span class="line">        QuickSort(buf,begin,left<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右子数组进行排序</span></span><br><span class="line">        QuickSort(buf,left+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    QuickSort(buf, <span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 十一 快速排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构十（选择排序SelectSort）</title>
      <link href="/2025/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8FSelectSort%EF%BC%89/"/>
      <url>/2025/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8FSelectSort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>选择排序 从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8FSelectSort%EF%BC%89/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序" title="选择排序"></p><p>More info: <a href="https://github.com/gybpersist/SelectSort">SelectSort</a></p><h2 id="选择排序（SelectSort）"><a href="#选择排序（SelectSort）" class="headerlink" title="选择排序（SelectSort）"></a>选择排序（SelectSort）</h2><h3 id="选择排序-从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序"><a href="#选择排序-从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序" class="headerlink" title="选择排序 从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序"></a>选择排序 从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份交换元素</span></span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 通过线性查找找到最小元素，需要比较 n-1 轮（最后一轮不用排）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; bufsize<span class="number">-1</span>; ++n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//假设每轮序列中第一个元素为最小</span></span><br><span class="line">        <span class="type">int</span> min = n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到最小元素的下标（m=n为自己和自己比,可以优化掉）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = n+<span class="number">1</span>; m &lt; bufsize; ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//比较找到最小元素下标</span></span><br><span class="line">            <span class="keyword">if</span>(buf[min] &gt; buf[m])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新最小值下标</span></span><br><span class="line">                min = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把最小元素放到前面（交换元素）</span></span><br><span class="line">        temp = buf[n];</span><br><span class="line">        buf[n] = buf[min];</span><br><span class="line">        buf[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素（Prin）"><a href="#遍历元素（Prin）" class="headerlink" title="遍历元素（Prin）"></a>遍历元素（Prin）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    SelectSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element:<span class="number">2</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">1</span>  <span class="number">7</span>  <span class="number">4</span></span><br><span class="line">Element:<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序 从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份交换元素</span></span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 通过线性查找找到最小元素，需要比较 n-1 轮（最后一轮不用排）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; bufsize<span class="number">-1</span>; ++n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//假设每轮序列中第一个元素为最小</span></span><br><span class="line">        <span class="type">int</span> min = n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到最小元素的下标（m=n为自己和自己比,可以优化掉）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = n+<span class="number">1</span>; m &lt; bufsize; ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//比较找到最小元素下标</span></span><br><span class="line">            <span class="keyword">if</span>(buf[min] &gt; buf[m])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新最小值下标</span></span><br><span class="line">                min = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把最小元素放到前面（交换元素）</span></span><br><span class="line">        temp = buf[n];</span><br><span class="line">        buf[n] = buf[min];</span><br><span class="line">        buf[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    SelectSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 十 选择排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构九（冒泡排序BubbleSort）</title>
      <link href="/2025/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8FBubbleSort%EF%BC%89/"/>
      <url>/2025/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8FBubbleSort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>插入排序 是把无序序列依次插入到有序序列，一般是从尾部开始比较</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8FBubbleSort%EF%BC%89/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序" title="插入排序"></p><p>More info: <a href="https://github.com/gybpersist/BubbleSort">BubbleSort</a></p><h2 id="冒泡排序（BubbleSort）"><a href="#冒泡排序（BubbleSort）" class="headerlink" title="冒泡排序（BubbleSort）"></a>冒泡排序（BubbleSort）</h2><h3 id="元素两两之间进行交换，需要比较n轮-n初值为1-，每轮需要-bufsize-n-次-从左到右比较，升序"><a href="#元素两两之间进行交换，需要比较n轮-n初值为1-，每轮需要-bufsize-n-次-从左到右比较，升序" class="headerlink" title="元素两两之间进行交换，需要比较n轮(n初值为1)，每轮需要 bufsize-n 次(从左到右比较，升序)"></a>元素两两之间进行交换，需要比较n轮(n初值为1)，每轮需要 bufsize-n 次(从左到右比较，升序)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份元素 临时存储交换值</span></span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 循环比较元素，比较的第n轮，总共需要比较(bufsize-1)轮</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt; bufsize; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每轮比较中需要 两两比较 的次数为（n=1 两两比较bufsize-1次；n=2 两两比较bufsize-2次...）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span> ; m &lt; bufsize-n ; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//两两比较</span></span><br><span class="line">            <span class="keyword">if</span>(buf[m] &gt; buf[m+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp=buf[m];</span><br><span class="line">                buf[m]=buf[m+<span class="number">1</span>];</span><br><span class="line">                buf[m+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素（Prin）"><a href="#遍历元素（Prin）" class="headerlink" title="遍历元素（Prin）"></a>遍历元素（Prin）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    BubbleSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element:<span class="number">2</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">1</span>  <span class="number">7</span>  <span class="number">4</span></span><br><span class="line">Element:<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序 是元素两两之间进行交换，需要比较n轮（n初值为1），每轮需要 bufsize-n 次(从左到右比较，升序)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份元素 临时存储交换值</span></span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 循环比较元素，比较的第n轮，总共需要比较(bufsize-1)轮</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt; bufsize; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每轮比较中需要 两两比较 的次数为（n=1 两两比较bufsize-1次；n=2 两两比较bufsize-2次...）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span> ; m &lt; bufsize-n ; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//两两比较</span></span><br><span class="line">            <span class="keyword">if</span>(buf[m] &gt; buf[m+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp=buf[m];</span><br><span class="line">                buf[m]=buf[m+<span class="number">1</span>];</span><br><span class="line">                buf[m+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    BubbleSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 九 冒泡排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构八（插入排序InsertSort）</title>
      <link href="/2025/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%EF%BC%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8FInsertSort%EF%BC%89/"/>
      <url>/2025/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%EF%BC%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8FInsertSort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>插入排序 是把无序序列依次插入到有序序列，一般是从尾部开始比较</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%EF%BC%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8FInsertSort%EF%BC%89/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg" alt="插入排序" title="插入排序"></p><p>More info: <a href="https://github.com/gybpersist/InsertSort">InsertSort</a></p><h2 id="插入排序（InsertSort）"><a href="#插入排序（InsertSort）" class="headerlink" title="插入排序（InsertSort）"></a>插入排序（InsertSort）</h2><h3 id="把无序序列的第一个当有序序列，然后每次从无序序列中拿出一个元素-在有序序列中进行比较（一般是从尾部开始比较）"><a href="#把无序序列的第一个当有序序列，然后每次从无序序列中拿出一个元素-在有序序列中进行比较（一般是从尾部开始比较）" class="headerlink" title="把无序序列的第一个当有序序列，然后每次从无序序列中拿出一个元素 在有序序列中进行比较（一般是从尾部开始比较）"></a>把无序序列的第一个当有序序列，然后每次从无序序列中拿出一个元素 在有序序列中进行比较（一般是从尾部开始比较）</h3><h3 id="1-如果比较结果为-待插入大于被比较的有序元素-则把待插入元素插入到被比较的有序元素后面"><a href="#1-如果比较结果为-待插入大于被比较的有序元素-则把待插入元素插入到被比较的有序元素后面" class="headerlink" title="1.如果比较结果为 待插入大于被比较的有序元素 则把待插入元素插入到被比较的有序元素后面"></a>1.如果比较结果为 待插入大于被比较的有序元素 则把待插入元素插入到被比较的有序元素后面</h3><h3 id="2-如果比较结果为-待插入小于被比较的有序元素-则把被比较的元素向后移动一位（依次与有序元素进行比较）直到来到首位或大于被比较的元素"><a href="#2-如果比较结果为-待插入小于被比较的有序元素-则把被比较的元素向后移动一位（依次与有序元素进行比较）直到来到首位或大于被比较的元素" class="headerlink" title="2.如果比较结果为 待插入小于被比较的有序元素 则把被比较的元素向后移动一位（依次与有序元素进行比较）直到来到首位或大于被比较的元素"></a>2.如果比较结果为 待插入小于被比较的有序元素 则把被比较的元素向后移动一位（依次与有序元素进行比较）直到来到首位或大于被比较的元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份元素</span></span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 选择第一个元素作为已经排序过的，剩下的元素作为无序序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; bufsize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//备份待插入元素</span></span><br><span class="line">        temp = buf[i];</span><br><span class="line">        <span class="comment">//备份待插入元素下标</span></span><br><span class="line">        <span class="type">int</span> subscript=i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把当前待插入元素与有序序列中元素进行比较，从有序序列尾部开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">-1</span> ; j &gt;= <span class="number">0</span> ; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当待插入元素 &gt; 当待插入元素前面的值</span></span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= buf[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当待插入元素 &lt; 当待插入元素前面的值</span></span><br><span class="line">            <span class="keyword">if</span>(temp &lt; buf[j])</span><br><span class="line">            &#123;</span><br><span class="line">                subscript=j;</span><br><span class="line">                <span class="comment">//把待插入元素前面的值向后移动</span></span><br><span class="line">                buf[j + <span class="number">1</span>] = buf[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把待插入元素插入指定位置</span></span><br><span class="line">        buf[subscript]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素（Prin）"><a href="#遍历元素（Prin）" class="headerlink" title="遍历元素（Prin）"></a>遍历元素（Prin）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    InsertSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element:<span class="number">2</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">1</span>  <span class="number">7</span>  <span class="number">4</span></span><br><span class="line">Element:<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序 是把无序序列依次插入到有序序列，一般是从尾部开始比较</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份元素</span></span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 选择第一个元素作为已经排序过的，剩下的元素作为无序序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; bufsize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//备份待插入元素</span></span><br><span class="line">        temp = buf[i];</span><br><span class="line">        <span class="comment">//备份待插入元素下标</span></span><br><span class="line">        <span class="type">int</span> subscript=i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把当前待插入元素与有序序列中元素进行比较，从有序序列尾部开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">-1</span> ; j &gt;= <span class="number">0</span> ; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当待插入元素 &gt; 当待插入元素前面的值</span></span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= buf[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当待插入元素 &lt; 当待插入元素前面的值</span></span><br><span class="line">            <span class="keyword">if</span>(temp &lt; buf[j])</span><br><span class="line">            &#123;</span><br><span class="line">                subscript=j;</span><br><span class="line">                <span class="comment">//把待插入元素前面的值向后移动</span></span><br><span class="line">                buf[j + <span class="number">1</span>] = buf[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把待插入元素插入指定位置</span></span><br><span class="line">        buf[subscript]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    InsertSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 八 插入排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构七（二叉树BSTree）</title>
      <link href="/2025/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91BSTree%EF%BC%89/"/>
      <url>/2025/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91BSTree%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>设计BST二叉查找树，方便对二叉树进行结点的增删，采用双向不循环链表实现，每个结点<br>都需要2个指针，分别指向该结点的左子树（lchild）和右子树（rchild）<br>附加1：计算所有节点的数量<br>附加2: 计算所以叶子节点的数量（度为0）<br>附加3: 计算二叉树的深度</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91BSTree%EF%BC%89/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树" title="二叉树"></p><p>More info: <a href="https://github.com/gybpersist/BSTree">BSTree</a></p><h2 id="构造二叉树（BSTree）"><a href="#构造二叉树（BSTree）" class="headerlink" title="构造二叉树（BSTree）"></a>构造二叉树（BSTree）</h2><h3 id="构造BST树的结点-BST树中所以结点的数据类型应该是相同的（BSTreeNode）"><a href="#构造BST树的结点-BST树中所以结点的数据类型应该是相同的（BSTreeNode）" class="headerlink" title="构造BST树的结点 BST树中所以结点的数据类型应该是相同的（BSTreeNode）"></a>构造BST树的结点 BST树中所以结点的数据类型应该是相同的（BSTreeNode）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> &#123;</span></span><br><span class="line">    dataType_t Keyval;                 <span class="comment">//BST树的键值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> *<span class="title">lchild</span>;</span>      <span class="comment">//BST树的左子树的指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> *<span class="title">rchild</span>;</span>      <span class="comment">//BST树的右子树的指针域</span></span><br><span class="line">&#125; BSTNode_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个带根结点的BST树，对BST树的根结点进行初始化（BSTree-Create）"><a href="#创建一个带根结点的BST树，对BST树的根结点进行初始化（BSTree-Create）" class="headerlink" title="创建一个带根结点的BST树，对BST树的根结点进行初始化（BSTree_Create）"></a>创建一个带根结点的BST树，对BST树的根结点进行初始化（BSTree_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BSTNode_t* <span class="title function_">BSTree_Create</span><span class="params">(dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个根结点并给根结点申请内存</span></span><br><span class="line">    BSTNode_t *Root = (BSTNode_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BSTNode_t));</span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Root is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对根结点进行初始化</span></span><br><span class="line">    Root-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    Root-&gt;Keyval = Keyval;</span><br><span class="line">    Root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（BSTree-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（BSTree-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（BSTree_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（BSTree_NewNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BSTNode_t *<span class="title function_">BSTree_NewNode</span><span class="params">(dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    BSTNode_t *NewNode = (BSTNode_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(BSTNode_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域2个）</span></span><br><span class="line">    NewNode-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    NewNode-&gt;Keyval = Keyval;</span><br><span class="line">    NewNode-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向BST树中加入结点-根结点的左子树键值比根结点的键值小，根结点的右子树键值比根结点的键值大-体现递归思想（BSTree-InsertNode）"><a href="#向BST树中加入结点-根结点的左子树键值比根结点的键值小，根结点的右子树键值比根结点的键值大-体现递归思想（BSTree-InsertNode）" class="headerlink" title="向BST树中加入结点  根结点的左子树键值比根结点的键值小，根结点的右子树键值比根结点的键值大 体现递归思想（BSTree_InsertNode）"></a>向BST树中加入结点  根结点的左子树键值比根结点的键值小，根结点的右子树键值比根结点的键值大 体现递归思想（BSTree_InsertNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_InsertNode</span><span class="params">(BSTNode_t *Root,dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.0 避免根结点地址丢失，对根结点地址进行备份</span></span><br><span class="line">    BSTNode_t *Proot = Root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.1 创建新结点并对新结点进行初始化</span></span><br><span class="line">    BSTNode_t *NewNode = BSTree_NewNode(Keyval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 此时分析当前BST树是否为空树（空树 or 非空树）</span></span><br><span class="line">    <span class="comment">//为空树</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把新结点做为BST树的根结点</span></span><br><span class="line">        Root = NewNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//为非空树,2种情况（键值 等于/不等于 根结点）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(Proot)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//新结点的键值和当前新的根结点的键值比较,相等 直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(NewNode-&gt;Keyval == Proot-&gt;Keyval)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Can Not Insert,......\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//新结点的键值和当前新的根结点的键值比较,不相等 继续分析</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//新结点的键值和当前新的根结点的键值比较,小于 把根结点的左子树作为新的根</span></span><br><span class="line">                <span class="keyword">if</span>(NewNode-&gt;Keyval &lt; Proot-&gt;Keyval)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Proot-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Proot-&gt;lchild = NewNode;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Proot = Proot-&gt;lchild;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  <span class="comment">//新结点的键值和当前新的根结点的键值比较,大于 把根结点的右子树作为新的根</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Proot-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Proot-&gt;rchild = NewNode;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Proot = Proot-&gt;rchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前序遍历-根左右-体现递归思想（BSTree-PreOrder）"><a href="#前序遍历-根左右-体现递归思想（BSTree-PreOrder）" class="headerlink" title="前序遍历 根左右 体现递归思想（BSTree_PreOrder）"></a>前序遍历 根左右 体现递归思想（BSTree_PreOrder）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_PreOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  \n&quot;</span>,Root-&gt;Keyval);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在输出根节点的左子树</span></span><br><span class="line">    BSTree_PreOrder(Root-&gt;lchild);</span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_PreOrder(Root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历-左根右-体现递归思想（BSTree-InOrder）"><a href="#中序遍历-左根右-体现递归思想（BSTree-InOrder）" class="headerlink" title="中序遍历 左根右 体现递归思想（BSTree_InOrder）"></a>中序遍历 左根右 体现递归思想（BSTree_InOrder）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_InOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先输出根节点的左子树</span></span><br><span class="line">    BSTree_InOrder(Root-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  \n&quot;</span>,Root-&gt;Keyval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_InOrder(Root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历-左右根-体现递归思想（BSTree-PostOrder）"><a href="#后序遍历-左右根-体现递归思想（BSTree-PostOrder）" class="headerlink" title="后序遍历 左右根 体现递归思想（BSTree_PostOrder）"></a>后序遍历 左右根 体现递归思想（BSTree_PostOrder）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_PostOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先输出根节点的左子树</span></span><br><span class="line">    BSTree_PostOrder(Root-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_PostOrder(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  \n&quot;</span>,Root-&gt;Keyval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附加1：计算所有节点的数量-可采用递归（BSTree-CountNode）"><a href="#附加1：计算所有节点的数量-可采用递归（BSTree-CountNode）" class="headerlink" title="附加1：计算所有节点的数量 可采用递归（BSTree_CountNode）"></a>附加1：计算所有节点的数量 可采用递归（BSTree_CountNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BSTree_CountNode</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的节点数</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设采用后序遍历计算节点数量</span></span><br><span class="line">    n1 = BSTree_CountNode(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_CountNode(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n1 + n2 +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附加2：计算所有叶子节点的数量-可采用递归（BSTree-CountLeafNode）"><a href="#附加2：计算所有叶子节点的数量-可采用递归（BSTree-CountLeafNode）" class="headerlink" title="附加2：计算所有叶子节点的数量 可采用递归（BSTree_CountLeafNode）"></a>附加2：计算所有叶子节点的数量 可采用递归（BSTree_CountLeafNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BSTree_CountLeafNode</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的节点数</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明只有一个根节点</span></span><br><span class="line">    <span class="keyword">if</span>(Root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; Root-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明有子树</span></span><br><span class="line">    n1 = BSTree_CountLeafNode(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_CountLeafNode(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附加3：计算二叉树的深度-可采用递归（BSTree-GetDepth）"><a href="#附加3：计算二叉树的深度-可采用递归（BSTree-GetDepth）" class="headerlink" title="附加3：计算二叉树的深度 可采用递归（BSTree_GetDepth）"></a>附加3：计算二叉树的深度 可采用递归（BSTree_GetDepth）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BSTree_GetDepth</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的深度</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的深度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    //被下面情况包括</span></span><br><span class="line"><span class="comment">//    //说明只有一个根节点</span></span><br><span class="line"><span class="comment">//    if(Root-&gt;lchild == NULL &amp;&amp; Root-&gt;rchild == NULL)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return 1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明有子树 计算左子树的深度 再 计算右子树的深度 最后 比较找最大再加一</span></span><br><span class="line">    n1 = BSTree_GetDepth(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_GetDepth(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ( (n1&gt;n2)?n1:n2 ) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1 创建一个带根节点的BST树</span></span><br><span class="line">    BSTNode_t *Root = BSTree_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向BST树插入新节点</span></span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">5</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">20</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">7</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">12</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">8</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">3</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">25</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//                     10</span></span><br><span class="line"><span class="comment">//            5                   20</span></span><br><span class="line"><span class="comment">//        3       7           12      25</span></span><br><span class="line"><span class="comment">//                    8                     26</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;前序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_PreOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n中序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_InOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n后序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_PostOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n总节点数：%d&quot;</span>,BSTree_CountNode(Root));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n所有叶子节点数：%d&quot;</span>,BSTree_CountLeafNode(Root));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n二叉树的深度：%d&quot;</span>,BSTree_GetDepth(Root));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">前序遍历为:</span><br><span class="line"><span class="number">10</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">20</span>  <span class="number">12</span>  <span class="number">25</span>  <span class="number">26</span></span><br><span class="line">中序遍历为:</span><br><span class="line"><span class="number">3</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">10</span>  <span class="number">12</span>  <span class="number">20</span>  <span class="number">25</span>  <span class="number">26</span></span><br><span class="line">后序遍历为:</span><br><span class="line"><span class="number">3</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">5</span>  <span class="number">12</span>  <span class="number">26</span>  <span class="number">25</span>  <span class="number">20</span>  <span class="number">10</span></span><br><span class="line">总节点数：<span class="number">9</span></span><br><span class="line">所有叶子节点数：<span class="number">4</span></span><br><span class="line">二叉树的深度：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设计BST二叉查找树，方便对二叉树进行节点的增删，采用双向不循环链表实现，每个节点</span></span><br><span class="line"><span class="comment">都需要2个指针，分别指向该节点的左子树（lchild）和右子树（rchild）</span></span><br><span class="line"><span class="comment">附加1：计算所有节点的数量</span></span><br><span class="line"><span class="comment">附加2: 计算所以叶子节点的数量（度为0）</span></span><br><span class="line"><span class="comment">附加3: 计算二叉树的深度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名 节点有效键值</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造BST树的节点 BST树中所以节点的数据类型应该是相同的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> &#123;</span></span><br><span class="line">    dataType_t Keyval;                 <span class="comment">//BST树的键值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> *<span class="title">lchild</span>;</span>      <span class="comment">//BST树的左子树的指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> *<span class="title">rchild</span>;</span>      <span class="comment">//BST树的右子树的指针域</span></span><br><span class="line">&#125; BSTNode_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建一个带根节点的BST树，对BST树的根节点进行初始化</span></span><br><span class="line">BSTNode_t* <span class="title function_">BSTree_Create</span><span class="params">(dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个根节点并给根节点申请内存</span></span><br><span class="line">    BSTNode_t *Root = (BSTNode_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BSTNode_t));</span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Root is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对根节点进行初始化</span></span><br><span class="line">    Root-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    Root-&gt;Keyval = Keyval;</span><br><span class="line">    Root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头节点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 创建新的节点，并对新节点进行初始化（数据域 指针域）</span></span><br><span class="line">BSTNode_t *<span class="title function_">BSTree_NewNode</span><span class="params">(dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新节点并给新节点申请内存</span></span><br><span class="line">    BSTNode_t *NewNode = (BSTNode_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(BSTNode_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新节点进行初始化（数据域 指针域2个）</span></span><br><span class="line">    NewNode-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    NewNode-&gt;Keyval = Keyval;</span><br><span class="line">    NewNode-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新节点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//3 向BST树中加入节点  根节点的左子树键值比根节点的键值小，根节点的右子树键值比根节点的键值大 体现递归思想</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_InsertNode</span><span class="params">(BSTNode_t *Root,dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.0 避免根节点地址丢失，对根节点地址进行备份</span></span><br><span class="line">    BSTNode_t *Proot = Root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.1 创建新节点并对新节点进行初始化</span></span><br><span class="line">    BSTNode_t *NewNode = BSTree_NewNode(Keyval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 此时分析当前BST树是否为空树（空树 or 非空树）</span></span><br><span class="line">    <span class="comment">//为空树</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把新节点做为BST树的根节点</span></span><br><span class="line">        Root = NewNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//为非空树,2种情况（键值 等于/不等于 根节点）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(Proot)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//新节点的键值和当前新的根节点的键值比较,相等 直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(NewNode-&gt;Keyval == Proot-&gt;Keyval)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Can Not Insert,......\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//新节点的键值和当前新的根节点的键值比较,不相等 继续分析</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//新节点的键值和当前新的根节点的键值比较,小于 把根节点的左子树作为新的根</span></span><br><span class="line">                <span class="keyword">if</span>(NewNode-&gt;Keyval &lt; Proot-&gt;Keyval)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Proot-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Proot-&gt;lchild = NewNode;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Proot = Proot-&gt;lchild;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  <span class="comment">//新节点的键值和当前新的根节点的键值比较,大于 把根节点的右子树作为新的根</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Proot-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Proot-&gt;rchild = NewNode;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Proot = Proot-&gt;rchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 前序遍历 根左右 体现递归思想</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_PreOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,Root-&gt;Keyval);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在输出根节点的左子树</span></span><br><span class="line">    BSTree_PreOrder(Root-&gt;lchild);</span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_PreOrder(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 中序遍历 左根右 体现递归思想</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_InOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先输出根节点的左子树</span></span><br><span class="line">    BSTree_InOrder(Root-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,Root-&gt;Keyval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_InOrder(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 后序遍历 左右根 体现递归思想</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_PostOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先输出根节点的左子树</span></span><br><span class="line">    BSTree_PostOrder(Root-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_PostOrder(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,Root-&gt;Keyval);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 附加1：计算所有节点的数量 可采用递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BSTree_CountNode</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的节点数</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设采用后序遍历计算节点数量</span></span><br><span class="line">    n1 = BSTree_CountNode(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_CountNode(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n1 + n2 +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 附加2：计算所有叶子节点的数量 可采用递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BSTree_CountLeafNode</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的节点数</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明只有一个根节点</span></span><br><span class="line">    <span class="keyword">if</span>(Root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; Root-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明有子树</span></span><br><span class="line">    n1 = BSTree_CountLeafNode(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_CountLeafNode(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 附加3：计算二叉树的深度 可采用递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BSTree_GetDepth</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的深度</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的深度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    //被下面情况包括</span></span><br><span class="line"><span class="comment">//    //说明只有一个根节点</span></span><br><span class="line"><span class="comment">//    if(Root-&gt;lchild == NULL &amp;&amp; Root-&gt;rchild == NULL)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return 1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明有子树 计算左子树的深度 再 计算右子树的深度 最后 比较找最大再加一</span></span><br><span class="line">    n1 = BSTree_GetDepth(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_GetDepth(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ( (n1&gt;n2)?n1:n2 ) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1 创建一个带根节点的BST树</span></span><br><span class="line">    BSTNode_t *Root = BSTree_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向BST树插入新节点</span></span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">5</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">20</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">7</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">12</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">8</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">3</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">25</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">26</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//                     10</span></span><br><span class="line"><span class="comment">//            5                   20</span></span><br><span class="line"><span class="comment">//        3       7           12      25</span></span><br><span class="line"><span class="comment">//                    8                     26</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;前序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_PreOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n中序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_InOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n后序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_PostOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n总节点数：%d&quot;</span>,BSTree_CountNode(Root));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n所有叶子节点数：%d&quot;</span>,BSTree_CountLeafNode(Root));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n二叉树的深度：%d&quot;</span>,BSTree_GetDepth(Root));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 七 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构六（顺序栈sequenceStack）</title>
      <link href="/2025/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/"/>
      <url>/2025/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个顺序栈实现对顺序栈内元素的<br> ——入栈<br> ——出栈<br> ——遍历顺序栈</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/%E9%A1%BA%E5%BA%8F%E6%A0%88.jpg" alt="顺序栈" title="顺序栈"></p><p>More info: <a href="https://github.com/gybpersist/sequenceStack">sequenceStack</a></p><h2 id="构造顺序栈（sequenceStack）"><a href="#构造顺序栈（sequenceStack）" class="headerlink" title="构造顺序栈（sequenceStack）"></a>构造顺序栈（sequenceStack）</h2><h3 id="构造顺序栈记录参数-顺序栈的栈底地址-顺序栈的容量-顺序栈的栈顶元素的下标"><a href="#构造顺序栈记录参数-顺序栈的栈底地址-顺序栈的容量-顺序栈的栈顶元素的下标" class="headerlink" title="构造顺序栈记录参数(顺序栈的栈底地址 顺序栈的容量 顺序栈的栈顶元素的下标)"></a>构造顺序栈记录参数(顺序栈的栈底地址 顺序栈的容量 顺序栈的栈顶元素的下标)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sequenceStack</span> &#123;</span></span><br><span class="line">    dataType_t *Bottom;       <span class="comment">//顺序栈的栈底地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;      <span class="comment">//顺序栈的容量</span></span><br><span class="line">    <span class="type">int</span> Top;               <span class="comment">//顺序栈的栈顶元素的下标</span></span><br><span class="line">&#125; sqStack_t;</span><br></pre></td></tr></table></figure><h2 id="创建顺序栈并对顺序栈进行初始化（sqStack-Create）"><a href="#创建顺序栈并对顺序栈进行初始化（sqStack-Create）" class="headerlink" title="创建顺序栈并对顺序栈进行初始化（sqStack_Create）"></a>创建顺序栈并对顺序栈进行初始化（sqStack_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sqStack_t *<span class="title function_">sqStack_Create</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 利用calloc为顺序栈的管理结构体申请堆内存</span></span><br><span class="line">    sqStack_t *manager = (sqStack_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (manager));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for manager is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 为所有元素申请堆内存 calloc,并完成错误处理</span></span><br><span class="line">    manager-&gt;Bottom = (dataType_t*)<span class="built_in">calloc</span>(size,<span class="keyword">sizeof</span>(dataType_t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager-&gt;Bottom)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for element is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(manager);  <span class="comment">//释放内存</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 对管理顺序栈的结构体进行初始化（元素容量 最后元素下标）</span></span><br><span class="line">    manager-&gt;size = size; <span class="comment">//对顺序栈的容量进行初始化</span></span><br><span class="line">    manager-&gt;Top = <span class="number">-1</span>;   <span class="comment">//由于顺序栈为空，则最后元素下标初值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序栈是否以满（sqStack-IsFull）"><a href="#判断顺序栈是否以满（sqStack-IsFull）" class="headerlink" title="判断顺序栈是否以满（sqStack_IsFull）"></a>判断顺序栈是否以满（sqStack_IsFull）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断顺序栈是否以满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_IsFull</span><span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;Top+<span class="number">1</span> == manager-&gt;size) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//        if(manager-&gt;Top+1 == manager-&gt;size)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return ture;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return false;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入栈-sqStack-Push"><a href="#入栈-sqStack-Push" class="headerlink" title="入栈(sqStack_Push)"></a>入栈(sqStack_Push)</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/%E5%85%A5%E6%A0%88.png" alt="入栈" title="入栈"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_Push</span> <span class="params">(sqStack_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 判断顺序栈是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqStack_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceStack is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 若顺序栈有空闲空间，则把新元素添加到顺序栈尾部</span></span><br><span class="line"><span class="comment">/*    manager-&gt;Top++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Bottom + manager-&gt;Top) = data;   */</span></span><br><span class="line">    manager-&gt;Bottom[++manager-&gt;Top] = data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序栈是否为空（sqStack-IsEmpty）"><a href="#判断顺序栈是否为空（sqStack-IsEmpty）" class="headerlink" title="判断顺序栈是否为空（sqStack_IsEmpty）"></a>判断顺序栈是否为空（sqStack_IsEmpty）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_IsEmpty</span><span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;Top == <span class="number">-1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出栈（sqStack-Pop）"><a href="#出栈（sqStack-Pop）" class="headerlink" title="出栈（sqStack_Pop）"></a>出栈（sqStack_Pop）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/%E5%87%BA%E6%A0%88.png" alt="出栈" title="出栈"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dataType_t <span class="title function_">sqStack_Pop</span> <span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    dataType_t temp=<span class="number">-1</span>;     <span class="comment">//记录需要出栈的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.1 判断顺序栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(sqStack_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SequenceStack is Empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 由于删掉一个元素，则顺序栈有效元素下标减一 后--（先赋值后--）</span></span><br><span class="line">    temp = manager-&gt;Bottom[manager-&gt;Top--];</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return manager-&gt;Bottom[manager-&gt;Top--];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历顺序栈（sqStack-print）"><a href="#遍历顺序栈（sqStack-print）" class="headerlink" title="遍历顺序栈（sqStack_print）"></a>遍历顺序栈（sqStack_print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5 遍历顺序栈中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqStack_print</span> <span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=manager-&gt;Top;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element[%d]=%d\n&quot;</span>,i,manager-&gt;Bottom[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 创建顺序栈</span></span><br><span class="line">    sqStack_t *manager = sqStack_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向顺序栈  入栈</span></span><br><span class="line">    sqStack_Push (manager,<span class="number">5</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">2</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">1</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">4</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">6</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 遍历顺序栈</span></span><br><span class="line">    sqStack_print (manager);     <span class="comment">//5 2 1 4 6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6 出栈</span></span><br><span class="line">    dataType_t temp1,temp2,temp3,temp4;</span><br><span class="line">    </span><br><span class="line">    temp1 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp1);</span><br><span class="line"></span><br><span class="line">    temp2 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp2);</span><br><span class="line"></span><br><span class="line">    temp3 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp3);</span><br><span class="line"></span><br><span class="line">    temp4 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d\n&quot;</span>,temp4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7 遍历顺序栈</span></span><br><span class="line">    sqStack_print (manager);     <span class="comment">//8 8 4 8 2 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Element[<span class="number">0</span>]=<span class="number">5</span></span><br><span class="line">Element[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line">Element[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">Element[<span class="number">3</span>]=<span class="number">4</span></span><br><span class="line">Element[<span class="number">4</span>]=<span class="number">6</span></span><br><span class="line">Element[<span class="number">5</span>]=<span class="number">8</span></span><br><span class="line"></span><br><span class="line"> 出栈：<span class="number">8</span>  出栈：<span class="number">6</span>  出栈：<span class="number">4</span>  出栈：<span class="number">1</span></span><br><span class="line">Element[<span class="number">0</span>]=<span class="number">5</span></span><br><span class="line">Element[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造顺序栈记录参数(顺序栈的栈底地址 顺序栈的容量 顺序栈的栈顶元素的下标)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sequenceStack</span> &#123;</span></span><br><span class="line">    dataType_t *Bottom;       <span class="comment">//顺序栈的栈底地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;      <span class="comment">//顺序栈的容量</span></span><br><span class="line">    <span class="type">int</span> Top;               <span class="comment">//顺序栈的栈顶元素的下标</span></span><br><span class="line">&#125; sqStack_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建顺序栈并对顺序栈进行初始化</span></span><br><span class="line">sqStack_t *<span class="title function_">sqStack_Create</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 利用calloc为顺序栈的管理结构体申请堆内存</span></span><br><span class="line">    sqStack_t *manager = (sqStack_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (manager));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for manager is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 为所有元素申请堆内存 calloc,并完成错误处理</span></span><br><span class="line">    manager-&gt;Bottom = (dataType_t*)<span class="built_in">calloc</span>(size,<span class="keyword">sizeof</span>(dataType_t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager-&gt;Bottom)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for element is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(manager);  <span class="comment">//释放内存</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 对管理顺序栈的结构体进行初始化（元素容量 最后元素下标）</span></span><br><span class="line">    manager-&gt;size = size; <span class="comment">//对顺序栈的容量进行初始化</span></span><br><span class="line">    manager-&gt;Top = <span class="number">-1</span>;   <span class="comment">//由于顺序栈为空，则最后元素下标初值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//判断顺序栈是否以满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_IsFull</span><span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;Top+<span class="number">1</span> == manager-&gt;size) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//        if(manager-&gt;Top+1 == manager-&gt;size)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return ture;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return false;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 顺序栈   入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_Push</span> <span class="params">(sqStack_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 判断顺序栈是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqStack_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceStack is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 若顺序栈有空闲空间，则把新元素添加到顺序栈尾部</span></span><br><span class="line"><span class="comment">/*    manager-&gt;Bottom++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Bottom + manager-&gt;Top) = data;   */</span></span><br><span class="line">    manager-&gt;Bottom[++manager-&gt;Top] = data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//判断顺序栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_IsEmpty</span><span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;Top == <span class="number">-1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//4 顺序栈  出栈</span></span><br><span class="line">dataType_t <span class="title function_">sqStack_Pop</span> <span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    dataType_t temp=<span class="number">-1</span>;     <span class="comment">//记录需要出栈的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.1 判断顺序栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(sqStack_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SequenceStack is Empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 由于删掉一个元素，则顺序栈有效元素下标减一 后--（先赋值后--）</span></span><br><span class="line">    temp = manager-&gt;Bottom[manager-&gt;Top--];</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return manager-&gt;Bottom[manager-&gt;Top--];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//5 遍历顺序栈中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqStack_print</span> <span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=manager-&gt;Top;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element[%d]=%d\n&quot;</span>,i,manager-&gt;Bottom[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 创建顺序栈</span></span><br><span class="line">    sqStack_t *manager = sqStack_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向顺序栈  入栈</span></span><br><span class="line">    sqStack_Push (manager,<span class="number">5</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">2</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">1</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">4</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">6</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 遍历顺序栈</span></span><br><span class="line">    sqStack_print (manager);     <span class="comment">//5 2 1 4 6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6 出栈</span></span><br><span class="line">    dataType_t temp1,temp2,temp3,temp4;</span><br><span class="line">    </span><br><span class="line">    temp1 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp1);</span><br><span class="line"></span><br><span class="line">    temp2 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp2);</span><br><span class="line"></span><br><span class="line">    temp3 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp3);</span><br><span class="line"></span><br><span class="line">    temp4 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d\n&quot;</span>,temp4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7 遍历顺序栈</span></span><br><span class="line">    sqStack_print (manager);     <span class="comment">//8 8 4 8 2 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 六 顺序栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 顺序栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构五（双向循环链表DoubleCirLList）</title>
      <link href="/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCircularLinkeList%EF%BC%89/"/>
      <url>/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCircularLinkeList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个双向循环链表实现对双向循环链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历双向循环链表</p><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="双向循环链表" title="双向循环链表"></p><p>More info: <a href="https://github.com/gybpersist/DoubleCirLList">DoubleCirLList</a></p><h2 id="构造双向循环链表（DoubleCirLList）"><a href="#构造双向循环链表（DoubleCirLList）" class="headerlink" title="构造双向循环链表（DoubleCirLList）"></a>构造双向循环链表（DoubleCirLList）</h2><h3 id="构造双向循环链表的结点-双向循环链表中所有结点的数据类型应该是相同的"><a href="#构造双向循环链表的结点-双向循环链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造双向循环链表的结点 双向循环链表中所有结点的数据类型应该是相同的"></a>构造双向循环链表的结点 双向循环链表中所有结点的数据类型应该是相同的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">// 双向循环链表的数据域，用于存储具体的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> *<span class="title">prev</span>;</span>   <span class="comment">// 双向循环链表的前驱指针域，指向前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> *<span class="title">next</span>;</span>   <span class="comment">// 双向循环链表的后继指针域，指向后一个节点</span></span><br><span class="line">&#125; DoubleLList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（DoubleCirLList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（DoubleCirLList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（DoubleCirLList_Create）"></a>创建一个空链表，空链表应该有一个头结点（DoubleCirLList_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t* <span class="title function_">DoubleCirLList_Create</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个头结点并给头结点申请内存，使用 calloc 函数将内存初始化为 0</span></span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span> (Head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若内存分配失败，使用 perror 输出错误信息并退出程序</span></span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对头结点进行初始化，体现循环，将头结点的 prev 和 next 指针都指向自己</span></span><br><span class="line">    Head-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把头结点的地址返回，方便后续操作</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleCirLList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleCirLList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleCirLList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleCirLList_NewNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t *<span class="title function_">DoubleCirLList_NewNode</span><span class="params">(dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新结点并给新结点申请内存，使用 calloc 函数将内存初始化为 0</span></span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若内存分配失败，使用 perror 输出错误信息并返回 NULL</span></span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对新结点进行初始化（数据域 指针域2个），体现循环，将新结点的 prev 和 next 指针都指向自己</span></span><br><span class="line">    NewNode-&gt;prev = NewNode;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把新结点的地址返回，方便后续操作</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入新节点到指定节点之后（insertAfter）"><a href="#插入新节点到指定节点之后（insertAfter）" class="headerlink" title="插入新节点到指定节点之后（insertAfter）"></a>插入新节点到指定节点之后（insertAfter）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertAfter</span><span class="params">(DoubleLList_t *node, DoubleLList_t *newNode)</span> &#123;</span><br><span class="line">    <span class="comment">// 将新节点的 next 指针指向指定节点的下一个节点</span></span><br><span class="line">    newNode-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="comment">// 将新节点的 prev 指针指向指定节点</span></span><br><span class="line">    newNode-&gt;prev = node;</span><br><span class="line">    <span class="comment">// 将指定节点的下一个节点的 prev 指针指向新节点</span></span><br><span class="line">    node-&gt;next-&gt;prev = newNode;</span><br><span class="line">    <span class="comment">// 将指定节点的 next 指针指向新节点</span></span><br><span class="line">    node-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（DoubleCirLList-HeadInsert）"><a href="#头插（DoubleCirLList-HeadInsert）" class="headerlink" title="头插（DoubleCirLList_HeadInsert）"></a>头插（DoubleCirLList_HeadInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_HeadInsert</span><span class="params">(DoubleLList_t *Head, dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">//3.1建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        Head-&gt;prev = NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下四步操作将新节点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（DoubleCirLList-TailInsert）"><a href="#尾插（DoubleCirLList-TailInsert）" class="headerlink" title="尾插（DoubleCirLList_TailInsert）"></a>尾插（DoubleCirLList_TailInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_TailInsert</span><span class="params">(DoubleLList_t *Head, dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">// 将新节点的 prev 指针指向原尾节点</span></span><br><span class="line">    NewNode-&gt;prev = Head-&gt;prev;</span><br><span class="line">    <span class="comment">// 将原尾节点的 next 指针指向新节点</span></span><br><span class="line">    Head-&gt;prev-&gt;next = NewNode;</span><br><span class="line">    <span class="comment">// 将新节点的 next 指针指向头结点</span></span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    <span class="comment">// 将头结点的 prev 指针指向新节点</span></span><br><span class="line">    Head-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（DoubleCirLList-DestInsert）"><a href="#指定插入（DoubleCirLList-DestInsert）" class="headerlink" title="指定插入（DoubleCirLList_DestInsert）"></a>指定插入（DoubleCirLList_DestInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_DestInsert</span><span class="params">(DoubleLList_t *Head, dataType_t destval, dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">// 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head &amp;&amp; Phead-&gt;data != destval) &#123;</span><br><span class="line">        <span class="comment">// 若未找到目标节点且未遍历完链表，将指针移动到下一个节点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Phead == Head) &#123;</span><br><span class="line">        <span class="comment">// 未找到目标节点，释放新节点的内存并返回 false</span></span><br><span class="line">        <span class="built_in">free</span>(NewNode);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下四步操作将新节点插入到目标节点之后</span></span><br><span class="line">    NewNode-&gt;next = Phead-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Phead-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（DoubleCirLList-Print）"><a href="#遍历链表（DoubleCirLList-Print）" class="headerlink" title="遍历链表（DoubleCirLList_Print）"></a>遍历链表（DoubleCirLList_Print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_Print</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="comment">// 若链表为空，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">// 输出当前节点的数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>, i, Phead-&gt;data);</span><br><span class="line">        <span class="comment">// 将指针移动到下一个节点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除指定节点（deleteNode）"><a href="#删除指定节点（deleteNode）" class="headerlink" title="删除指定节点（deleteNode）"></a>删除指定节点（deleteNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(DoubleLList_t *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 将指定节点的前一个节点的 next 指针指向指定节点的下一个节点</span></span><br><span class="line">    node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="comment">// 将指定节点的下一个节点的 prev 指针指向指定节点的前一个节点</span></span><br><span class="line">    node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="comment">// 将指定节点的 next 和 prev 指针置为 NULL</span></span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 释放指定节点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除首结点（DoubleCirLList-HeadDel）"><a href="#头删-删除首结点（DoubleCirLList-HeadDel）" class="headerlink" title="头删 删除首结点（DoubleCirLList_HeadDel）"></a>头删 删除首结点（DoubleCirLList_HeadDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_HeadDel</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断链表是否为空，如果为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.2 对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.3 链表非空 删除首结点</span></span><br><span class="line">    <span class="comment">// 将首结点之后的结点的 prev 指针连接到头结点</span></span><br><span class="line">    Head-&gt;next-&gt;next-&gt;prev = Head;</span><br><span class="line">    <span class="comment">// 将头结点的 next 指针指向原先首结点之后的结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.4 释放首结点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    deleteNode(Head-&gt;next);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（DoubleCirLList-TailDel）"><a href="#尾删-删除尾结点（DoubleCirLList-TailDel）" class="headerlink" title="尾删 删除尾结点（DoubleCirLList_TailDel）"></a>尾删 删除尾结点（DoubleCirLList_TailDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_TailDel</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 8.1 判断判断链表是否为空，如果为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.2 记录当前尾结点的地址</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="comment">// 将头结点的 prev 指针连接到尾结点的前一个结点</span></span><br><span class="line">    Head-&gt;next-&gt;prev = Phead-&gt;prev;</span><br><span class="line">    <span class="comment">// 将尾结点的前一个结点的 next 指针连接到头结点</span></span><br><span class="line">    Phead-&gt;prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.4 释放尾结点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    deleteNode(Head-&gt;prev);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个双向循环链表</span></span><br><span class="line">    DoubleLList_t *Head = DoubleCirLList_Create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行头插操作</span></span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">5</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">8</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">1</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">6</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行尾插操作</span></span><br><span class="line">    DoubleCirLList_TailInsert(Head, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在值为 1 的节点后插入新节点</span></span><br><span class="line">    DoubleCirLList_DestInsert(Head, <span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行头删操作</span></span><br><span class="line">    DoubleCirLList_HeadDel(Head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行尾删操作</span></span><br><span class="line">    DoubleCirLList_TailDel(Head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名，将 int 类型重命名为 dataType_t，方便后续修改数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 构造双向循环链表的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">// 双向循环链表的数据域，用于存储具体的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> *<span class="title">prev</span>;</span>   <span class="comment">// 双向循环链表的前驱指针域，指向前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> *<span class="title">next</span>;</span>   <span class="comment">// 双向循环链表的后继指针域，指向后一个节点</span></span><br><span class="line">&#125; DoubleLList_t;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 1 创建一个空链表，空链表应该有一个头结点</span></span><br><span class="line">DoubleLList_t* <span class="title function_">DoubleCirLList_Create</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个头结点并给头结点申请内存，使用 calloc 函数将内存初始化为 0</span></span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span> (Head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若内存分配失败，使用 perror 输出错误信息并退出程序</span></span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对头结点进行初始化，体现循环，将头结点的 prev 和 next 指针都指向自己</span></span><br><span class="line">    Head-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把头结点的地址返回，方便后续操作</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">DoubleLList_t *<span class="title function_">DoubleCirLList_NewNode</span><span class="params">(dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新结点并给新结点申请内存，使用 calloc 函数将内存初始化为 0</span></span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若内存分配失败，使用 perror 输出错误信息并返回 NULL</span></span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对新结点进行初始化（数据域 指针域2个），体现循环，将新结点的 prev 和 next 指针都指向自己</span></span><br><span class="line">    NewNode-&gt;prev = NewNode;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把新结点的地址返回，方便后续操作</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 插入新节点到指定节点之后</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertAfter</span><span class="params">(DoubleLList_t *node, DoubleLList_t *newNode)</span> &#123;</span><br><span class="line">    <span class="comment">// 将新节点的 next 指针指向指定节点的下一个节点</span></span><br><span class="line">    newNode-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="comment">// 将新节点的 prev 指针指向指定节点</span></span><br><span class="line">    newNode-&gt;prev = node;</span><br><span class="line">    <span class="comment">// 将指定节点的下一个节点的 prev 指针指向新节点</span></span><br><span class="line">    node-&gt;next-&gt;prev = newNode;</span><br><span class="line">    <span class="comment">// 将指定节点的 next 指针指向新节点</span></span><br><span class="line">    node-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 3 在链表中 头插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_HeadInsert</span><span class="params">(DoubleLList_t *Head, dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">//3.1建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        Head-&gt;prev = NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下四步操作将新节点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 4 在链表中 尾部插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_TailInsert</span><span class="params">(DoubleLList_t *Head, dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">// 将新节点的 prev 指针指向原尾节点</span></span><br><span class="line">    NewNode-&gt;prev = Head-&gt;prev;</span><br><span class="line">    <span class="comment">// 将原尾节点的 next 指针指向新节点</span></span><br><span class="line">    Head-&gt;prev-&gt;next = NewNode;</span><br><span class="line">    <span class="comment">// 将新节点的 next 指针指向头结点</span></span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    <span class="comment">// 将头结点的 prev 指针指向新节点</span></span><br><span class="line">    Head-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 5 在链表中 指定插入</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_DestInsert</span><span class="params">(DoubleLList_t *Head, dataType_t destval, dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">// 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head &amp;&amp; Phead-&gt;data != destval) &#123;</span><br><span class="line">        <span class="comment">// 若未找到目标节点且未遍历完链表，将指针移动到下一个节点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Phead == Head) &#123;</span><br><span class="line">        <span class="comment">// 未找到目标节点，释放新节点的内存并返回 false</span></span><br><span class="line">        <span class="built_in">free</span>(NewNode);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下四步操作将新节点插入到目标节点之后</span></span><br><span class="line">    NewNode-&gt;next = Phead-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Phead-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 6 遍历链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_Print</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="comment">// 若链表为空，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">// 输出当前节点的数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>, i, Phead-&gt;data);</span><br><span class="line">        <span class="comment">// 将指针移动到下一个节点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 删除指定节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(DoubleLList_t *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 将指定节点的前一个节点的 next 指针指向指定节点的下一个节点</span></span><br><span class="line">    node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="comment">// 将指定节点的下一个节点的 prev 指针指向指定节点的前一个节点</span></span><br><span class="line">    node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="comment">// 将指定节点的 next 和 prev 指针置为 NULL</span></span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 释放指定节点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 7 头删 删除首结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_HeadDel</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断链表是否为空，如果为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.2 对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.3 链表非空 删除首结点</span></span><br><span class="line">    <span class="comment">// 将首结点之后的结点的 prev 指针连接到头结点</span></span><br><span class="line">    Head-&gt;next-&gt;next-&gt;prev = Head;</span><br><span class="line">    <span class="comment">// 将头结点的 next 指针指向原先首结点之后的结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.4 释放首结点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    deleteNode(Head-&gt;next);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 8 尾删 删除尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_TailDel</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 8.1 判断判断链表是否为空，如果为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.2 记录当前尾结点的地址</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="comment">// 将头结点的 prev 指针连接到尾结点的前一个结点</span></span><br><span class="line">    Head-&gt;next-&gt;prev = Phead-&gt;prev;</span><br><span class="line">    <span class="comment">// 将尾结点的前一个结点的 next 指针连接到头结点</span></span><br><span class="line">    Phead-&gt;prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.4 释放尾结点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    deleteNode(Head-&gt;prev);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个双向循环链表</span></span><br><span class="line">    DoubleLList_t *Head = DoubleCirLList_Create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行头插操作</span></span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">5</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">8</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">1</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">6</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行尾插操作</span></span><br><span class="line">    DoubleCirLList_TailInsert(Head, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在值为 1 的节点后插入新节点</span></span><br><span class="line">    DoubleCirLList_DestInsert(Head, <span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行头删操作</span></span><br><span class="line">    DoubleCirLList_HeadDel(Head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行尾删操作</span></span><br><span class="line">    DoubleCirLList_TailDel(Head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 五 双向循环链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 双向循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构四（单向循环链表CircularLinkedList）</title>
      <link href="/2025/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/"/>
      <url>/2025/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个单向循环链表实现对单向循环链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历单向循环链表</p><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="单向循环链表" title="单向循环链表"></p><p>More info: <a href="https://github.com/gybpersist/CircularLinkedList">CircularLinkedList</a></p><h2 id="构造单向循环链表（CircularLinkedList）"><a href="#构造单向循环链表（CircularLinkedList）" class="headerlink" title="构造单向循环链表（CircularLinkedList）"></a>构造单向循环链表（CircularLinkedList）</h2><h3 id="构造单向循环链表的结点-单向循环链表中所有结点的数据类型应该是相同的"><a href="#构造单向循环链表的结点-单向循环链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造单向循环链表的结点 单向循环链表中所有结点的数据类型应该是相同的"></a>构造单向循环链表的结点 单向循环链表中所有结点的数据类型应该是相同的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CircularLinkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//单向循环链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CircularLinkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//单向循环链表的指针域</span></span><br><span class="line">&#125; CricLList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（CricLList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（CricLList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（CricLList_Create）"></a>创建一个空链表，空链表应该有一个头结点（CricLList_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CricLList_t* <span class="title function_">CricLList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    CricLList_t *Head = (CricLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (CricLList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化，头结点是不存储有效内容的</span></span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（CricLList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（CricLList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（CricLList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（CricLList_NewNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CricLList_t *<span class="title function_">CricLList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    CricLList_t *NewNode = (CricLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(CricLList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（CricLList-HeadInsert）"><a href="#头插（CricLList-HeadInsert）" class="headerlink" title="头插（CricLList_HeadInsert）"></a>头插（CricLList_HeadInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_HeadInsert</span><span class="params">(CricLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（CricLList-TailInsert）"><a href="#尾插（CricLList-TailInsert）" class="headerlink" title="尾插（CricLList_TailInsert）"></a>尾插（CricLList_TailInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_TailInsert</span><span class="params">(CricLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（CricLList-DestInsert）"><a href="#指定插入（CricLList-DestInsert）" class="headerlink" title="指定插入（CricLList_DestInsert）"></a>指定插入（CricLList_DestInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_DestInsert</span><span class="params">(CricLList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == Head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//代表循环完之后未找到 目标值destval</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（CricLList-Print）"><a href="#遍历链表（CricLList-Print）" class="headerlink" title="遍历链表（CricLList_Print）"></a>遍历链表（CricLList_Print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_Print</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点的地址进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除头结点（CricLList-HeadDel）"><a href="#头删-删除头结点（CricLList-HeadDel）" class="headerlink" title="头删 删除头结点（CricLList_HeadDel）"></a>头删 删除头结点（CricLList_HeadDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_HeadDel</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 对链表的首结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果链表只有一个节点，删除后让头结点指向自身</span></span><br><span class="line">    <span class="keyword">if</span> (Phead-&gt;next == Head) &#123;</span><br><span class="line">        Head-&gt;next = Head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（CricLList-TailDel）"><a href="#尾删-删除尾结点（CricLList-TailDel）" class="headerlink" title="尾删 删除尾结点（CricLList_TailDel）"></a>尾删 删除尾结点（CricLList_TailDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_TailDel</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 记录当前结点的地址</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    CricLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    CricLList_t *Head = CricLList_Create();            <span class="comment">//创建链表</span></span><br><span class="line"></span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造单向循环链表的结点 单向链循环表中所以结点的数据类型应该是相同的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CircularLinkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//单向链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CircularLinkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//单向链表的指针域</span></span><br><span class="line">&#125; CricLList_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建一个空链表，空链表应该有一个头结点</span></span><br><span class="line">CricLList_t* <span class="title function_">CricLList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    CricLList_t *Head = (CricLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (CricLList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化，头结点是不存储有效内容的,指针域指向自己，体现循环思想</span></span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">CricLList_t *<span class="title function_">CricLList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    CricLList_t *NewNode = (CricLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(CricLList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//3 在链表中 头插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_HeadInsert</span><span class="params">(CricLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//4 在链表中 尾部插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_TailInsert</span><span class="params">(CricLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next = NewNode;</span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//5 在链表中 指定插入</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_DestInsert</span><span class="params">(CricLList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == Head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//代表循环完之后未找到 目标值destval</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//6 遍历链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_Print</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点的地址进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//7 头删 删除首结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_HeadDel</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 对链表的首结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果链表只有一个节点，删除后让头结点指向自身</span></span><br><span class="line">    <span class="keyword">if</span> (Phead-&gt;next == Head) &#123;</span><br><span class="line">        Head-&gt;next = Head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//8 尾删 删除尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_TailDel</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 记录当前结点的地址</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    CricLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    CricLList_t *Head = CricLList_Create();            <span class="comment">//创建链表</span></span><br><span class="line"></span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 四 单向循环链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 单向循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构二（单向链表linkedList）</title>
      <link href="/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/"/>
      <url>/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个单向链表实现对单向链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历单向链表</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="单向链表" title="单向链表"></p><p>More info: <a href="https://github.com/gybpersist/linkedList">linkedList</a></p><h2 id="构造单向链表（linkedList）"><a href="#构造单向链表（linkedList）" class="headerlink" title="构造单向链表（linkedList）"></a>构造单向链表（linkedList）</h2><h3 id="构造单向链表的结点-单向链表中所有结点的数据类型应该是相同的"><a href="#构造单向链表的结点-单向链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造单向链表的结点 单向链表中所有结点的数据类型应该是相同的"></a>构造单向链表的结点 单向链表中所有结点的数据类型应该是相同的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//单向链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//单向链表的指针域</span></span><br><span class="line">&#125; lList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（lList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（lList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（lList_Create）"></a>创建一个空链表，空链表应该有一个头结点（lList_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lList_t* <span class="title function_">lList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    lList_t *Head = (lList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (lList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化，头结点是不存储有效内容的</span></span><br><span class="line">    Head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（lList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（lList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（lList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（lList_NewNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lList_t *<span class="title function_">lList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    lList_t *NewNode = (lList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(lList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（lList-HeadInsert）"><a href="#头插（lList-HeadInsert）" class="headerlink" title="头插（lList_HeadInsert）"></a>头插（lList_HeadInsert）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lList_HeadInsert</span><span class="params">(lList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（lList-TailInsert）"><a href="#尾插（lList-TailInsert）" class="headerlink" title="尾插（lList_TailInsert）"></a>尾插（lList_TailInsert）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lList_TailInsert</span><span class="params">(lList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（lList-DestInsert）"><a href="#指定插入（lList-DestInsert）" class="headerlink" title="指定插入（lList_DestInsert）"></a>指定插入（lList_DestInsert）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lList_DestInsert</span><span class="params">(lList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != <span class="literal">NULL</span> &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（lList-Print）"><a href="#遍历链表（lList-Print）" class="headerlink" title="遍历链表（lList_Print）"></a>遍历链表（lList_Print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lList_Print</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除首结点（lList-HeadDel）"><a href="#头删-删除首结点（lList-HeadDel）" class="headerlink" title="头删 删除首结点（lList_HeadDel）"></a>头删 删除首结点（lList_HeadDel）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lList_HeadDel</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 对链表的首结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（lList-TailDel）"><a href="#尾删-删除尾结点（lList-TailDel）" class="headerlink" title="尾删 删除尾结点（lList_TailDel）"></a>尾删 删除尾结点（lList_TailDel）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lList_TailDel</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 记录当前结点的地址</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    lList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    lList_t *Head = lList_Create();            <span class="comment">//创建链表</span></span><br><span class="line">    lList_NewNode(<span class="number">5</span>);                    <span class="comment">//创建新结点</span></span><br><span class="line"></span><br><span class="line">    lList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    lList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    lList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    lList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造单向链表的结点 单向链表中所有结点的数据类型应该是相同的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//单向链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//单向链表的指针域</span></span><br><span class="line">&#125; lList_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建一个空链表，空链表应该有一个头结点</span></span><br><span class="line">lList_t* <span class="title function_">lList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    lList_t *Head = (lList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (lList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化，头结点是不存储有效内容的</span></span><br><span class="line">    Head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">lList_t *<span class="title function_">lList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    lList_t *NewNode = (lList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(lList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//3 ccccccccc</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">lList_HeadInsert</span><span class="params">(lList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//4 在链表中 尾部插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">lList_TailInsert</span><span class="params">(lList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//5 在链表中 指定插入</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">lList_DestInsert</span><span class="params">(lList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != <span class="literal">NULL</span> &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//6 遍历链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lList_Print</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//7 头删 删除首结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">lList_HeadDel</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 对链表的首结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//8 尾删 删除尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">lList_TailDel</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 记录当前结点的地址</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    lList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    lList_t *Head = lList_Create();            <span class="comment">//创建链表</span></span><br><span class="line">    lList_NewNode(<span class="number">5</span>);                    <span class="comment">//创建新结点</span></span><br><span class="line"></span><br><span class="line">    lList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    lList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    lList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    lList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 二 单向链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 单向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构一（顺序表sequenceList）</title>
      <link href="/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8sequenceList%EF%BC%89/"/>
      <url>/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8sequenceList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p> --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个顺序表实现对顺序表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历顺序表</p><p><img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8sequenceList%EF%BC%89/%E9%A1%BA%E5%BA%8F%E8%A1%A8.png" alt="顺序表" title="顺序表"></p><p>More info: <a href="https://github.com/gybpersist/sequenceList">sequenceList</a></p><h2 id="构造顺序表（sequenceList）"><a href="#构造顺序表（sequenceList）" class="headerlink" title="构造顺序表（sequenceList）"></a>构造顺序表（sequenceList）</h2><h3 id="构造顺序表记录参数-顺序表的首地址-顺序表的容量-顺序表的有效元素的下标"><a href="#构造顺序表记录参数-顺序表的首地址-顺序表的容量-顺序表的有效元素的下标" class="headerlink" title="构造顺序表记录参数(顺序表的首地址 顺序表的容量 顺序表的有效元素的下标)"></a>构造顺序表记录参数(顺序表的首地址 顺序表的容量 顺序表的有效元素的下标)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sequenceList</span> &#123;</span></span><br><span class="line">    dataType_t *Addr;       <span class="comment">//顺序表的首地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;      <span class="comment">//顺序表的容量</span></span><br><span class="line">    <span class="type">int</span> last;               <span class="comment">//顺序表的有效元素的下标</span></span><br><span class="line">&#125; sqList_t;</span><br></pre></td></tr></table></figure><h2 id="创建顺序表并对顺序表进行初始化（sqList-Create）"><a href="#创建顺序表并对顺序表进行初始化（sqList-Create）" class="headerlink" title="创建顺序表并对顺序表进行初始化（sqList_Create）"></a>创建顺序表并对顺序表进行初始化（sqList_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sqList_t *<span class="title function_">sqList_Create</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 利用calloc为顺序表的管理结构体申请堆内存</span></span><br><span class="line">    sqList_t *manager = (sqList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (manager));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for manager is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 为所有元素申请堆内存 calloc,并完成错误处理</span></span><br><span class="line">    manager-&gt;Addr = (dataType_t*)<span class="built_in">calloc</span>(size,<span class="keyword">sizeof</span>(dataType_t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager-&gt;Addr)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for element is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(manager);  <span class="comment">//释放内存</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 对管理顺序表的结构体进行初始化（元素容量 最后元素下标）</span></span><br><span class="line">    manager-&gt;size = size; <span class="comment">//对顺序表的容量进行初始化</span></span><br><span class="line">    manager-&gt;last = <span class="number">-1</span>;   <span class="comment">//由于顺序表为空，则最后元素下标初值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序表是否以满（sqList-IsFull）"><a href="#判断顺序表是否以满（sqList-IsFull）" class="headerlink" title="判断顺序表是否以满（sqList_IsFull）"></a>判断顺序表是否以满（sqList_IsFull）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断顺序表是否以满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_IsFull</span><span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;last+<span class="number">1</span> == manager-&gt;size) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//        if(manager-&gt;last+1 == manager-&gt;size)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return ture;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return false;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（sqList-endAdd）"><a href="#尾插（sqList-endAdd）" class="headerlink" title="尾插（sqList_endAdd）"></a>尾插（sqList_endAdd）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向顺序表的尾部插入元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_endAdd</span> <span class="params">(sqList_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 判断顺序表是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceList is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 若顺序表有空闲空间，则把新元素添加到顺序表尾部</span></span><br><span class="line"><span class="comment">/*    manager-&gt;last++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span></span><br><span class="line">    manager-&gt;Addr[++manager-&gt;last] = data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（sqList-headAdd）"><a href="#头插（sqList-headAdd）" class="headerlink" title="头插（sqList_headAdd）"></a>头插（sqList_headAdd）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3 向顺序表的头部插入元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_headAdd</span> <span class="params">(sqList_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 判断顺序表是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceList is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 若顺序表有空闲空间，则把新元素添加到顺序表头部 顺序表中所以元素向后移动1个单位</span></span><br><span class="line"><span class="comment">/*    manager-&gt;last++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = manager-&gt;last;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i+<span class="number">1</span>] = manager-&gt;Addr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 把新元素放到顺序表的头部,并且更新管理结构体中的元素下标+1</span></span><br><span class="line">    manager-&gt;Addr[<span class="number">0</span>] = data;</span><br><span class="line">    manager-&gt;last++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序表是否为空（sqList-IsEmpty）"><a href="#判断顺序表是否为空（sqList-IsEmpty）" class="headerlink" title="判断顺序表是否为空（sqList_IsEmpty）"></a>判断顺序表是否为空（sqList_IsEmpty）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断顺序表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_IsEmpty</span><span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;last == <span class="number">-1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定删除（sqList-delAdd）"><a href="#指定删除（sqList-delAdd）" class="headerlink" title="指定删除（sqList_delAdd）"></a>指定删除（sqList_delAdd）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4 向顺序表删除元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_delAdd</span> <span class="params">(sqList_t *manager,dataType_t destVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">-1</span>;     <span class="comment">//记录需要删除的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.1 判断顺序表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SequenceList is Empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 需要查找目标值是否在顺序表中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt;= manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果目标值与顺序表中的值相同</span></span><br><span class="line">        <span class="keyword">if</span>(destVal == manager-&gt;Addr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            temp=i;     <span class="comment">//把目标元素的下标备份到变量temp中</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果顺序表中没有目标值的元素则终止函数</span></span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;destval [%d] is not found\n&quot;</span>,destVal);</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.4 如果顺序表中有目标值的元素，则将该元素的后继元素向前移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = temp; i &lt; manager-&gt;last; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i] = manager-&gt;Addr[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.5 由于删掉一个元素，则顺序表有效元素下标减一</span></span><br><span class="line">    manager-&gt;last--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历顺序表（sqList-print）"><a href="#遍历顺序表（sqList-print）" class="headerlink" title="遍历顺序表（sqList_print）"></a>遍历顺序表（sqList_print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5 遍历顺序表中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqList_print</span> <span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element[%d]=%d\n&quot;</span>,i,manager-&gt;Addr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 创建顺序表</span></span><br><span class="line">    sqList_t *manager = sqList_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向顺序表尾部插入新元素</span></span><br><span class="line">    sqList_endAdd (manager,<span class="number">5</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">2</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">1</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">4</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//5 2 1 4 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4 向顺序表头部插入新元素</span></span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">4</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//8 8 4 8 5 2 1 4 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6 删除顺序表中元素</span></span><br><span class="line">    sqList_delAdd (manager,<span class="number">20</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">5</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">1</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//8 8 4 8 2 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Element[<span class="number">0</span>]=<span class="number">5</span></span><br><span class="line">Element[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line">Element[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">Element[<span class="number">3</span>]=<span class="number">4</span></span><br><span class="line">Element[<span class="number">4</span>]=<span class="number">6</span></span><br><span class="line"></span><br><span class="line">Element[<span class="number">0</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">1</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">2</span>]=<span class="number">4</span></span><br><span class="line">Element[<span class="number">3</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">4</span>]=<span class="number">5</span></span><br><span class="line">Element[<span class="number">5</span>]=<span class="number">2</span></span><br><span class="line">Element[<span class="number">6</span>]=<span class="number">1</span></span><br><span class="line">Element[<span class="number">7</span>]=<span class="number">4</span></span><br><span class="line">Element[<span class="number">8</span>]=<span class="number">6</span></span><br><span class="line"></span><br><span class="line">destval [<span class="number">20</span>] is not found</span><br><span class="line">Element[<span class="number">0</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">1</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">2</span>]=<span class="number">4</span></span><br><span class="line">Element[<span class="number">3</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">4</span>]=<span class="number">2</span></span><br><span class="line">Element[<span class="number">5</span>]=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造顺序表记录参数(顺序表的首地址 顺序表的容量 顺序表的有效元素的下标)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sequenceList</span> &#123;</span></span><br><span class="line">    dataType_t *Addr;       <span class="comment">//顺序表的首地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;      <span class="comment">//顺序表的容量</span></span><br><span class="line">    <span class="type">int</span> last;               <span class="comment">//顺序表的有效元素的下标</span></span><br><span class="line">&#125; sqList_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建顺序表并对顺序表进行初始化</span></span><br><span class="line">sqList_t *<span class="title function_">sqList_Create</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 利用calloc为顺序表的管理结构体申请堆内存</span></span><br><span class="line">    sqList_t *manager = (sqList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (manager));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for manager is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 为所有元素申请堆内存 calloc,并完成错误处理</span></span><br><span class="line">    manager-&gt;Addr = (dataType_t*)<span class="built_in">calloc</span>(size,<span class="keyword">sizeof</span>(dataType_t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager-&gt;Addr)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for element is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(manager);  <span class="comment">//释放内存</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 对管理顺序表的结构体进行初始化（元素容量 最后元素下标）</span></span><br><span class="line">    manager-&gt;size = size; <span class="comment">//对顺序表的容量进行初始化</span></span><br><span class="line">    manager-&gt;last = <span class="number">-1</span>;   <span class="comment">//由于顺序表为空，则最后元素下标初值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//判断顺序表是否以满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_IsFull</span><span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;last+<span class="number">1</span> == manager-&gt;size) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//        if(manager-&gt;last+1 == manager-&gt;size)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return ture;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return false;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 向顺序表的尾部插入元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_endAdd</span> <span class="params">(sqList_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 判断顺序表是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceList is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 若顺序表有空闲空间，则把新元素添加到顺序表尾部</span></span><br><span class="line"><span class="comment">/*    manager-&gt;last++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span></span><br><span class="line">    manager-&gt;Addr[++manager-&gt;last] = data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//3 向顺序表的头部插入元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_headAdd</span> <span class="params">(sqList_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 判断顺序表是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceList is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 若顺序表有空闲空间，则把新元素添加到顺序表头部 顺序表中所以元素向后移动1个单位</span></span><br><span class="line"><span class="comment">/*    manager-&gt;last++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = manager-&gt;last;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i+<span class="number">1</span>] = manager-&gt;Addr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 把新元素放到顺序表的头部,并且更新管理结构体中的元素下标+1</span></span><br><span class="line">    manager-&gt;Addr[<span class="number">0</span>] = data;</span><br><span class="line">    manager-&gt;last++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//判断顺序表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_IsEmpty</span><span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;last == <span class="number">-1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//4 向顺序表删除元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_delAdd</span> <span class="params">(sqList_t *manager,dataType_t destVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">-1</span>;     <span class="comment">//记录需要删除的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.1 判断顺序表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SequenceList is Empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 需要查找目标值是否在顺序表中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt;= manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果目标值与顺序表中的值相同</span></span><br><span class="line">        <span class="keyword">if</span>(destVal == manager-&gt;Addr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            temp=i;     <span class="comment">//把目标元素的下标备份到变量temp中</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果顺序表中没有目标值的元素则终止函数</span></span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;destval [%d] is not found\n&quot;</span>,destVal);</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.4 如果顺序表中有目标值的元素，则将该元素的后继元素向前移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = temp; i &lt; manager-&gt;last; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i] = manager-&gt;Addr[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.5 由于删掉一个元素，则顺序表有效元素下标减一</span></span><br><span class="line">    manager-&gt;last--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//5 遍历顺序表中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqList_print</span> <span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element[%d]=%d\n&quot;</span>,i,manager-&gt;Addr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 创建顺序表</span></span><br><span class="line">    sqList_t *manager = sqList_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向顺序表尾部插入新元素</span></span><br><span class="line">    sqList_endAdd (manager,<span class="number">5</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">2</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">1</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">4</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//5 2 1 4 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4 向顺序表头部插入新元素</span></span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">4</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//8 8 4 8 5 2 1 4 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6 删除顺序表中元素</span></span><br><span class="line">    sqList_delAdd (manager,<span class="number">20</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">5</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">1</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//8 8 4 8 2 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 一 顺序表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构三（双向链表DoubleLinkedList）</title>
      <link href="/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/"/>
      <url>/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个双向链表实现对双向链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历双向链表</p><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表" title="双向链表"></p><p>More info: <a href="https://github.com/gybpersist/DoubleLinkedList">DoubleLinkedList</a></p><h2 id="构造双向链表（DoubleLinkedList）"><a href="#构造双向链表（DoubleLinkedList）" class="headerlink" title="构造双向链表（DoubleLinkedList）"></a>构造双向链表（DoubleLinkedList）</h2><h3 id="构造双向链表的结点-双向链表中所有结点的数据类型应该是相同的"><a href="#构造双向链表的结点-双向链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造双向链表的结点 双向链表中所有结点的数据类型应该是相同的"></a>构造双向链表的结点 双向链表中所有结点的数据类型应该是相同的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//双向链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> *<span class="title">prev</span>;</span>      <span class="comment">//双向链表的后继指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//双向链表的前驱指针域</span></span><br><span class="line">&#125; DoubleLList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（DoubleLList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（DoubleLList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（DoubleLList_Create）"></a>创建一个空链表，空链表应该有一个头结点（DoubleLList_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t* <span class="title function_">DoubleLList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化</span></span><br><span class="line">    Head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    Head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleLList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleLList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleLList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleLList_NewNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t *<span class="title function_">DoubleLList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域2个）</span></span><br><span class="line">    NewNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（DoubleLList-HeadInsert）"><a href="#头插（DoubleLList-HeadInsert）" class="headerlink" title="头插（DoubleLList_HeadInsert）"></a>头插（DoubleLList_HeadInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_HeadInsert</span><span class="params">(DoubleLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line">    NewNode-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（DoubleLList-TailInsert）"><a href="#尾插（DoubleLList-TailInsert）" class="headerlink" title="尾插（DoubleLList_TailInsert）"></a>尾插（DoubleLList_TailInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_TailInsert</span><span class="params">(DoubleLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（DoubleLList-DestInsert）"><a href="#指定插入（DoubleLList-DestInsert）" class="headerlink" title="指定插入（DoubleLList_DestInsert）"></a>指定插入（DoubleLList_DestInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_DestInsert</span><span class="params">(DoubleLList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != <span class="literal">NULL</span> &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（DoubleLList-Print）"><a href="#遍历链表（DoubleLList-Print）" class="headerlink" title="遍历链表（DoubleLList_Print）"></a>遍历链表（DoubleLList_Print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_Print</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点的地址进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除首结点（DoubleLList-HeadDel）"><a href="#头删-删除首结点（DoubleLList-HeadDel）" class="headerlink" title="头删 删除首结点（DoubleLList_HeadDel）"></a>头删 删除首结点（DoubleLList_HeadDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_HeadDel</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Phead-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（DoubleLList-TailDel）"><a href="#尾删-删除尾结点（DoubleLList-TailDel）" class="headerlink" title="尾删 删除尾结点（DoubleLList_TailDel）"></a>尾删 删除尾结点（DoubleLList_TailDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_TailDel</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 记录当前结点的地址</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    DoubleLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DoubleLList_t *Head = DoubleLList_Create();            <span class="comment">//创建链表</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        <span class="comment">//3 6 1 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        <span class="comment">//3 6 1 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造双向链表的结点 双向链表中所以结点的数据类型应该是相同的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//双向链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> *<span class="title">prev</span>;</span>      <span class="comment">//双向链表的后继指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//双向链表的前驱指针域</span></span><br><span class="line">&#125; DoubleLList_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建一个空链表，空链表应该有一个头结点</span></span><br><span class="line">DoubleLList_t* <span class="title function_">DoubleLList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化</span></span><br><span class="line">    Head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    Head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">DoubleLList_t *<span class="title function_">DoubleLList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域2个）</span></span><br><span class="line">    NewNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//3 在链表中 头插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_HeadInsert</span><span class="params">(DoubleLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 新节点是链表最后一个节点，next 指针置为 NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//4 在链表中 尾部插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_TailInsert</span><span class="params">(DoubleLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//5 在链表中 指定插入</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_DestInsert</span><span class="params">(DoubleLList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != <span class="literal">NULL</span> &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//6 遍历链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_Print</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点的地址进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//7 头删 删除首结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_HeadDel</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Phead-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//8 尾删 删除尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_TailDel</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 记录当前结点的地址</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    DoubleLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DoubleLList_t *Head = DoubleLList_Create();            <span class="comment">//创建链表</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        <span class="comment">//3 6 1 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        <span class="comment">//3 6 1 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 三 双向链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 双向链表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
