<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言 三</title>
      <link href="/2025/05/19/C%E8%AF%AD%E8%A8%80%20%E4%B8%89/"/>
      <url>/2025/05/19/C%E8%AF%AD%E8%A8%80%20%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p>  --><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><strong>运算符</strong></a><br><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E5%9F%BA%E7%A1%80">运算符基础</a><br><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</a><br><a href="#%E5%85%B3%E7%B3%BB%EF%BC%88%E6%AF%94%E8%BE%83%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6">关系（比较）运算符</a><br><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a><br><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</a><br><a href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</a><br><a href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6">三元运算符</a><br><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><strong>流程控制</strong></a><br><a href="#%E5%88%86%E6%94%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">分支控制语句</a><br><a href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</a>       </p> <p id = "运算符"></p> <h2 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1 运算符"></a>1 运算符</h2> <p id = "运算符基础"></p><h3 id="1-1-运算符基础"><a href="#1-1-运算符基础" class="headerlink" title="1.1 运算符基础"></a>1.1 运算符基础</h3><blockquote><p>**运算符：**也称为操作符，是一种特殊的符号，用以用于数据的运算、赋值和比较等。</p><p><strong>运算数：</strong> 也称为操作数，参与运算的数据，可以是变量、常量、表达式。</p><p><strong>表达式：</strong> 表达式具有值，可以是一个变量、一个常量，也可以是变量、常量和运算符的组合。</p></blockquote><blockquote><p><strong>运算符4要素：</strong> 功能、所需操作数个数、所组成表达式的值、有无副作用。</p><p><strong>运算符分类(按操作数个数)：</strong> 一元运算符、二元运算符、三元运算符。</p><p><strong>运算符分类(按功能)：</strong> 算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、其他运算符</p></blockquote> <p id = "算术运算符"></p><h3 id="1-2-算术运算符"><a href="#1-2-算术运算符" class="headerlink" title="1.2 算术运算符"></a>1.2 算术运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>+</code></td><td>正号</td><td>1</td><td>操作数的值</td><td>无</td></tr><tr><td><code>-</code></td><td>负号</td><td>1</td><td>操作数的值符号取反</td><td>无</td></tr><tr><td><code>+</code></td><td>相加</td><td>2</td><td>相加的值</td><td>无</td></tr><tr><td><code>-</code></td><td>相减</td><td>2</td><td>相减的值</td><td>无</td></tr><tr><td><code>*</code></td><td>相乘</td><td>2</td><td>相乘的值</td><td>无</td></tr><tr><td><code>/</code></td><td>相除</td><td>2</td><td>相除的值</td><td>无</td></tr><tr><td><code>%</code></td><td>取余（取模）</td><td>2</td><td>余数</td><td>无</td></tr><tr><td><code>++</code></td><td>自增</td><td>1</td><td></td><td>有</td></tr><tr><td><code>--</code></td><td>自减</td><td>1</td><td></td><td>有</td></tr></tbody></table><blockquote><p><strong>总结：</strong></p><ol><li>正号、负号</li><li>加、减、乘、除</li><li>取余（取模）<ul><li>表达式的值的符号与第一个操作数保持一致。</li><li>要求两个操作数必须都是整数。</li></ul></li><li>自增、自减<ul><li>如果操作数在前，取操作数自增自减之前的值作为表达式的值</li><li>如果运算符在前，取操作数自增自减之后的值作为表达式的值</li></ul></li></ol></blockquote><blockquote><p><strong>注意：</strong></p><ul><li>带有副作用的运算符，要求操作数必须是变量的形式。</li><li>C 语言规定，同一个表达中，不允许出现互相影响的带有副作用的子表达式（C 语言标准没有规定各个操作数的计算顺序，由编译器自行实现）。</li></ul></blockquote> <p id = "关系（比较）运算符"></p><h3 id="1-3-关系（比较）运算符"><a href="#1-3-关系（比较）运算符" class="headerlink" title="1.3 关系（比较）运算符"></a>1.3 关系（比较）运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>&gt;</code></td><td>大于</td><td>2</td><td>1或0</td><td>无</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td><td>2</td><td>1或0</td><td>无</td></tr><tr><td><code>&lt;</code></td><td>小于</td><td>2</td><td>1或0</td><td>无</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td><td>2</td><td>1或0</td><td>无</td></tr><tr><td><code>==</code></td><td>相等</td><td>2</td><td>1或0</td><td>无</td></tr><tr><td><code>!=</code></td><td>不相等</td><td>2</td><td>1或0</td><td>无</td></tr></tbody></table><blockquote><p><strong>总结：</strong></p><ol><li>比大小</li><li>判等</li></ol></blockquote> <p id = "逻辑运算符"></p><h3 id="1-4-逻辑运算符"><a href="#1-4-逻辑运算符" class="headerlink" title="1.4 逻辑运算符"></a>1.4 逻辑运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑与</td><td>2</td><td>两个条件都成立得1，否则得0</td><td>无</td></tr><tr><td>&#96;</td><td></td><td>&#96;</td><td>逻辑或</td><td>2</td></tr><tr><td><code>！</code></td><td>逻辑非</td><td>1</td><td>操作数非0表达式得0，操作数0表达式得1</td><td>无</td></tr></tbody></table><blockquote><p><strong>注意：</strong></p><p>逻辑与短路: 如果第一个条件不成立，第二个条件将不会执行到。</p><p>逻辑或短路：如果第一个条件就成立，第二个条件将不会比执行。</p></blockquote> <p id = "位运算符"></p><h3 id="1-5-位运算符"><a href="#1-5-位运算符" class="headerlink" title="1.5 位运算符"></a>1.5 位运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td></td><td></td><td></td><td></td></tr><tr><td>&#96;</td><td>&#96;</td><td></td><td></td><td></td></tr><tr><td><code>^</code></td><td></td><td></td><td></td><td></td></tr><tr><td><code>~</code></td><td></td><td></td><td></td><td></td></tr><tr><td><code>&lt;&lt;</code></td><td></td><td></td><td></td><td></td></tr><tr><td><code>&gt;&gt;</code></td><td>按</td><td></td><td></td><td></td></tr></tbody></table><blockquote><p><strong>总结：</strong></p></blockquote><blockquote><p><strong>按位左移和右移的快捷计算方式</strong>：</p></blockquote> <p id = "赋值运算符"></p><h3 id="1-6-赋值运算符"><a href="#1-6-赋值运算符" class="headerlink" title="1.6 赋值运算符"></a>1.6 赋值运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>=</code></td><td></td><td></td><td></td><td></td></tr><tr><td><code>+=</code></td><td></td><td></td><td></td><td></td></tr><tr><td><code>-=</code></td><td></td><td></td><td></td><td></td></tr><tr><td><code>*=</code></td><td></td><td></td><td></td><td></td></tr><tr><td><code>/=</code></td><td></td><td></td><td></td><td></td></tr><tr><td><code>%=</code></td><td></td><td></td><td></td><td></td></tr><tr><td><code>&amp;=</code></td><td></td><td></td><td></td><td></td></tr><tr><td>&#96;</td><td>&#x3D;&#96;</td><td></td><td></td><td></td></tr><tr><td><code>^=</code></td><td></td><td></td><td></td><td></td></tr><tr><td><code>&lt;&lt;=</code></td><td></td><td></td><td></td><td></td></tr><tr><td><code>&gt;&gt;=</code></td><td></td><td></td><td></td><td></td></tr></tbody></table><blockquote><p><strong>总结：</strong></p></blockquote><blockquote><p><strong>注意：</strong></p></blockquote> <p id = "三元运算符"></p><h3 id="1-7-三元运算符"><a href="#1-7-三元运算符" class="headerlink" title="1.7 三元运算符"></a>1.7 三元运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>?:</code></td><td></td><td></td><td></td><td></td></tr></tbody></table> <p id = "流程控制"></p><h2 id="2-流程控制"><a href="#2-流程控制" class="headerlink" title="2 流程控制"></a>2 流程控制</h2> <p id = "分支控制语句"></p><h3 id="2-1-分支控制语句"><a href="#2-1-分支控制语句" class="headerlink" title="2.1 分支控制语句"></a>2.1 分支控制语句</h3><h4 id="①-单向分支"><a href="#①-单向分支" class="headerlink" title="① 单向分支"></a>① 单向分支</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-双向分支"><a href="#②-双向分支" class="headerlink" title="② 双向分支"></a>② 双向分支</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③-多向分支-else-if"><a href="#③-多向分支-else-if" class="headerlink" title="③ 多向分支 else if"></a>③ 多向分支 else if</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式<span class="number">1</span>)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">2</span>)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">3</span>)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">4</span>)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④-多向分支-switch-case"><a href="#④-多向分支-switch-case" class="headerlink" title="④ 多向分支 switch case"></a>④ 多向分支 switch case</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 表达式可能的值<span class="number">1</span>：</span><br><span class="line">        语句块;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 表达式可能的值<span class="number">2</span>：</span><br><span class="line">        语句块;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 表达式可能的值<span class="number">3</span>：</span><br><span class="line">        语句块;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 表达式可能的值<span class="number">4</span>：</span><br><span class="line">        语句块;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>（1）switch 后面表达式的值必须是一个整型（char、short, int, long等）或 枚举类型。</p><p>（2）case 后面的值必须是字面量常量，而不能是变量、标识符常量。</p><p>（3）default 是可选的，当没有匹配的 case 时，执行 default。</p><p>（4）break 语句可以使程序跳出 switch 语句块，如果没有break，会执行下一个case 语句块，直到遇到break或者执行到switch结尾，这个现象称为穿透。</p></blockquote><h4 id="⑤-嵌套分支"><a href="#⑤-嵌套分支" class="headerlink" title="⑤ 嵌套分支"></a>⑤ 嵌套分支</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (条件表达式)  </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (条件表达式)  </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> C语言 三 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 运算符 </tag>
            
            <tag> 流程控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言 一</title>
      <link href="/2025/05/17/C%E8%AF%AD%E8%A8%80%20%E4%B8%80/"/>
      <url>/2025/05/17/C%E8%AF%AD%E8%A8%80%20%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p>  --><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#%E7%A8%8B%E5%BA%8F">程序</a><br><a href="#c%E8%AF%AD%E8%A8%80">c语言</a><br><a href="#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7">开发工具</a><br><a href="#%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a><br><a href="#c%E8%AF%AD%E8%A8%80%E6%89%A7%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B">c语言执行的流程</a><br><a href="#%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86">源文件中的组成部分</a><br><a href="#%E5%8F%98%E9%87%8F">变量</a><br><a href="#%E5%B8%B8%E9%87%8F">常量</a>        </p><p id = "程序"></p><h2 id="1-程序"><a href="#1-程序" class="headerlink" title="1 程序"></a>1 程序</h2><p>编写的编程语言(大量的代码(指令)组成)<br>  比如 xxx.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">   retun <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p id = "c语言"></p><h2 id="2-c语言"><a href="#2-c语言" class="headerlink" title="2 c语言"></a>2 c语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">概念: 是一个程序员使用的高级语言</span><br><span class="line">使用场景: 作为嵌入式开发的基础语言    </span><br></pre></td></tr></table></figure><p id = "开发工具"></p><h2 id="3-开发工具"><a href="#3-开发工具" class="headerlink" title="3 开发工具"></a>3 开发工具</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsCode: 免费,轻量级的开发工具</span><br></pre></td></tr></table></figure> <p id = "编译器"></p><h2 id="4-编译器"><a href="#4-编译器" class="headerlink" title="4 编译器"></a>4 编译器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minGW: 是一个windows系统的工具包,其中包含了c语言的编译器--&gt;gcc</span><br></pre></td></tr></table></figure> <p id = "c语言执行的流程"></p><h2 id="5-c语言执行的流程"><a href="#5-c语言执行的流程" class="headerlink" title="5 c语言执行的流程"></a>5 c语言执行的流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.编写源代码  xxx.c</span><br><span class="line">2.预处理     xxx.i  : 修理xxx.c的源文件(去除多余的注释,空格)</span><br><span class="line">3.编译       xxx.s  把预处理文件编译成汇编文件</span><br><span class="line">4.汇编       xxx.o  把汇编文件编译成二进制文件(机器码)</span><br><span class="line">5.链接       xxx.exe 把所有的可执行文件组合起来(自定义的xxx.o和库文件)</span><br><span class="line">6.执行       执行的就是windows中的可执行文件 xxx.exe</span><br></pre></td></tr></table></figure> <p id = "源文件中的组成部分"></p><h2 id="6-源文件中的组成部分"><a href="#6-源文件中的组成部分" class="headerlink" title="6 源文件中的组成部分"></a>6 源文件中的组成部分</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="meta">#<span class="keyword">include</span> 引入头文件</span></span><br><span class="line"><span class="number">2.</span><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="number">0</span>&#125; 主函数</span><br></pre></td></tr></table></figure> <p id = "变量"></p><h2 id="7-变量"><a href="#7-变量" class="headerlink" title="7 变量"></a>7 变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">变量的作用:  在内存中保存可变的数据</span><br><span class="line">     特点： 变量在内存中的数据是可以修改的</span><br><span class="line">   三要素:  1.变量的类型 2.标识符(变量的名字) 3.变量的值</span><br><span class="line">   </span><br><span class="line"> 标识符(变量,常量,函数,数组)的命名 的规则  </span><br><span class="line">  强制要求:</span><br><span class="line">     1.必须由字母、数字、下划线组成</span><br><span class="line">     2.数字不能开头</span><br><span class="line">     3.不能使用关键字 (类型关键字:int float ....)</span><br><span class="line">     4.严格区分大小写  （hello  ,Hello）</span><br><span class="line">     </span><br><span class="line">   推荐: 1.见名知意 (有效的单词)</span><br><span class="line">        2.小驼峰命名 (如果多个单词: myAge)</span><br></pre></td></tr></table></figure><p id = "常量"></p><h2 id="8-常量"><a href="#8-常量" class="headerlink" title="8 常量"></a>8 常量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">概念: 就是不能改变的量(内存中的数据不能被修改)</span><br><span class="line">作用: 定义程序中使用到的不可更改的数据  比如(PI=3.14)</span><br><span class="line">表现形式: </span><br><span class="line">1.const定义  ： 必须指定类型</span><br><span class="line"></span><br><span class="line">2.#define定义   不能指定类型</span><br><span class="line">   注意: 在预处理阶段自动把定义的常量值替换到程序中</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> C语言 一 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言 二</title>
      <link href="/2025/05/17/C%E8%AF%AD%E8%A8%80%20%E4%BA%8C/"/>
      <url>/2025/05/17/C%E8%AF%AD%E8%A8%80%20%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p>  --><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a><br><a href="#%E8%BF%9B%E5%88%B6%E5%88%86%E7%B1%BB">进制分类</a><br><a href="#%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F">进制表示形式</a><br><a href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</a><br><a href="#%E5%8E%9F%E5%8F%8D%E8%A1%A5%E7%A0%81">原码 反码 补码</a><br><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a><br><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96">数据类型转化</a>        </p> <p id = "二进制"></p> <h2 id="1-二进制"><a href="#1-二进制" class="headerlink" title="1 二进制"></a>1 二进制</h2> <p id = "进制分类"></p> <h3 id="1-1-进制分类"><a href="#1-1-进制分类" class="headerlink" title="1.1 进制分类"></a>1.1 进制分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.二进制</span><br><span class="line">2.十进制</span><br><span class="line">3.十六进制</span><br></pre></td></tr></table></figure><p id = "进制表示形式"></p> <h3 id="1-2-不同进制表示形式"><a href="#1-2-不同进制表示形式" class="headerlink" title="1.2 不同进制表示形式"></a>1.2 不同进制表示形式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">十进制: 就是十进制(无特殊)</span><br><span class="line">二进制: 0b010101</span><br><span class="line">十六进制: 0x  0X  #0x  #0X</span><br></pre></td></tr></table></figure> <p id = "进制转换"></p> <h3 id="1-3-进制之间的转换"><a href="#1-3-进制之间的转换" class="headerlink" title="1.3 进制之间的转换"></a>1.3 进制之间的转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">二进制转十进制</span><br><span class="line">    方式:  从低位开始,提取每一位的数据,乘以<span class="number">2</span>的(位数<span class="number">-1</span>)次方， 结果相加</span><br><span class="line">       <span class="number">0111</span> 二进制</span><br><span class="line">       <span class="number">0</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">       <span class="number">1</span>*<span class="number">2</span>^(<span class="number">1</span><span class="number">-1</span>)=<span class="number">1</span></span><br><span class="line">       <span class="number">1</span>*<span class="number">2</span>^(<span class="number">2</span><span class="number">-1</span>)=<span class="number">2</span></span><br><span class="line">       <span class="number">1</span>*<span class="number">2</span>^(<span class="number">3</span><span class="number">-1</span>)=<span class="number">4</span></span><br><span class="line">       <span class="number">0</span>*<span class="number">2</span>^(<span class="number">3</span><span class="number">-1</span>)=<span class="number">0</span></span><br><span class="line">       <span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span>+<span class="number">0</span>=<span class="number">7</span></span><br><span class="line"></span><br><span class="line">十进制转二进制</span><br><span class="line">    方式: 使用该数不断的除以<span class="number">2</span>,直到商为零结束， 最后把每一步计算的余数倒叙组合就是二进制       </span><br><span class="line">       <span class="number">10</span>十进制 转为二进制</span><br><span class="line">        <span class="number">10</span>%<span class="number">2</span>=<span class="number">5</span> 余 <span class="number">0</span></span><br><span class="line">        <span class="number">5</span>%<span class="number">2</span>=<span class="number">2</span> 余 <span class="number">1</span></span><br><span class="line">        <span class="number">2</span>%<span class="number">2</span>=<span class="number">1</span> 余 <span class="number">0</span></span><br><span class="line">        <span class="number">1</span>%<span class="number">2</span>=<span class="number">0</span> 余 <span class="number">1</span></span><br><span class="line">        <span class="number">1010</span></span><br><span class="line"></span><br><span class="line">十六进制转为十进制</span><br><span class="line">    方式:  从低位开始,提取每一位的数据,乘以<span class="number">16</span>的(位数<span class="number">-1</span>)次方， 结果相加   </span><br><span class="line">           #<span class="number">0x12A</span></span><br><span class="line">           (A)<span class="number">10</span>*<span class="number">16</span>^<span class="number">0</span>=<span class="number">10</span></span><br><span class="line">           (<span class="number">2</span>)<span class="number">2</span>* <span class="number">16</span>^<span class="number">1</span>=<span class="number">32</span></span><br><span class="line">           (<span class="number">1</span>)<span class="number">1</span>*<span class="number">16</span>^<span class="number">2</span>=<span class="number">256</span></span><br><span class="line">          <span class="number">256</span>+<span class="number">32</span>+<span class="number">10</span>=<span class="number">298</span></span><br><span class="line">十进制转为十六进制     </span><br><span class="line">    方式: 使用该数不断的除以<span class="number">16</span>,直到商为零结束， 最后把每一步计算的余数倒叙组合就是二进制  </span><br><span class="line">             <span class="number">33</span>（十进制）</span><br><span class="line">             <span class="number">33</span>%<span class="number">16</span>=<span class="number">2</span> 余 <span class="number">1</span></span><br><span class="line">             <span class="number">2</span>%<span class="number">16</span>=<span class="number">0</span>  余 <span class="number">2</span></span><br><span class="line">            十六进制的结果: <span class="number">21</span></span><br><span class="line">   </span><br><span class="line">二进制转为十六进制</span><br><span class="line">    方式: 把二进制每<span class="number">4</span>位一组,计算十六进制          </span><br><span class="line">      <span class="number">1001</span>  <span class="number">1100</span>   </span><br><span class="line">       <span class="number">9</span>（十进制）     <span class="number">12</span>（十进制）</span><br><span class="line">      十六进制结果:  <span class="number">9</span>C  </span><br><span class="line">                </span><br><span class="line">十六进制转为二进制   </span><br><span class="line">    方式:  把每一位转成<span class="number">4</span>位一组的二进制  </span><br><span class="line">                    <span class="number">9</span>C    </span><br><span class="line">         （C）<span class="number">12</span>=<span class="number">8</span>+<span class="number">4</span>  二进制表示:  <span class="number">1010</span>  </span><br><span class="line">          (<span class="number">9</span>) <span class="number">9</span>=<span class="number">8</span>+<span class="number">1</span>  二进制表示:  <span class="number">1001</span>   </span><br><span class="line">            二进制结果: <span class="number">10011010</span>     </span><br></pre></td></tr></table></figure> <p id = "原反补码"></p> <h3 id="1-4-原码-反码-补码"><a href="#1-4-原码-反码-补码" class="headerlink" title="1.4 原码 反码 补码"></a>1.4 原码 反码 补码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">机器数: 就是二进制数据</span><br><span class="line">形式值：没有符号位   1111  最高位不是符号位</span><br><span class="line">真值： 有符号位     1111（ 最高位是符号位）</span><br><span class="line"></span><br><span class="line">原码:  真值</span><br><span class="line">反码:  </span><br><span class="line">  正数的反码就是原码</span><br><span class="line">  负数的反码符号位不变其余取反 1111---&gt; 1000</span><br><span class="line">补码：</span><br><span class="line">  正数的补码就是原码</span><br><span class="line">  负数的补码就是反码+1,符号位不变</span><br><span class="line">  </span><br><span class="line">总结:1.正数的 原码 反码 补码 一致  </span><br><span class="line">    2.计算中存储的数据都是以补码形式存在  </span><br></pre></td></tr></table></figure> <p id = "数据类型"></p> <h3 id="1-5-数据类型"><a href="#1-5-数据类型" class="headerlink" title="1.5 数据类型"></a>1.5 数据类型</h3><table><thead><tr><th>整型</th><th>浮点型</th><th>布尔类型</th></tr></thead><tbody><tr><td>char           1字节</td><td>float 4字节</td><td>宏定义(自定义布尔类): #define BOOL int</td></tr><tr><td>short          2字节</td><td>double 8字节</td><td>使用c99标准中:<em>Bool</em></td></tr><tr><td>int               4字节</td><td>long double 16字节</td><td>使用c99标准: 导入头文件<br /><br />&lt;stdbool.h&gt;</td></tr><tr><td>long           （32:4字节    64：8字节） —&gt; 现在的笔记本是使用了32位系统的转化方式(4字节)</td><td></td><td></td></tr><tr><td>long long    8字节</td><td></td><td></td></tr></tbody></table><p id = "数据类型转化"></p> <h3 id="1-6-数据类型转化"><a href="#1-6-数据类型转化" class="headerlink" title="1.6 数据类型转化"></a>1.6 数据类型转化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">自动类型转换:  窄类型转为宽类型</span><br><span class="line">1.运算过程中的自动类型转换(隐式转换)   </span><br><span class="line">比如: int a=1;short b=2  </span><br><span class="line">计算: a+b 结果是int类型</span><br><span class="line"></span><br><span class="line">2.赋值过程中的自动类型转换(隐式转换)   </span><br><span class="line">比如: float f=3.14;  自动把double类型转为了float类型</span><br><span class="line"></span><br><span class="line">3.强制类型转化</span><br><span class="line">   宽类型转为窄类型</span><br><span class="line">   案例: </span><br><span class="line">      //计算三个人的平均年龄  </span><br><span class="line">      int age1=20,age2=23,age3=24;</span><br><span class="line">      </span><br><span class="line">      //printf(&quot;%lf&quot;,(age1+age2+age3)/3.0);         // 22.333333</span><br><span class="line">      printf(&quot;%lf&quot;,(double)((age1+age2+age3)/3));   // 22.000000</span><br><span class="line">      printf(&quot;%lf&quot;,(double)(age1+age2+age3)/3);     // 22.333333</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> C语言 二 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 二进制 </tag>
            
            <tag> 进制分类 </tag>
            
            <tag> 进制表示形式 </tag>
            
            <tag> 进制转换 </tag>
            
            <tag> 原码 反码 补码 </tag>
            
            <tag> 数据类型 </tag>
            
            <tag> 数据类型转化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构十一（快速排序QuickSort）</title>
      <link href="/2025/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%E4%B8%80%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FQuickSort%EF%BC%89/"/>
      <url>/2025/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%E4%B8%80%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FQuickSort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录key，key一般都是最左边，目的就是为了把key排到正确的位置，同时将key设为坑位<br>开始坑在左边，右边开始找值补坑，right找到比key小的值，放入坑位，right形成新的坑<br>现在坑在右边，左边开始找值补坑，left找到比key大的值，放入坑位，left形成新的坑<br>直到left和right相遇就结束，最后把key放到坑位，key就排到正确的位置</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%E4%B8%80%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FQuickSort%EF%BC%89/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序" title="快速排序"></p><p>More info: <a href="https://github.com/gybpersist/QuickSort">QuickSort</a></p><h2 id="快速排序（QuickSort）"><a href="#快速排序（QuickSort）" class="headerlink" title="快速排序（QuickSort）"></a>快速排序（QuickSort）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> begin,<span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份关键元素</span></span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//备份首元素下标，尾元素下标</span></span><br><span class="line">    <span class="type">int</span> left = begin,right = end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 避免元素为空</span></span><br><span class="line">    <span class="keyword">if</span>(begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//备份关键元素(把首元素先作为关键元素)</span></span><br><span class="line">        temp = buf[begin];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当左右找到相同元素是停止</span></span><br><span class="line">        <span class="keyword">while</span> (left != right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先是从右向左找 找到比关键元素大的，不交换，然后向左移动（h--）,直到找到比关键元素小的</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; buf[right] &gt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断左右两边是否指到同一个位置，不是则把 比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">                buf[left] = buf[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//然后是从左向右找 找到比关键元素小的，不交换，然后向左移动（right--）,直到找到比关键元素小的</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; buf[left] &lt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断左右两边是否指到同一个位置，不是则把 比关键元素大的元素放到关键元素位置上</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">                buf[right] = buf[left];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左右两边指到同一个位置(buf[left] = buf[right]) 把关键元素放到这个位置上</span></span><br><span class="line">        buf[left] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在基准元素归位之后，数组被分成了两个子数组：</span></span><br><span class="line">        <span class="comment">//左子数组：从begin到left - 1</span></span><br><span class="line">        <span class="comment">//右子数组：从left + 1到end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//随后，对这两个子数组分别调用QuickSort函数进行递归排序：</span></span><br><span class="line">        <span class="comment">//对左子数组进行排序</span></span><br><span class="line">        QuickSort(buf,begin,left<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右子数组进行排序</span></span><br><span class="line">        QuickSort(buf,left+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素（Prin）"><a href="#遍历元素（Prin）" class="headerlink" title="遍历元素（Prin）"></a>遍历元素（Prin）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    QuickSort(buf, <span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element:<span class="number">2</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">1</span>  <span class="number">7</span>  <span class="number">4</span></span><br><span class="line">Element:<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//记录key，key一般都是最左边，目的就是为了把key排到正确的位置，同时将key设为坑位</span></span><br><span class="line"><span class="comment">//开始坑在左边，右边开始找值补坑，right找到比key小的值，放入坑位，right形成新的坑</span></span><br><span class="line"><span class="comment">//现在坑在右边，左边开始找值补坑，left找到比key大的值，放入坑位，left形成新的坑</span></span><br><span class="line"><span class="comment">//直到left和right相遇就结束，最后把key放到坑位，key就排到正确的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> begin,<span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份关键元素</span></span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//备份首元素下标，尾元素下标</span></span><br><span class="line">    <span class="type">int</span> left = begin,right = end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 避免元素为空</span></span><br><span class="line">    <span class="keyword">if</span>(begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//备份关键元素(把首元素先作为关键元素)</span></span><br><span class="line">        temp = buf[begin];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当左右找到相同元素是停止</span></span><br><span class="line">        <span class="keyword">while</span> (left != right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先是从右向左找 找到比关键元素大的，不交换，然后向左移动（h--）,直到找到比关键元素小的</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; buf[right] &gt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断左右两边是否指到同一个位置，不是则把 比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">                buf[left] = buf[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//然后是从左向右找 找到比关键元素小的，不交换，然后向左移动（right--）,直到找到比关键元素小的</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; buf[left] &lt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断左右两边是否指到同一个位置，不是则把 比关键元素大的元素放到关键元素位置上</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">                buf[right] = buf[left];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左右两边指到同一个位置(buf[left] = buf[right]) 把关键元素放到这个位置上</span></span><br><span class="line">        buf[left] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在基准元素归位之后，数组被分成了两个子数组：</span></span><br><span class="line">        <span class="comment">//左子数组：从begin到left - 1</span></span><br><span class="line">        <span class="comment">//右子数组：从left + 1到end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//随后，对这两个子数组分别调用QuickSort函数进行递归排序：</span></span><br><span class="line">        <span class="comment">//对左子数组进行排序</span></span><br><span class="line">        QuickSort(buf,begin,left<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右子数组进行排序</span></span><br><span class="line">        QuickSort(buf,left+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    QuickSort(buf, <span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 十一 快速排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构十（选择排序SelectSort）</title>
      <link href="/2025/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8FSelectSort%EF%BC%89/"/>
      <url>/2025/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8FSelectSort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>选择排序 从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8FSelectSort%EF%BC%89/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序" title="选择排序"></p><p>More info: <a href="https://github.com/gybpersist/SelectSort">SelectSort</a></p><h2 id="选择排序（SelectSort）"><a href="#选择排序（SelectSort）" class="headerlink" title="选择排序（SelectSort）"></a>选择排序（SelectSort）</h2><h3 id="选择排序-从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序"><a href="#选择排序-从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序" class="headerlink" title="选择排序 从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序"></a>选择排序 从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份交换元素</span></span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 通过线性查找找到最小元素，需要比较 n-1 轮（最后一轮不用排）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; bufsize<span class="number">-1</span>; ++n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//假设每轮序列中第一个元素为最小</span></span><br><span class="line">        <span class="type">int</span> min = n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到最小元素的下标（m=n为自己和自己比,可以优化掉）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = n+<span class="number">1</span>; m &lt; bufsize; ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//比较找到最小元素下标</span></span><br><span class="line">            <span class="keyword">if</span>(buf[min] &gt; buf[m])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新最小值下标</span></span><br><span class="line">                min = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把最小元素放到前面（交换元素）</span></span><br><span class="line">        temp = buf[n];</span><br><span class="line">        buf[n] = buf[min];</span><br><span class="line">        buf[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素（Prin）"><a href="#遍历元素（Prin）" class="headerlink" title="遍历元素（Prin）"></a>遍历元素（Prin）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    SelectSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element:<span class="number">2</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">1</span>  <span class="number">7</span>  <span class="number">4</span></span><br><span class="line">Element:<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序 从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份交换元素</span></span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 通过线性查找找到最小元素，需要比较 n-1 轮（最后一轮不用排）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; bufsize<span class="number">-1</span>; ++n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//假设每轮序列中第一个元素为最小</span></span><br><span class="line">        <span class="type">int</span> min = n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到最小元素的下标（m=n为自己和自己比,可以优化掉）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = n+<span class="number">1</span>; m &lt; bufsize; ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//比较找到最小元素下标</span></span><br><span class="line">            <span class="keyword">if</span>(buf[min] &gt; buf[m])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新最小值下标</span></span><br><span class="line">                min = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把最小元素放到前面（交换元素）</span></span><br><span class="line">        temp = buf[n];</span><br><span class="line">        buf[n] = buf[min];</span><br><span class="line">        buf[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    SelectSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 十 选择排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构九（冒泡排序BubbleSort）</title>
      <link href="/2025/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8FBubbleSort%EF%BC%89/"/>
      <url>/2025/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8FBubbleSort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>插入排序 是把无序序列依次插入到有序序列，一般是从尾部开始比较</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8FBubbleSort%EF%BC%89/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序" title="插入排序"></p><p>More info: <a href="https://github.com/gybpersist/BubbleSort">BubbleSort</a></p><h2 id="冒泡排序（BubbleSort）"><a href="#冒泡排序（BubbleSort）" class="headerlink" title="冒泡排序（BubbleSort）"></a>冒泡排序（BubbleSort）</h2><h3 id="元素两两之间进行交换，需要比较n轮-n初值为1-，每轮需要-bufsize-n-次-从左到右比较，升序"><a href="#元素两两之间进行交换，需要比较n轮-n初值为1-，每轮需要-bufsize-n-次-从左到右比较，升序" class="headerlink" title="元素两两之间进行交换，需要比较n轮(n初值为1)，每轮需要 bufsize-n 次(从左到右比较，升序)"></a>元素两两之间进行交换，需要比较n轮(n初值为1)，每轮需要 bufsize-n 次(从左到右比较，升序)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份元素 临时存储交换值</span></span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 循环比较元素，比较的第n轮，总共需要比较(bufsize-1)轮</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt; bufsize; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每轮比较中需要 两两比较 的次数为（n=1 两两比较bufsize-1次；n=2 两两比较bufsize-2次...）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span> ; m &lt; bufsize-n ; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//两两比较</span></span><br><span class="line">            <span class="keyword">if</span>(buf[m] &gt; buf[m+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp=buf[m];</span><br><span class="line">                buf[m]=buf[m+<span class="number">1</span>];</span><br><span class="line">                buf[m+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素（Prin）"><a href="#遍历元素（Prin）" class="headerlink" title="遍历元素（Prin）"></a>遍历元素（Prin）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    BubbleSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element:<span class="number">2</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">1</span>  <span class="number">7</span>  <span class="number">4</span></span><br><span class="line">Element:<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序 是元素两两之间进行交换，需要比较n轮（n初值为1），每轮需要 bufsize-n 次(从左到右比较，升序)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份元素 临时存储交换值</span></span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 循环比较元素，比较的第n轮，总共需要比较(bufsize-1)轮</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt; bufsize; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每轮比较中需要 两两比较 的次数为（n=1 两两比较bufsize-1次；n=2 两两比较bufsize-2次...）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span> ; m &lt; bufsize-n ; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//两两比较</span></span><br><span class="line">            <span class="keyword">if</span>(buf[m] &gt; buf[m+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp=buf[m];</span><br><span class="line">                buf[m]=buf[m+<span class="number">1</span>];</span><br><span class="line">                buf[m+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    BubbleSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 九 冒泡排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构八（插入排序InsertSort）</title>
      <link href="/2025/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%EF%BC%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8FInsertSort%EF%BC%89/"/>
      <url>/2025/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%EF%BC%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8FInsertSort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>插入排序 是把无序序列依次插入到有序序列，一般是从尾部开始比较</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%EF%BC%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8FInsertSort%EF%BC%89/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg" alt="插入排序" title="插入排序"></p><p>More info: <a href="https://github.com/gybpersist/InsertSort">InsertSort</a></p><h2 id="插入排序（InsertSort）"><a href="#插入排序（InsertSort）" class="headerlink" title="插入排序（InsertSort）"></a>插入排序（InsertSort）</h2><h3 id="把无序序列的第一个当有序序列，然后每次从无序序列中拿出一个元素-在有序序列中进行比较（一般是从尾部开始比较）"><a href="#把无序序列的第一个当有序序列，然后每次从无序序列中拿出一个元素-在有序序列中进行比较（一般是从尾部开始比较）" class="headerlink" title="把无序序列的第一个当有序序列，然后每次从无序序列中拿出一个元素 在有序序列中进行比较（一般是从尾部开始比较）"></a>把无序序列的第一个当有序序列，然后每次从无序序列中拿出一个元素 在有序序列中进行比较（一般是从尾部开始比较）</h3><h3 id="1-如果比较结果为-待插入大于被比较的有序元素-则把待插入元素插入到被比较的有序元素后面"><a href="#1-如果比较结果为-待插入大于被比较的有序元素-则把待插入元素插入到被比较的有序元素后面" class="headerlink" title="1.如果比较结果为 待插入大于被比较的有序元素 则把待插入元素插入到被比较的有序元素后面"></a>1.如果比较结果为 待插入大于被比较的有序元素 则把待插入元素插入到被比较的有序元素后面</h3><h3 id="2-如果比较结果为-待插入小于被比较的有序元素-则把被比较的元素向后移动一位（依次与有序元素进行比较）直到来到首位或大于被比较的元素"><a href="#2-如果比较结果为-待插入小于被比较的有序元素-则把被比较的元素向后移动一位（依次与有序元素进行比较）直到来到首位或大于被比较的元素" class="headerlink" title="2.如果比较结果为 待插入小于被比较的有序元素 则把被比较的元素向后移动一位（依次与有序元素进行比较）直到来到首位或大于被比较的元素"></a>2.如果比较结果为 待插入小于被比较的有序元素 则把被比较的元素向后移动一位（依次与有序元素进行比较）直到来到首位或大于被比较的元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份元素</span></span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 选择第一个元素作为已经排序过的，剩下的元素作为无序序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; bufsize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//备份待插入元素</span></span><br><span class="line">        temp = buf[i];</span><br><span class="line">        <span class="comment">//备份待插入元素下标</span></span><br><span class="line">        <span class="type">int</span> subscript=i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把当前待插入元素与有序序列中元素进行比较，从有序序列尾部开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">-1</span> ; j &gt;= <span class="number">0</span> ; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当待插入元素 &gt; 当待插入元素前面的值</span></span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= buf[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当待插入元素 &lt; 当待插入元素前面的值</span></span><br><span class="line">            <span class="keyword">if</span>(temp &lt; buf[j])</span><br><span class="line">            &#123;</span><br><span class="line">                subscript=j;</span><br><span class="line">                <span class="comment">//把待插入元素前面的值向后移动</span></span><br><span class="line">                buf[j + <span class="number">1</span>] = buf[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把待插入元素插入指定位置</span></span><br><span class="line">        buf[subscript]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素（Prin）"><a href="#遍历元素（Prin）" class="headerlink" title="遍历元素（Prin）"></a>遍历元素（Prin）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    InsertSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element:<span class="number">2</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">1</span>  <span class="number">7</span>  <span class="number">4</span></span><br><span class="line">Element:<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序 是把无序序列依次插入到有序序列，一般是从尾部开始比较</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份元素</span></span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 选择第一个元素作为已经排序过的，剩下的元素作为无序序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; bufsize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//备份待插入元素</span></span><br><span class="line">        temp = buf[i];</span><br><span class="line">        <span class="comment">//备份待插入元素下标</span></span><br><span class="line">        <span class="type">int</span> subscript=i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把当前待插入元素与有序序列中元素进行比较，从有序序列尾部开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">-1</span> ; j &gt;= <span class="number">0</span> ; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当待插入元素 &gt; 当待插入元素前面的值</span></span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= buf[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当待插入元素 &lt; 当待插入元素前面的值</span></span><br><span class="line">            <span class="keyword">if</span>(temp &lt; buf[j])</span><br><span class="line">            &#123;</span><br><span class="line">                subscript=j;</span><br><span class="line">                <span class="comment">//把待插入元素前面的值向后移动</span></span><br><span class="line">                buf[j + <span class="number">1</span>] = buf[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把待插入元素插入指定位置</span></span><br><span class="line">        buf[subscript]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    InsertSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 八 插入排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构七（二叉树BSTree）</title>
      <link href="/2025/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91BSTree%EF%BC%89/"/>
      <url>/2025/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91BSTree%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>设计BST二叉查找树，方便对二叉树进行结点的增删，采用双向不循环链表实现，每个结点<br>都需要2个指针，分别指向该结点的左子树（lchild）和右子树（rchild）<br>附加1：计算所有节点的数量<br>附加2: 计算所以叶子节点的数量（度为0）<br>附加3: 计算二叉树的深度</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91BSTree%EF%BC%89/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树" title="二叉树"></p><p>More info: <a href="https://github.com/gybpersist/BSTree">BSTree</a></p><h2 id="构造二叉树（BSTree）"><a href="#构造二叉树（BSTree）" class="headerlink" title="构造二叉树（BSTree）"></a>构造二叉树（BSTree）</h2><h3 id="构造BST树的结点-BST树中所以结点的数据类型应该是相同的（BSTreeNode）"><a href="#构造BST树的结点-BST树中所以结点的数据类型应该是相同的（BSTreeNode）" class="headerlink" title="构造BST树的结点 BST树中所以结点的数据类型应该是相同的（BSTreeNode）"></a>构造BST树的结点 BST树中所以结点的数据类型应该是相同的（BSTreeNode）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> &#123;</span></span><br><span class="line">    dataType_t Keyval;                 <span class="comment">//BST树的键值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> *<span class="title">lchild</span>;</span>      <span class="comment">//BST树的左子树的指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> *<span class="title">rchild</span>;</span>      <span class="comment">//BST树的右子树的指针域</span></span><br><span class="line">&#125; BSTNode_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个带根结点的BST树，对BST树的根结点进行初始化（BSTree-Create）"><a href="#创建一个带根结点的BST树，对BST树的根结点进行初始化（BSTree-Create）" class="headerlink" title="创建一个带根结点的BST树，对BST树的根结点进行初始化（BSTree_Create）"></a>创建一个带根结点的BST树，对BST树的根结点进行初始化（BSTree_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BSTNode_t* <span class="title function_">BSTree_Create</span><span class="params">(dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个根结点并给根结点申请内存</span></span><br><span class="line">    BSTNode_t *Root = (BSTNode_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BSTNode_t));</span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Root is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对根结点进行初始化</span></span><br><span class="line">    Root-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    Root-&gt;Keyval = Keyval;</span><br><span class="line">    Root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（BSTree-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（BSTree-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（BSTree_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（BSTree_NewNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BSTNode_t *<span class="title function_">BSTree_NewNode</span><span class="params">(dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    BSTNode_t *NewNode = (BSTNode_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(BSTNode_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域2个）</span></span><br><span class="line">    NewNode-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    NewNode-&gt;Keyval = Keyval;</span><br><span class="line">    NewNode-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向BST树中加入结点-根结点的左子树键值比根结点的键值小，根结点的右子树键值比根结点的键值大-体现递归思想（BSTree-InsertNode）"><a href="#向BST树中加入结点-根结点的左子树键值比根结点的键值小，根结点的右子树键值比根结点的键值大-体现递归思想（BSTree-InsertNode）" class="headerlink" title="向BST树中加入结点  根结点的左子树键值比根结点的键值小，根结点的右子树键值比根结点的键值大 体现递归思想（BSTree_InsertNode）"></a>向BST树中加入结点  根结点的左子树键值比根结点的键值小，根结点的右子树键值比根结点的键值大 体现递归思想（BSTree_InsertNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_InsertNode</span><span class="params">(BSTNode_t *Root,dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.0 避免根结点地址丢失，对根结点地址进行备份</span></span><br><span class="line">    BSTNode_t *Proot = Root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.1 创建新结点并对新结点进行初始化</span></span><br><span class="line">    BSTNode_t *NewNode = BSTree_NewNode(Keyval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 此时分析当前BST树是否为空树（空树 or 非空树）</span></span><br><span class="line">    <span class="comment">//为空树</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把新结点做为BST树的根结点</span></span><br><span class="line">        Root = NewNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//为非空树,2种情况（键值 等于/不等于 根结点）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(Proot)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//新结点的键值和当前新的根结点的键值比较,相等 直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(NewNode-&gt;Keyval == Proot-&gt;Keyval)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Can Not Insert,......\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//新结点的键值和当前新的根结点的键值比较,不相等 继续分析</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//新结点的键值和当前新的根结点的键值比较,小于 把根结点的左子树作为新的根</span></span><br><span class="line">                <span class="keyword">if</span>(NewNode-&gt;Keyval &lt; Proot-&gt;Keyval)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Proot-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Proot-&gt;lchild = NewNode;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Proot = Proot-&gt;lchild;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  <span class="comment">//新结点的键值和当前新的根结点的键值比较,大于 把根结点的右子树作为新的根</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Proot-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Proot-&gt;rchild = NewNode;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Proot = Proot-&gt;rchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前序遍历-根左右-体现递归思想（BSTree-PreOrder）"><a href="#前序遍历-根左右-体现递归思想（BSTree-PreOrder）" class="headerlink" title="前序遍历 根左右 体现递归思想（BSTree_PreOrder）"></a>前序遍历 根左右 体现递归思想（BSTree_PreOrder）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_PreOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  \n&quot;</span>,Root-&gt;Keyval);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在输出根节点的左子树</span></span><br><span class="line">    BSTree_PreOrder(Root-&gt;lchild);</span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_PreOrder(Root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历-左根右-体现递归思想（BSTree-InOrder）"><a href="#中序遍历-左根右-体现递归思想（BSTree-InOrder）" class="headerlink" title="中序遍历 左根右 体现递归思想（BSTree_InOrder）"></a>中序遍历 左根右 体现递归思想（BSTree_InOrder）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_InOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先输出根节点的左子树</span></span><br><span class="line">    BSTree_InOrder(Root-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  \n&quot;</span>,Root-&gt;Keyval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_InOrder(Root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历-左右根-体现递归思想（BSTree-PostOrder）"><a href="#后序遍历-左右根-体现递归思想（BSTree-PostOrder）" class="headerlink" title="后序遍历 左右根 体现递归思想（BSTree_PostOrder）"></a>后序遍历 左右根 体现递归思想（BSTree_PostOrder）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_PostOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先输出根节点的左子树</span></span><br><span class="line">    BSTree_PostOrder(Root-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_PostOrder(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  \n&quot;</span>,Root-&gt;Keyval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附加1：计算所有节点的数量-可采用递归（BSTree-CountNode）"><a href="#附加1：计算所有节点的数量-可采用递归（BSTree-CountNode）" class="headerlink" title="附加1：计算所有节点的数量 可采用递归（BSTree_CountNode）"></a>附加1：计算所有节点的数量 可采用递归（BSTree_CountNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BSTree_CountNode</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的节点数</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设采用后序遍历计算节点数量</span></span><br><span class="line">    n1 = BSTree_CountNode(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_CountNode(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n1 + n2 +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附加2：计算所有叶子节点的数量-可采用递归（BSTree-CountLeafNode）"><a href="#附加2：计算所有叶子节点的数量-可采用递归（BSTree-CountLeafNode）" class="headerlink" title="附加2：计算所有叶子节点的数量 可采用递归（BSTree_CountLeafNode）"></a>附加2：计算所有叶子节点的数量 可采用递归（BSTree_CountLeafNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BSTree_CountLeafNode</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的节点数</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明只有一个根节点</span></span><br><span class="line">    <span class="keyword">if</span>(Root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; Root-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明有子树</span></span><br><span class="line">    n1 = BSTree_CountLeafNode(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_CountLeafNode(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附加3：计算二叉树的深度-可采用递归（BSTree-GetDepth）"><a href="#附加3：计算二叉树的深度-可采用递归（BSTree-GetDepth）" class="headerlink" title="附加3：计算二叉树的深度 可采用递归（BSTree_GetDepth）"></a>附加3：计算二叉树的深度 可采用递归（BSTree_GetDepth）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BSTree_GetDepth</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的深度</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的深度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    //被下面情况包括</span></span><br><span class="line"><span class="comment">//    //说明只有一个根节点</span></span><br><span class="line"><span class="comment">//    if(Root-&gt;lchild == NULL &amp;&amp; Root-&gt;rchild == NULL)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return 1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明有子树 计算左子树的深度 再 计算右子树的深度 最后 比较找最大再加一</span></span><br><span class="line">    n1 = BSTree_GetDepth(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_GetDepth(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ( (n1&gt;n2)?n1:n2 ) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1 创建一个带根节点的BST树</span></span><br><span class="line">    BSTNode_t *Root = BSTree_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向BST树插入新节点</span></span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">5</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">20</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">7</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">12</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">8</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">3</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">25</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//                     10</span></span><br><span class="line"><span class="comment">//            5                   20</span></span><br><span class="line"><span class="comment">//        3       7           12      25</span></span><br><span class="line"><span class="comment">//                    8                     26</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;前序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_PreOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n中序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_InOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n后序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_PostOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n总节点数：%d&quot;</span>,BSTree_CountNode(Root));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n所有叶子节点数：%d&quot;</span>,BSTree_CountLeafNode(Root));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n二叉树的深度：%d&quot;</span>,BSTree_GetDepth(Root));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">前序遍历为:</span><br><span class="line"><span class="number">10</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">20</span>  <span class="number">12</span>  <span class="number">25</span>  <span class="number">26</span></span><br><span class="line">中序遍历为:</span><br><span class="line"><span class="number">3</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">10</span>  <span class="number">12</span>  <span class="number">20</span>  <span class="number">25</span>  <span class="number">26</span></span><br><span class="line">后序遍历为:</span><br><span class="line"><span class="number">3</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">5</span>  <span class="number">12</span>  <span class="number">26</span>  <span class="number">25</span>  <span class="number">20</span>  <span class="number">10</span></span><br><span class="line">总节点数：<span class="number">9</span></span><br><span class="line">所有叶子节点数：<span class="number">4</span></span><br><span class="line">二叉树的深度：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设计BST二叉查找树，方便对二叉树进行节点的增删，采用双向不循环链表实现，每个节点</span></span><br><span class="line"><span class="comment">都需要2个指针，分别指向该节点的左子树（lchild）和右子树（rchild）</span></span><br><span class="line"><span class="comment">附加1：计算所有节点的数量</span></span><br><span class="line"><span class="comment">附加2: 计算所以叶子节点的数量（度为0）</span></span><br><span class="line"><span class="comment">附加3: 计算二叉树的深度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名 节点有效键值</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造BST树的节点 BST树中所以节点的数据类型应该是相同的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> &#123;</span></span><br><span class="line">    dataType_t Keyval;                 <span class="comment">//BST树的键值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> *<span class="title">lchild</span>;</span>      <span class="comment">//BST树的左子树的指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> *<span class="title">rchild</span>;</span>      <span class="comment">//BST树的右子树的指针域</span></span><br><span class="line">&#125; BSTNode_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建一个带根节点的BST树，对BST树的根节点进行初始化</span></span><br><span class="line">BSTNode_t* <span class="title function_">BSTree_Create</span><span class="params">(dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个根节点并给根节点申请内存</span></span><br><span class="line">    BSTNode_t *Root = (BSTNode_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BSTNode_t));</span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Root is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对根节点进行初始化</span></span><br><span class="line">    Root-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    Root-&gt;Keyval = Keyval;</span><br><span class="line">    Root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头节点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 创建新的节点，并对新节点进行初始化（数据域 指针域）</span></span><br><span class="line">BSTNode_t *<span class="title function_">BSTree_NewNode</span><span class="params">(dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新节点并给新节点申请内存</span></span><br><span class="line">    BSTNode_t *NewNode = (BSTNode_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(BSTNode_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新节点进行初始化（数据域 指针域2个）</span></span><br><span class="line">    NewNode-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    NewNode-&gt;Keyval = Keyval;</span><br><span class="line">    NewNode-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新节点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//3 向BST树中加入节点  根节点的左子树键值比根节点的键值小，根节点的右子树键值比根节点的键值大 体现递归思想</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_InsertNode</span><span class="params">(BSTNode_t *Root,dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.0 避免根节点地址丢失，对根节点地址进行备份</span></span><br><span class="line">    BSTNode_t *Proot = Root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.1 创建新节点并对新节点进行初始化</span></span><br><span class="line">    BSTNode_t *NewNode = BSTree_NewNode(Keyval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 此时分析当前BST树是否为空树（空树 or 非空树）</span></span><br><span class="line">    <span class="comment">//为空树</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把新节点做为BST树的根节点</span></span><br><span class="line">        Root = NewNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//为非空树,2种情况（键值 等于/不等于 根节点）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(Proot)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//新节点的键值和当前新的根节点的键值比较,相等 直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(NewNode-&gt;Keyval == Proot-&gt;Keyval)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Can Not Insert,......\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//新节点的键值和当前新的根节点的键值比较,不相等 继续分析</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//新节点的键值和当前新的根节点的键值比较,小于 把根节点的左子树作为新的根</span></span><br><span class="line">                <span class="keyword">if</span>(NewNode-&gt;Keyval &lt; Proot-&gt;Keyval)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Proot-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Proot-&gt;lchild = NewNode;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Proot = Proot-&gt;lchild;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  <span class="comment">//新节点的键值和当前新的根节点的键值比较,大于 把根节点的右子树作为新的根</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Proot-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Proot-&gt;rchild = NewNode;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Proot = Proot-&gt;rchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 前序遍历 根左右 体现递归思想</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_PreOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,Root-&gt;Keyval);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在输出根节点的左子树</span></span><br><span class="line">    BSTree_PreOrder(Root-&gt;lchild);</span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_PreOrder(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 中序遍历 左根右 体现递归思想</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_InOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先输出根节点的左子树</span></span><br><span class="line">    BSTree_InOrder(Root-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,Root-&gt;Keyval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_InOrder(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 后序遍历 左右根 体现递归思想</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_PostOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先输出根节点的左子树</span></span><br><span class="line">    BSTree_PostOrder(Root-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_PostOrder(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,Root-&gt;Keyval);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 附加1：计算所有节点的数量 可采用递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BSTree_CountNode</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的节点数</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设采用后序遍历计算节点数量</span></span><br><span class="line">    n1 = BSTree_CountNode(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_CountNode(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n1 + n2 +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 附加2：计算所有叶子节点的数量 可采用递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BSTree_CountLeafNode</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的节点数</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明只有一个根节点</span></span><br><span class="line">    <span class="keyword">if</span>(Root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; Root-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明有子树</span></span><br><span class="line">    n1 = BSTree_CountLeafNode(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_CountLeafNode(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 附加3：计算二叉树的深度 可采用递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BSTree_GetDepth</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的深度</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的深度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    //被下面情况包括</span></span><br><span class="line"><span class="comment">//    //说明只有一个根节点</span></span><br><span class="line"><span class="comment">//    if(Root-&gt;lchild == NULL &amp;&amp; Root-&gt;rchild == NULL)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return 1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明有子树 计算左子树的深度 再 计算右子树的深度 最后 比较找最大再加一</span></span><br><span class="line">    n1 = BSTree_GetDepth(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_GetDepth(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ( (n1&gt;n2)?n1:n2 ) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1 创建一个带根节点的BST树</span></span><br><span class="line">    BSTNode_t *Root = BSTree_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向BST树插入新节点</span></span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">5</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">20</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">7</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">12</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">8</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">3</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">25</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">26</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//                     10</span></span><br><span class="line"><span class="comment">//            5                   20</span></span><br><span class="line"><span class="comment">//        3       7           12      25</span></span><br><span class="line"><span class="comment">//                    8                     26</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;前序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_PreOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n中序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_InOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n后序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_PostOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n总节点数：%d&quot;</span>,BSTree_CountNode(Root));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n所有叶子节点数：%d&quot;</span>,BSTree_CountLeafNode(Root));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n二叉树的深度：%d&quot;</span>,BSTree_GetDepth(Root));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 七 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构六（顺序栈sequenceStack）</title>
      <link href="/2025/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/"/>
      <url>/2025/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个顺序栈实现对顺序栈内元素的<br> ——入栈<br> ——出栈<br> ——遍历顺序栈</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/%E9%A1%BA%E5%BA%8F%E6%A0%88.jpg" alt="顺序栈" title="顺序栈"></p><p>More info: <a href="https://github.com/gybpersist/sequenceStack">sequenceStack</a></p><h2 id="构造顺序栈（sequenceStack）"><a href="#构造顺序栈（sequenceStack）" class="headerlink" title="构造顺序栈（sequenceStack）"></a>构造顺序栈（sequenceStack）</h2><h3 id="构造顺序栈记录参数-顺序栈的栈底地址-顺序栈的容量-顺序栈的栈顶元素的下标"><a href="#构造顺序栈记录参数-顺序栈的栈底地址-顺序栈的容量-顺序栈的栈顶元素的下标" class="headerlink" title="构造顺序栈记录参数(顺序栈的栈底地址 顺序栈的容量 顺序栈的栈顶元素的下标)"></a>构造顺序栈记录参数(顺序栈的栈底地址 顺序栈的容量 顺序栈的栈顶元素的下标)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sequenceStack</span> &#123;</span></span><br><span class="line">    dataType_t *Bottom;       <span class="comment">//顺序栈的栈底地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;      <span class="comment">//顺序栈的容量</span></span><br><span class="line">    <span class="type">int</span> Top;               <span class="comment">//顺序栈的栈顶元素的下标</span></span><br><span class="line">&#125; sqStack_t;</span><br></pre></td></tr></table></figure><h2 id="创建顺序栈并对顺序栈进行初始化（sqStack-Create）"><a href="#创建顺序栈并对顺序栈进行初始化（sqStack-Create）" class="headerlink" title="创建顺序栈并对顺序栈进行初始化（sqStack_Create）"></a>创建顺序栈并对顺序栈进行初始化（sqStack_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sqStack_t *<span class="title function_">sqStack_Create</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 利用calloc为顺序栈的管理结构体申请堆内存</span></span><br><span class="line">    sqStack_t *manager = (sqStack_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (manager));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for manager is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 为所有元素申请堆内存 calloc,并完成错误处理</span></span><br><span class="line">    manager-&gt;Bottom = (dataType_t*)<span class="built_in">calloc</span>(size,<span class="keyword">sizeof</span>(dataType_t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager-&gt;Bottom)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for element is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(manager);  <span class="comment">//释放内存</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 对管理顺序栈的结构体进行初始化（元素容量 最后元素下标）</span></span><br><span class="line">    manager-&gt;size = size; <span class="comment">//对顺序栈的容量进行初始化</span></span><br><span class="line">    manager-&gt;Top = <span class="number">-1</span>;   <span class="comment">//由于顺序栈为空，则最后元素下标初值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序栈是否以满（sqStack-IsFull）"><a href="#判断顺序栈是否以满（sqStack-IsFull）" class="headerlink" title="判断顺序栈是否以满（sqStack_IsFull）"></a>判断顺序栈是否以满（sqStack_IsFull）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断顺序栈是否以满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_IsFull</span><span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;Top+<span class="number">1</span> == manager-&gt;size) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//        if(manager-&gt;Top+1 == manager-&gt;size)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return ture;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return false;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入栈-sqStack-Push"><a href="#入栈-sqStack-Push" class="headerlink" title="入栈(sqStack_Push)"></a>入栈(sqStack_Push)</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/%E5%85%A5%E6%A0%88.png" alt="入栈" title="入栈"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_Push</span> <span class="params">(sqStack_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 判断顺序栈是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqStack_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceStack is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 若顺序栈有空闲空间，则把新元素添加到顺序栈尾部</span></span><br><span class="line"><span class="comment">/*    manager-&gt;Top++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Bottom + manager-&gt;Top) = data;   */</span></span><br><span class="line">    manager-&gt;Bottom[++manager-&gt;Top] = data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序栈是否为空（sqStack-IsEmpty）"><a href="#判断顺序栈是否为空（sqStack-IsEmpty）" class="headerlink" title="判断顺序栈是否为空（sqStack_IsEmpty）"></a>判断顺序栈是否为空（sqStack_IsEmpty）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_IsEmpty</span><span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;Top == <span class="number">-1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出栈（sqStack-Pop）"><a href="#出栈（sqStack-Pop）" class="headerlink" title="出栈（sqStack_Pop）"></a>出栈（sqStack_Pop）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/%E5%87%BA%E6%A0%88.png" alt="出栈" title="出栈"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dataType_t <span class="title function_">sqStack_Pop</span> <span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    dataType_t temp=<span class="number">-1</span>;     <span class="comment">//记录需要出栈的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.1 判断顺序栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(sqStack_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SequenceStack is Empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 由于删掉一个元素，则顺序栈有效元素下标减一 后--（先赋值后--）</span></span><br><span class="line">    temp = manager-&gt;Bottom[manager-&gt;Top--];</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return manager-&gt;Bottom[manager-&gt;Top--];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历顺序栈（sqStack-print）"><a href="#遍历顺序栈（sqStack-print）" class="headerlink" title="遍历顺序栈（sqStack_print）"></a>遍历顺序栈（sqStack_print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5 遍历顺序栈中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqStack_print</span> <span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=manager-&gt;Top;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element[%d]=%d\n&quot;</span>,i,manager-&gt;Bottom[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 创建顺序栈</span></span><br><span class="line">    sqStack_t *manager = sqStack_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向顺序栈  入栈</span></span><br><span class="line">    sqStack_Push (manager,<span class="number">5</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">2</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">1</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">4</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">6</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 遍历顺序栈</span></span><br><span class="line">    sqStack_print (manager);     <span class="comment">//5 2 1 4 6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6 出栈</span></span><br><span class="line">    dataType_t temp1,temp2,temp3,temp4;</span><br><span class="line">    </span><br><span class="line">    temp1 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp1);</span><br><span class="line"></span><br><span class="line">    temp2 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp2);</span><br><span class="line"></span><br><span class="line">    temp3 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp3);</span><br><span class="line"></span><br><span class="line">    temp4 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d\n&quot;</span>,temp4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7 遍历顺序栈</span></span><br><span class="line">    sqStack_print (manager);     <span class="comment">//8 8 4 8 2 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Element[<span class="number">0</span>]=<span class="number">5</span></span><br><span class="line">Element[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line">Element[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">Element[<span class="number">3</span>]=<span class="number">4</span></span><br><span class="line">Element[<span class="number">4</span>]=<span class="number">6</span></span><br><span class="line">Element[<span class="number">5</span>]=<span class="number">8</span></span><br><span class="line"></span><br><span class="line"> 出栈：<span class="number">8</span>  出栈：<span class="number">6</span>  出栈：<span class="number">4</span>  出栈：<span class="number">1</span></span><br><span class="line">Element[<span class="number">0</span>]=<span class="number">5</span></span><br><span class="line">Element[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造顺序栈记录参数(顺序栈的栈底地址 顺序栈的容量 顺序栈的栈顶元素的下标)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sequenceStack</span> &#123;</span></span><br><span class="line">    dataType_t *Bottom;       <span class="comment">//顺序栈的栈底地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;      <span class="comment">//顺序栈的容量</span></span><br><span class="line">    <span class="type">int</span> Top;               <span class="comment">//顺序栈的栈顶元素的下标</span></span><br><span class="line">&#125; sqStack_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建顺序栈并对顺序栈进行初始化</span></span><br><span class="line">sqStack_t *<span class="title function_">sqStack_Create</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 利用calloc为顺序栈的管理结构体申请堆内存</span></span><br><span class="line">    sqStack_t *manager = (sqStack_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (manager));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for manager is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 为所有元素申请堆内存 calloc,并完成错误处理</span></span><br><span class="line">    manager-&gt;Bottom = (dataType_t*)<span class="built_in">calloc</span>(size,<span class="keyword">sizeof</span>(dataType_t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager-&gt;Bottom)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for element is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(manager);  <span class="comment">//释放内存</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 对管理顺序栈的结构体进行初始化（元素容量 最后元素下标）</span></span><br><span class="line">    manager-&gt;size = size; <span class="comment">//对顺序栈的容量进行初始化</span></span><br><span class="line">    manager-&gt;Top = <span class="number">-1</span>;   <span class="comment">//由于顺序栈为空，则最后元素下标初值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//判断顺序栈是否以满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_IsFull</span><span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;Top+<span class="number">1</span> == manager-&gt;size) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//        if(manager-&gt;Top+1 == manager-&gt;size)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return ture;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return false;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 顺序栈   入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_Push</span> <span class="params">(sqStack_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 判断顺序栈是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqStack_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceStack is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 若顺序栈有空闲空间，则把新元素添加到顺序栈尾部</span></span><br><span class="line"><span class="comment">/*    manager-&gt;Bottom++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Bottom + manager-&gt;Top) = data;   */</span></span><br><span class="line">    manager-&gt;Bottom[++manager-&gt;Top] = data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//判断顺序栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_IsEmpty</span><span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;Top == <span class="number">-1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//4 顺序栈  出栈</span></span><br><span class="line">dataType_t <span class="title function_">sqStack_Pop</span> <span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    dataType_t temp=<span class="number">-1</span>;     <span class="comment">//记录需要出栈的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.1 判断顺序栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(sqStack_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SequenceStack is Empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 由于删掉一个元素，则顺序栈有效元素下标减一 后--（先赋值后--）</span></span><br><span class="line">    temp = manager-&gt;Bottom[manager-&gt;Top--];</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return manager-&gt;Bottom[manager-&gt;Top--];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//5 遍历顺序栈中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqStack_print</span> <span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=manager-&gt;Top;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element[%d]=%d\n&quot;</span>,i,manager-&gt;Bottom[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 创建顺序栈</span></span><br><span class="line">    sqStack_t *manager = sqStack_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向顺序栈  入栈</span></span><br><span class="line">    sqStack_Push (manager,<span class="number">5</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">2</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">1</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">4</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">6</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 遍历顺序栈</span></span><br><span class="line">    sqStack_print (manager);     <span class="comment">//5 2 1 4 6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6 出栈</span></span><br><span class="line">    dataType_t temp1,temp2,temp3,temp4;</span><br><span class="line">    </span><br><span class="line">    temp1 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp1);</span><br><span class="line"></span><br><span class="line">    temp2 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp2);</span><br><span class="line"></span><br><span class="line">    temp3 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp3);</span><br><span class="line"></span><br><span class="line">    temp4 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d\n&quot;</span>,temp4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7 遍历顺序栈</span></span><br><span class="line">    sqStack_print (manager);     <span class="comment">//8 8 4 8 2 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 六 顺序栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 顺序栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构五（双向循环链表DoubleCirLList）</title>
      <link href="/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCircularLinkeList%EF%BC%89/"/>
      <url>/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCircularLinkeList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个双向循环链表实现对双向循环链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历双向循环链表</p><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="双向循环链表" title="双向循环链表"></p><p>More info: <a href="https://github.com/gybpersist/DoubleCirLList">DoubleCirLList</a></p><h2 id="构造双向循环链表（DoubleCirLList）"><a href="#构造双向循环链表（DoubleCirLList）" class="headerlink" title="构造双向循环链表（DoubleCirLList）"></a>构造双向循环链表（DoubleCirLList）</h2><h3 id="构造双向循环链表的结点-双向循环链表中所有结点的数据类型应该是相同的"><a href="#构造双向循环链表的结点-双向循环链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造双向循环链表的结点 双向循环链表中所有结点的数据类型应该是相同的"></a>构造双向循环链表的结点 双向循环链表中所有结点的数据类型应该是相同的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">// 双向循环链表的数据域，用于存储具体的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> *<span class="title">prev</span>;</span>   <span class="comment">// 双向循环链表的前驱指针域，指向前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> *<span class="title">next</span>;</span>   <span class="comment">// 双向循环链表的后继指针域，指向后一个节点</span></span><br><span class="line">&#125; DoubleLList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（DoubleCirLList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（DoubleCirLList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（DoubleCirLList_Create）"></a>创建一个空链表，空链表应该有一个头结点（DoubleCirLList_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t* <span class="title function_">DoubleCirLList_Create</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个头结点并给头结点申请内存，使用 calloc 函数将内存初始化为 0</span></span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span> (Head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若内存分配失败，使用 perror 输出错误信息并退出程序</span></span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对头结点进行初始化，体现循环，将头结点的 prev 和 next 指针都指向自己</span></span><br><span class="line">    Head-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把头结点的地址返回，方便后续操作</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleCirLList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleCirLList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleCirLList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleCirLList_NewNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t *<span class="title function_">DoubleCirLList_NewNode</span><span class="params">(dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新结点并给新结点申请内存，使用 calloc 函数将内存初始化为 0</span></span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若内存分配失败，使用 perror 输出错误信息并返回 NULL</span></span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对新结点进行初始化（数据域 指针域2个），体现循环，将新结点的 prev 和 next 指针都指向自己</span></span><br><span class="line">    NewNode-&gt;prev = NewNode;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把新结点的地址返回，方便后续操作</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入新节点到指定节点之后（insertAfter）"><a href="#插入新节点到指定节点之后（insertAfter）" class="headerlink" title="插入新节点到指定节点之后（insertAfter）"></a>插入新节点到指定节点之后（insertAfter）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertAfter</span><span class="params">(DoubleLList_t *node, DoubleLList_t *newNode)</span> &#123;</span><br><span class="line">    <span class="comment">// 将新节点的 next 指针指向指定节点的下一个节点</span></span><br><span class="line">    newNode-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="comment">// 将新节点的 prev 指针指向指定节点</span></span><br><span class="line">    newNode-&gt;prev = node;</span><br><span class="line">    <span class="comment">// 将指定节点的下一个节点的 prev 指针指向新节点</span></span><br><span class="line">    node-&gt;next-&gt;prev = newNode;</span><br><span class="line">    <span class="comment">// 将指定节点的 next 指针指向新节点</span></span><br><span class="line">    node-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（DoubleCirLList-HeadInsert）"><a href="#头插（DoubleCirLList-HeadInsert）" class="headerlink" title="头插（DoubleCirLList_HeadInsert）"></a>头插（DoubleCirLList_HeadInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_HeadInsert</span><span class="params">(DoubleLList_t *Head, dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">//3.1建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        Head-&gt;prev = NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下四步操作将新节点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（DoubleCirLList-TailInsert）"><a href="#尾插（DoubleCirLList-TailInsert）" class="headerlink" title="尾插（DoubleCirLList_TailInsert）"></a>尾插（DoubleCirLList_TailInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_TailInsert</span><span class="params">(DoubleLList_t *Head, dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">// 将新节点的 prev 指针指向原尾节点</span></span><br><span class="line">    NewNode-&gt;prev = Head-&gt;prev;</span><br><span class="line">    <span class="comment">// 将原尾节点的 next 指针指向新节点</span></span><br><span class="line">    Head-&gt;prev-&gt;next = NewNode;</span><br><span class="line">    <span class="comment">// 将新节点的 next 指针指向头结点</span></span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    <span class="comment">// 将头结点的 prev 指针指向新节点</span></span><br><span class="line">    Head-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（DoubleCirLList-DestInsert）"><a href="#指定插入（DoubleCirLList-DestInsert）" class="headerlink" title="指定插入（DoubleCirLList_DestInsert）"></a>指定插入（DoubleCirLList_DestInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_DestInsert</span><span class="params">(DoubleLList_t *Head, dataType_t destval, dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">// 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head &amp;&amp; Phead-&gt;data != destval) &#123;</span><br><span class="line">        <span class="comment">// 若未找到目标节点且未遍历完链表，将指针移动到下一个节点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Phead == Head) &#123;</span><br><span class="line">        <span class="comment">// 未找到目标节点，释放新节点的内存并返回 false</span></span><br><span class="line">        <span class="built_in">free</span>(NewNode);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下四步操作将新节点插入到目标节点之后</span></span><br><span class="line">    NewNode-&gt;next = Phead-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Phead-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（DoubleCirLList-Print）"><a href="#遍历链表（DoubleCirLList-Print）" class="headerlink" title="遍历链表（DoubleCirLList_Print）"></a>遍历链表（DoubleCirLList_Print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_Print</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="comment">// 若链表为空，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">// 输出当前节点的数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>, i, Phead-&gt;data);</span><br><span class="line">        <span class="comment">// 将指针移动到下一个节点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除指定节点（deleteNode）"><a href="#删除指定节点（deleteNode）" class="headerlink" title="删除指定节点（deleteNode）"></a>删除指定节点（deleteNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(DoubleLList_t *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 将指定节点的前一个节点的 next 指针指向指定节点的下一个节点</span></span><br><span class="line">    node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="comment">// 将指定节点的下一个节点的 prev 指针指向指定节点的前一个节点</span></span><br><span class="line">    node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="comment">// 将指定节点的 next 和 prev 指针置为 NULL</span></span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 释放指定节点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除首结点（DoubleCirLList-HeadDel）"><a href="#头删-删除首结点（DoubleCirLList-HeadDel）" class="headerlink" title="头删 删除首结点（DoubleCirLList_HeadDel）"></a>头删 删除首结点（DoubleCirLList_HeadDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_HeadDel</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断链表是否为空，如果为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.2 对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.3 链表非空 删除首结点</span></span><br><span class="line">    <span class="comment">// 将首结点之后的结点的 prev 指针连接到头结点</span></span><br><span class="line">    Head-&gt;next-&gt;next-&gt;prev = Head;</span><br><span class="line">    <span class="comment">// 将头结点的 next 指针指向原先首结点之后的结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.4 释放首结点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    deleteNode(Head-&gt;next);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（DoubleCirLList-TailDel）"><a href="#尾删-删除尾结点（DoubleCirLList-TailDel）" class="headerlink" title="尾删 删除尾结点（DoubleCirLList_TailDel）"></a>尾删 删除尾结点（DoubleCirLList_TailDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_TailDel</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 8.1 判断判断链表是否为空，如果为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.2 记录当前尾结点的地址</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="comment">// 将头结点的 prev 指针连接到尾结点的前一个结点</span></span><br><span class="line">    Head-&gt;next-&gt;prev = Phead-&gt;prev;</span><br><span class="line">    <span class="comment">// 将尾结点的前一个结点的 next 指针连接到头结点</span></span><br><span class="line">    Phead-&gt;prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.4 释放尾结点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    deleteNode(Head-&gt;prev);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个双向循环链表</span></span><br><span class="line">    DoubleLList_t *Head = DoubleCirLList_Create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行头插操作</span></span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">5</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">8</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">1</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">6</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行尾插操作</span></span><br><span class="line">    DoubleCirLList_TailInsert(Head, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在值为 1 的节点后插入新节点</span></span><br><span class="line">    DoubleCirLList_DestInsert(Head, <span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行头删操作</span></span><br><span class="line">    DoubleCirLList_HeadDel(Head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行尾删操作</span></span><br><span class="line">    DoubleCirLList_TailDel(Head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名，将 int 类型重命名为 dataType_t，方便后续修改数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 构造双向循环链表的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">// 双向循环链表的数据域，用于存储具体的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> *<span class="title">prev</span>;</span>   <span class="comment">// 双向循环链表的前驱指针域，指向前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> *<span class="title">next</span>;</span>   <span class="comment">// 双向循环链表的后继指针域，指向后一个节点</span></span><br><span class="line">&#125; DoubleLList_t;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 1 创建一个空链表，空链表应该有一个头结点</span></span><br><span class="line">DoubleLList_t* <span class="title function_">DoubleCirLList_Create</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个头结点并给头结点申请内存，使用 calloc 函数将内存初始化为 0</span></span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span> (Head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若内存分配失败，使用 perror 输出错误信息并退出程序</span></span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对头结点进行初始化，体现循环，将头结点的 prev 和 next 指针都指向自己</span></span><br><span class="line">    Head-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把头结点的地址返回，方便后续操作</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">DoubleLList_t *<span class="title function_">DoubleCirLList_NewNode</span><span class="params">(dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新结点并给新结点申请内存，使用 calloc 函数将内存初始化为 0</span></span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若内存分配失败，使用 perror 输出错误信息并返回 NULL</span></span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对新结点进行初始化（数据域 指针域2个），体现循环，将新结点的 prev 和 next 指针都指向自己</span></span><br><span class="line">    NewNode-&gt;prev = NewNode;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把新结点的地址返回，方便后续操作</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 插入新节点到指定节点之后</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertAfter</span><span class="params">(DoubleLList_t *node, DoubleLList_t *newNode)</span> &#123;</span><br><span class="line">    <span class="comment">// 将新节点的 next 指针指向指定节点的下一个节点</span></span><br><span class="line">    newNode-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="comment">// 将新节点的 prev 指针指向指定节点</span></span><br><span class="line">    newNode-&gt;prev = node;</span><br><span class="line">    <span class="comment">// 将指定节点的下一个节点的 prev 指针指向新节点</span></span><br><span class="line">    node-&gt;next-&gt;prev = newNode;</span><br><span class="line">    <span class="comment">// 将指定节点的 next 指针指向新节点</span></span><br><span class="line">    node-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 3 在链表中 头插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_HeadInsert</span><span class="params">(DoubleLList_t *Head, dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">//3.1建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        Head-&gt;prev = NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下四步操作将新节点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 4 在链表中 尾部插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_TailInsert</span><span class="params">(DoubleLList_t *Head, dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">// 将新节点的 prev 指针指向原尾节点</span></span><br><span class="line">    NewNode-&gt;prev = Head-&gt;prev;</span><br><span class="line">    <span class="comment">// 将原尾节点的 next 指针指向新节点</span></span><br><span class="line">    Head-&gt;prev-&gt;next = NewNode;</span><br><span class="line">    <span class="comment">// 将新节点的 next 指针指向头结点</span></span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    <span class="comment">// 将头结点的 prev 指针指向新节点</span></span><br><span class="line">    Head-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 5 在链表中 指定插入</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_DestInsert</span><span class="params">(DoubleLList_t *Head, dataType_t destval, dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">// 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head &amp;&amp; Phead-&gt;data != destval) &#123;</span><br><span class="line">        <span class="comment">// 若未找到目标节点且未遍历完链表，将指针移动到下一个节点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Phead == Head) &#123;</span><br><span class="line">        <span class="comment">// 未找到目标节点，释放新节点的内存并返回 false</span></span><br><span class="line">        <span class="built_in">free</span>(NewNode);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下四步操作将新节点插入到目标节点之后</span></span><br><span class="line">    NewNode-&gt;next = Phead-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Phead-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 6 遍历链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_Print</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="comment">// 若链表为空，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">// 输出当前节点的数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>, i, Phead-&gt;data);</span><br><span class="line">        <span class="comment">// 将指针移动到下一个节点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 删除指定节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(DoubleLList_t *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 将指定节点的前一个节点的 next 指针指向指定节点的下一个节点</span></span><br><span class="line">    node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="comment">// 将指定节点的下一个节点的 prev 指针指向指定节点的前一个节点</span></span><br><span class="line">    node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="comment">// 将指定节点的 next 和 prev 指针置为 NULL</span></span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 释放指定节点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 7 头删 删除首结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_HeadDel</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断链表是否为空，如果为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.2 对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.3 链表非空 删除首结点</span></span><br><span class="line">    <span class="comment">// 将首结点之后的结点的 prev 指针连接到头结点</span></span><br><span class="line">    Head-&gt;next-&gt;next-&gt;prev = Head;</span><br><span class="line">    <span class="comment">// 将头结点的 next 指针指向原先首结点之后的结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.4 释放首结点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    deleteNode(Head-&gt;next);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 8 尾删 删除尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_TailDel</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 8.1 判断判断链表是否为空，如果为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.2 记录当前尾结点的地址</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="comment">// 将头结点的 prev 指针连接到尾结点的前一个结点</span></span><br><span class="line">    Head-&gt;next-&gt;prev = Phead-&gt;prev;</span><br><span class="line">    <span class="comment">// 将尾结点的前一个结点的 next 指针连接到头结点</span></span><br><span class="line">    Phead-&gt;prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.4 释放尾结点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    deleteNode(Head-&gt;prev);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个双向循环链表</span></span><br><span class="line">    DoubleLList_t *Head = DoubleCirLList_Create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行头插操作</span></span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">5</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">8</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">1</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">6</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行尾插操作</span></span><br><span class="line">    DoubleCirLList_TailInsert(Head, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在值为 1 的节点后插入新节点</span></span><br><span class="line">    DoubleCirLList_DestInsert(Head, <span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行头删操作</span></span><br><span class="line">    DoubleCirLList_HeadDel(Head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行尾删操作</span></span><br><span class="line">    DoubleCirLList_TailDel(Head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 五 双向循环链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 双向循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构四（单向循环链表CircularLinkedList）</title>
      <link href="/2025/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/"/>
      <url>/2025/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个单向循环链表实现对单向循环链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历单向循环链表</p><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="单向循环链表" title="单向循环链表"></p><p>More info: <a href="https://github.com/gybpersist/CircularLinkedList">CircularLinkedList</a></p><h2 id="构造单向循环链表（CircularLinkedList）"><a href="#构造单向循环链表（CircularLinkedList）" class="headerlink" title="构造单向循环链表（CircularLinkedList）"></a>构造单向循环链表（CircularLinkedList）</h2><h3 id="构造单向循环链表的结点-单向循环链表中所有结点的数据类型应该是相同的"><a href="#构造单向循环链表的结点-单向循环链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造单向循环链表的结点 单向循环链表中所有结点的数据类型应该是相同的"></a>构造单向循环链表的结点 单向循环链表中所有结点的数据类型应该是相同的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CircularLinkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//单向循环链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CircularLinkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//单向循环链表的指针域</span></span><br><span class="line">&#125; CricLList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（CricLList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（CricLList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（CricLList_Create）"></a>创建一个空链表，空链表应该有一个头结点（CricLList_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CricLList_t* <span class="title function_">CricLList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    CricLList_t *Head = (CricLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (CricLList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化，头结点是不存储有效内容的</span></span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（CricLList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（CricLList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（CricLList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（CricLList_NewNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CricLList_t *<span class="title function_">CricLList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    CricLList_t *NewNode = (CricLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(CricLList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（CricLList-HeadInsert）"><a href="#头插（CricLList-HeadInsert）" class="headerlink" title="头插（CricLList_HeadInsert）"></a>头插（CricLList_HeadInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_HeadInsert</span><span class="params">(CricLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（CricLList-TailInsert）"><a href="#尾插（CricLList-TailInsert）" class="headerlink" title="尾插（CricLList_TailInsert）"></a>尾插（CricLList_TailInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_TailInsert</span><span class="params">(CricLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（CricLList-DestInsert）"><a href="#指定插入（CricLList-DestInsert）" class="headerlink" title="指定插入（CricLList_DestInsert）"></a>指定插入（CricLList_DestInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_DestInsert</span><span class="params">(CricLList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == Head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//代表循环完之后未找到 目标值destval</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（CricLList-Print）"><a href="#遍历链表（CricLList-Print）" class="headerlink" title="遍历链表（CricLList_Print）"></a>遍历链表（CricLList_Print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_Print</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点的地址进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除头结点（CricLList-HeadDel）"><a href="#头删-删除头结点（CricLList-HeadDel）" class="headerlink" title="头删 删除头结点（CricLList_HeadDel）"></a>头删 删除头结点（CricLList_HeadDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_HeadDel</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 对链表的首结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果链表只有一个节点，删除后让头结点指向自身</span></span><br><span class="line">    <span class="keyword">if</span> (Phead-&gt;next == Head) &#123;</span><br><span class="line">        Head-&gt;next = Head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（CricLList-TailDel）"><a href="#尾删-删除尾结点（CricLList-TailDel）" class="headerlink" title="尾删 删除尾结点（CricLList_TailDel）"></a>尾删 删除尾结点（CricLList_TailDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_TailDel</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 记录当前结点的地址</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    CricLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    CricLList_t *Head = CricLList_Create();            <span class="comment">//创建链表</span></span><br><span class="line"></span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造单向循环链表的结点 单向链循环表中所以结点的数据类型应该是相同的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CircularLinkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//单向链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CircularLinkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//单向链表的指针域</span></span><br><span class="line">&#125; CricLList_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建一个空链表，空链表应该有一个头结点</span></span><br><span class="line">CricLList_t* <span class="title function_">CricLList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    CricLList_t *Head = (CricLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (CricLList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化，头结点是不存储有效内容的,指针域指向自己，体现循环思想</span></span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">CricLList_t *<span class="title function_">CricLList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    CricLList_t *NewNode = (CricLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(CricLList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//3 在链表中 头插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_HeadInsert</span><span class="params">(CricLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//4 在链表中 尾部插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_TailInsert</span><span class="params">(CricLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next = NewNode;</span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//5 在链表中 指定插入</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_DestInsert</span><span class="params">(CricLList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == Head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//代表循环完之后未找到 目标值destval</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//6 遍历链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_Print</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点的地址进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//7 头删 删除首结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_HeadDel</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 对链表的首结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果链表只有一个节点，删除后让头结点指向自身</span></span><br><span class="line">    <span class="keyword">if</span> (Phead-&gt;next == Head) &#123;</span><br><span class="line">        Head-&gt;next = Head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//8 尾删 删除尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_TailDel</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 记录当前结点的地址</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    CricLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    CricLList_t *Head = CricLList_Create();            <span class="comment">//创建链表</span></span><br><span class="line"></span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 四 单向循环链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 单向循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构二（单向链表linkedList）</title>
      <link href="/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/"/>
      <url>/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个单向链表实现对单向链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历单向链表</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="单向链表" title="单向链表"></p><p>More info: <a href="https://github.com/gybpersist/linkedList">linkedList</a></p><h2 id="构造单向链表（linkedList）"><a href="#构造单向链表（linkedList）" class="headerlink" title="构造单向链表（linkedList）"></a>构造单向链表（linkedList）</h2><h3 id="构造单向链表的结点-单向链表中所有结点的数据类型应该是相同的"><a href="#构造单向链表的结点-单向链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造单向链表的结点 单向链表中所有结点的数据类型应该是相同的"></a>构造单向链表的结点 单向链表中所有结点的数据类型应该是相同的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//单向链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//单向链表的指针域</span></span><br><span class="line">&#125; lList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（lList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（lList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（lList_Create）"></a>创建一个空链表，空链表应该有一个头结点（lList_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lList_t* <span class="title function_">lList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    lList_t *Head = (lList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (lList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化，头结点是不存储有效内容的</span></span><br><span class="line">    Head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（lList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（lList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（lList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（lList_NewNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lList_t *<span class="title function_">lList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    lList_t *NewNode = (lList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(lList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（lList-HeadInsert）"><a href="#头插（lList-HeadInsert）" class="headerlink" title="头插（lList_HeadInsert）"></a>头插（lList_HeadInsert）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lList_HeadInsert</span><span class="params">(lList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（lList-TailInsert）"><a href="#尾插（lList-TailInsert）" class="headerlink" title="尾插（lList_TailInsert）"></a>尾插（lList_TailInsert）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lList_TailInsert</span><span class="params">(lList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（lList-DestInsert）"><a href="#指定插入（lList-DestInsert）" class="headerlink" title="指定插入（lList_DestInsert）"></a>指定插入（lList_DestInsert）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lList_DestInsert</span><span class="params">(lList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != <span class="literal">NULL</span> &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（lList-Print）"><a href="#遍历链表（lList-Print）" class="headerlink" title="遍历链表（lList_Print）"></a>遍历链表（lList_Print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lList_Print</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除首结点（lList-HeadDel）"><a href="#头删-删除首结点（lList-HeadDel）" class="headerlink" title="头删 删除首结点（lList_HeadDel）"></a>头删 删除首结点（lList_HeadDel）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lList_HeadDel</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 对链表的首结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（lList-TailDel）"><a href="#尾删-删除尾结点（lList-TailDel）" class="headerlink" title="尾删 删除尾结点（lList_TailDel）"></a>尾删 删除尾结点（lList_TailDel）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lList_TailDel</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 记录当前结点的地址</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    lList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    lList_t *Head = lList_Create();            <span class="comment">//创建链表</span></span><br><span class="line">    lList_NewNode(<span class="number">5</span>);                    <span class="comment">//创建新结点</span></span><br><span class="line"></span><br><span class="line">    lList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    lList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    lList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    lList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造单向链表的结点 单向链表中所有结点的数据类型应该是相同的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//单向链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//单向链表的指针域</span></span><br><span class="line">&#125; lList_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建一个空链表，空链表应该有一个头结点</span></span><br><span class="line">lList_t* <span class="title function_">lList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    lList_t *Head = (lList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (lList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化，头结点是不存储有效内容的</span></span><br><span class="line">    Head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">lList_t *<span class="title function_">lList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    lList_t *NewNode = (lList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(lList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//3 ccccccccc</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">lList_HeadInsert</span><span class="params">(lList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//4 在链表中 尾部插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">lList_TailInsert</span><span class="params">(lList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//5 在链表中 指定插入</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">lList_DestInsert</span><span class="params">(lList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != <span class="literal">NULL</span> &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//6 遍历链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lList_Print</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//7 头删 删除首结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">lList_HeadDel</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 对链表的首结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//8 尾删 删除尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">lList_TailDel</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 记录当前结点的地址</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    lList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    lList_t *Head = lList_Create();            <span class="comment">//创建链表</span></span><br><span class="line">    lList_NewNode(<span class="number">5</span>);                    <span class="comment">//创建新结点</span></span><br><span class="line"></span><br><span class="line">    lList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    lList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    lList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    lList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 二 单向链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 单向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构一（顺序表sequenceList）</title>
      <link href="/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8sequenceList%EF%BC%89/"/>
      <url>/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8sequenceList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p> --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个顺序表实现对顺序表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历顺序表</p><p><img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8sequenceList%EF%BC%89/%E9%A1%BA%E5%BA%8F%E8%A1%A8.png" alt="顺序表" title="顺序表"></p><p>More info: <a href="https://github.com/gybpersist/sequenceList">sequenceList</a></p><h2 id="构造顺序表（sequenceList）"><a href="#构造顺序表（sequenceList）" class="headerlink" title="构造顺序表（sequenceList）"></a>构造顺序表（sequenceList）</h2><h3 id="构造顺序表记录参数-顺序表的首地址-顺序表的容量-顺序表的有效元素的下标"><a href="#构造顺序表记录参数-顺序表的首地址-顺序表的容量-顺序表的有效元素的下标" class="headerlink" title="构造顺序表记录参数(顺序表的首地址 顺序表的容量 顺序表的有效元素的下标)"></a>构造顺序表记录参数(顺序表的首地址 顺序表的容量 顺序表的有效元素的下标)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sequenceList</span> &#123;</span></span><br><span class="line">    dataType_t *Addr;       <span class="comment">//顺序表的首地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;      <span class="comment">//顺序表的容量</span></span><br><span class="line">    <span class="type">int</span> last;               <span class="comment">//顺序表的有效元素的下标</span></span><br><span class="line">&#125; sqList_t;</span><br></pre></td></tr></table></figure><h2 id="创建顺序表并对顺序表进行初始化（sqList-Create）"><a href="#创建顺序表并对顺序表进行初始化（sqList-Create）" class="headerlink" title="创建顺序表并对顺序表进行初始化（sqList_Create）"></a>创建顺序表并对顺序表进行初始化（sqList_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sqList_t *<span class="title function_">sqList_Create</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 利用calloc为顺序表的管理结构体申请堆内存</span></span><br><span class="line">    sqList_t *manager = (sqList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (manager));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for manager is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 为所有元素申请堆内存 calloc,并完成错误处理</span></span><br><span class="line">    manager-&gt;Addr = (dataType_t*)<span class="built_in">calloc</span>(size,<span class="keyword">sizeof</span>(dataType_t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager-&gt;Addr)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for element is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(manager);  <span class="comment">//释放内存</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 对管理顺序表的结构体进行初始化（元素容量 最后元素下标）</span></span><br><span class="line">    manager-&gt;size = size; <span class="comment">//对顺序表的容量进行初始化</span></span><br><span class="line">    manager-&gt;last = <span class="number">-1</span>;   <span class="comment">//由于顺序表为空，则最后元素下标初值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序表是否以满（sqList-IsFull）"><a href="#判断顺序表是否以满（sqList-IsFull）" class="headerlink" title="判断顺序表是否以满（sqList_IsFull）"></a>判断顺序表是否以满（sqList_IsFull）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断顺序表是否以满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_IsFull</span><span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;last+<span class="number">1</span> == manager-&gt;size) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//        if(manager-&gt;last+1 == manager-&gt;size)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return ture;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return false;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（sqList-endAdd）"><a href="#尾插（sqList-endAdd）" class="headerlink" title="尾插（sqList_endAdd）"></a>尾插（sqList_endAdd）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向顺序表的尾部插入元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_endAdd</span> <span class="params">(sqList_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 判断顺序表是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceList is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 若顺序表有空闲空间，则把新元素添加到顺序表尾部</span></span><br><span class="line"><span class="comment">/*    manager-&gt;last++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span></span><br><span class="line">    manager-&gt;Addr[++manager-&gt;last] = data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（sqList-headAdd）"><a href="#头插（sqList-headAdd）" class="headerlink" title="头插（sqList_headAdd）"></a>头插（sqList_headAdd）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3 向顺序表的头部插入元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_headAdd</span> <span class="params">(sqList_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 判断顺序表是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceList is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 若顺序表有空闲空间，则把新元素添加到顺序表头部 顺序表中所以元素向后移动1个单位</span></span><br><span class="line"><span class="comment">/*    manager-&gt;last++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = manager-&gt;last;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i+<span class="number">1</span>] = manager-&gt;Addr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 把新元素放到顺序表的头部,并且更新管理结构体中的元素下标+1</span></span><br><span class="line">    manager-&gt;Addr[<span class="number">0</span>] = data;</span><br><span class="line">    manager-&gt;last++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序表是否为空（sqList-IsEmpty）"><a href="#判断顺序表是否为空（sqList-IsEmpty）" class="headerlink" title="判断顺序表是否为空（sqList_IsEmpty）"></a>判断顺序表是否为空（sqList_IsEmpty）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断顺序表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_IsEmpty</span><span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;last == <span class="number">-1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定删除（sqList-delAdd）"><a href="#指定删除（sqList-delAdd）" class="headerlink" title="指定删除（sqList_delAdd）"></a>指定删除（sqList_delAdd）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4 向顺序表删除元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_delAdd</span> <span class="params">(sqList_t *manager,dataType_t destVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">-1</span>;     <span class="comment">//记录需要删除的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.1 判断顺序表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SequenceList is Empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 需要查找目标值是否在顺序表中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt;= manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果目标值与顺序表中的值相同</span></span><br><span class="line">        <span class="keyword">if</span>(destVal == manager-&gt;Addr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            temp=i;     <span class="comment">//把目标元素的下标备份到变量temp中</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果顺序表中没有目标值的元素则终止函数</span></span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;destval [%d] is not found\n&quot;</span>,destVal);</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.4 如果顺序表中有目标值的元素，则将该元素的后继元素向前移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = temp; i &lt; manager-&gt;last; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i] = manager-&gt;Addr[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.5 由于删掉一个元素，则顺序表有效元素下标减一</span></span><br><span class="line">    manager-&gt;last--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历顺序表（sqList-print）"><a href="#遍历顺序表（sqList-print）" class="headerlink" title="遍历顺序表（sqList_print）"></a>遍历顺序表（sqList_print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5 遍历顺序表中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqList_print</span> <span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element[%d]=%d\n&quot;</span>,i,manager-&gt;Addr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 创建顺序表</span></span><br><span class="line">    sqList_t *manager = sqList_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向顺序表尾部插入新元素</span></span><br><span class="line">    sqList_endAdd (manager,<span class="number">5</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">2</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">1</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">4</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//5 2 1 4 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4 向顺序表头部插入新元素</span></span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">4</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//8 8 4 8 5 2 1 4 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6 删除顺序表中元素</span></span><br><span class="line">    sqList_delAdd (manager,<span class="number">20</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">5</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">1</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//8 8 4 8 2 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Element[<span class="number">0</span>]=<span class="number">5</span></span><br><span class="line">Element[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line">Element[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">Element[<span class="number">3</span>]=<span class="number">4</span></span><br><span class="line">Element[<span class="number">4</span>]=<span class="number">6</span></span><br><span class="line"></span><br><span class="line">Element[<span class="number">0</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">1</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">2</span>]=<span class="number">4</span></span><br><span class="line">Element[<span class="number">3</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">4</span>]=<span class="number">5</span></span><br><span class="line">Element[<span class="number">5</span>]=<span class="number">2</span></span><br><span class="line">Element[<span class="number">6</span>]=<span class="number">1</span></span><br><span class="line">Element[<span class="number">7</span>]=<span class="number">4</span></span><br><span class="line">Element[<span class="number">8</span>]=<span class="number">6</span></span><br><span class="line"></span><br><span class="line">destval [<span class="number">20</span>] is not found</span><br><span class="line">Element[<span class="number">0</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">1</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">2</span>]=<span class="number">4</span></span><br><span class="line">Element[<span class="number">3</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">4</span>]=<span class="number">2</span></span><br><span class="line">Element[<span class="number">5</span>]=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造顺序表记录参数(顺序表的首地址 顺序表的容量 顺序表的有效元素的下标)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sequenceList</span> &#123;</span></span><br><span class="line">    dataType_t *Addr;       <span class="comment">//顺序表的首地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;      <span class="comment">//顺序表的容量</span></span><br><span class="line">    <span class="type">int</span> last;               <span class="comment">//顺序表的有效元素的下标</span></span><br><span class="line">&#125; sqList_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建顺序表并对顺序表进行初始化</span></span><br><span class="line">sqList_t *<span class="title function_">sqList_Create</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 利用calloc为顺序表的管理结构体申请堆内存</span></span><br><span class="line">    sqList_t *manager = (sqList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (manager));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for manager is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 为所有元素申请堆内存 calloc,并完成错误处理</span></span><br><span class="line">    manager-&gt;Addr = (dataType_t*)<span class="built_in">calloc</span>(size,<span class="keyword">sizeof</span>(dataType_t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager-&gt;Addr)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for element is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(manager);  <span class="comment">//释放内存</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 对管理顺序表的结构体进行初始化（元素容量 最后元素下标）</span></span><br><span class="line">    manager-&gt;size = size; <span class="comment">//对顺序表的容量进行初始化</span></span><br><span class="line">    manager-&gt;last = <span class="number">-1</span>;   <span class="comment">//由于顺序表为空，则最后元素下标初值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//判断顺序表是否以满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_IsFull</span><span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;last+<span class="number">1</span> == manager-&gt;size) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//        if(manager-&gt;last+1 == manager-&gt;size)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return ture;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return false;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 向顺序表的尾部插入元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_endAdd</span> <span class="params">(sqList_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 判断顺序表是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceList is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 若顺序表有空闲空间，则把新元素添加到顺序表尾部</span></span><br><span class="line"><span class="comment">/*    manager-&gt;last++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span></span><br><span class="line">    manager-&gt;Addr[++manager-&gt;last] = data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//3 向顺序表的头部插入元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_headAdd</span> <span class="params">(sqList_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 判断顺序表是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceList is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 若顺序表有空闲空间，则把新元素添加到顺序表头部 顺序表中所以元素向后移动1个单位</span></span><br><span class="line"><span class="comment">/*    manager-&gt;last++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = manager-&gt;last;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i+<span class="number">1</span>] = manager-&gt;Addr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 把新元素放到顺序表的头部,并且更新管理结构体中的元素下标+1</span></span><br><span class="line">    manager-&gt;Addr[<span class="number">0</span>] = data;</span><br><span class="line">    manager-&gt;last++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//判断顺序表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_IsEmpty</span><span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;last == <span class="number">-1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//4 向顺序表删除元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_delAdd</span> <span class="params">(sqList_t *manager,dataType_t destVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">-1</span>;     <span class="comment">//记录需要删除的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.1 判断顺序表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SequenceList is Empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 需要查找目标值是否在顺序表中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt;= manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果目标值与顺序表中的值相同</span></span><br><span class="line">        <span class="keyword">if</span>(destVal == manager-&gt;Addr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            temp=i;     <span class="comment">//把目标元素的下标备份到变量temp中</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果顺序表中没有目标值的元素则终止函数</span></span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;destval [%d] is not found\n&quot;</span>,destVal);</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.4 如果顺序表中有目标值的元素，则将该元素的后继元素向前移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = temp; i &lt; manager-&gt;last; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i] = manager-&gt;Addr[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.5 由于删掉一个元素，则顺序表有效元素下标减一</span></span><br><span class="line">    manager-&gt;last--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//5 遍历顺序表中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqList_print</span> <span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element[%d]=%d\n&quot;</span>,i,manager-&gt;Addr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 创建顺序表</span></span><br><span class="line">    sqList_t *manager = sqList_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向顺序表尾部插入新元素</span></span><br><span class="line">    sqList_endAdd (manager,<span class="number">5</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">2</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">1</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">4</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//5 2 1 4 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4 向顺序表头部插入新元素</span></span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">4</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//8 8 4 8 5 2 1 4 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6 删除顺序表中元素</span></span><br><span class="line">    sqList_delAdd (manager,<span class="number">20</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">5</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">1</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//8 8 4 8 2 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 一 顺序表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构三（双向链表DoubleLinkedList）</title>
      <link href="/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/"/>
      <url>/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个双向链表实现对双向链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历双向链表</p><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表" title="双向链表"></p><p>More info: <a href="https://github.com/gybpersist/DoubleLinkedList">DoubleLinkedList</a></p><h2 id="构造双向链表（DoubleLinkedList）"><a href="#构造双向链表（DoubleLinkedList）" class="headerlink" title="构造双向链表（DoubleLinkedList）"></a>构造双向链表（DoubleLinkedList）</h2><h3 id="构造双向链表的结点-双向链表中所有结点的数据类型应该是相同的"><a href="#构造双向链表的结点-双向链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造双向链表的结点 双向链表中所有结点的数据类型应该是相同的"></a>构造双向链表的结点 双向链表中所有结点的数据类型应该是相同的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//双向链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> *<span class="title">prev</span>;</span>      <span class="comment">//双向链表的后继指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//双向链表的前驱指针域</span></span><br><span class="line">&#125; DoubleLList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（DoubleLList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（DoubleLList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（DoubleLList_Create）"></a>创建一个空链表，空链表应该有一个头结点（DoubleLList_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t* <span class="title function_">DoubleLList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化</span></span><br><span class="line">    Head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    Head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleLList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleLList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleLList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleLList_NewNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t *<span class="title function_">DoubleLList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域2个）</span></span><br><span class="line">    NewNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（DoubleLList-HeadInsert）"><a href="#头插（DoubleLList-HeadInsert）" class="headerlink" title="头插（DoubleLList_HeadInsert）"></a>头插（DoubleLList_HeadInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_HeadInsert</span><span class="params">(DoubleLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line">    NewNode-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（DoubleLList-TailInsert）"><a href="#尾插（DoubleLList-TailInsert）" class="headerlink" title="尾插（DoubleLList_TailInsert）"></a>尾插（DoubleLList_TailInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_TailInsert</span><span class="params">(DoubleLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（DoubleLList-DestInsert）"><a href="#指定插入（DoubleLList-DestInsert）" class="headerlink" title="指定插入（DoubleLList_DestInsert）"></a>指定插入（DoubleLList_DestInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_DestInsert</span><span class="params">(DoubleLList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != <span class="literal">NULL</span> &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（DoubleLList-Print）"><a href="#遍历链表（DoubleLList-Print）" class="headerlink" title="遍历链表（DoubleLList_Print）"></a>遍历链表（DoubleLList_Print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_Print</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点的地址进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除首结点（DoubleLList-HeadDel）"><a href="#头删-删除首结点（DoubleLList-HeadDel）" class="headerlink" title="头删 删除首结点（DoubleLList_HeadDel）"></a>头删 删除首结点（DoubleLList_HeadDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_HeadDel</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Phead-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（DoubleLList-TailDel）"><a href="#尾删-删除尾结点（DoubleLList-TailDel）" class="headerlink" title="尾删 删除尾结点（DoubleLList_TailDel）"></a>尾删 删除尾结点（DoubleLList_TailDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_TailDel</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 记录当前结点的地址</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    DoubleLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DoubleLList_t *Head = DoubleLList_Create();            <span class="comment">//创建链表</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        <span class="comment">//3 6 1 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        <span class="comment">//3 6 1 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造双向链表的结点 双向链表中所以结点的数据类型应该是相同的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//双向链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> *<span class="title">prev</span>;</span>      <span class="comment">//双向链表的后继指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//双向链表的前驱指针域</span></span><br><span class="line">&#125; DoubleLList_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建一个空链表，空链表应该有一个头结点</span></span><br><span class="line">DoubleLList_t* <span class="title function_">DoubleLList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化</span></span><br><span class="line">    Head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    Head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">DoubleLList_t *<span class="title function_">DoubleLList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域2个）</span></span><br><span class="line">    NewNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//3 在链表中 头插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_HeadInsert</span><span class="params">(DoubleLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 新节点是链表最后一个节点，next 指针置为 NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//4 在链表中 尾部插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_TailInsert</span><span class="params">(DoubleLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//5 在链表中 指定插入</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_DestInsert</span><span class="params">(DoubleLList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != <span class="literal">NULL</span> &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//6 遍历链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_Print</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点的地址进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//7 头删 删除首结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_HeadDel</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Phead-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//8 尾删 删除尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_TailDel</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 记录当前结点的地址</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    DoubleLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DoubleLList_t *Head = DoubleLList_Create();            <span class="comment">//创建链表</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        <span class="comment">//3 6 1 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        <span class="comment">//3 6 1 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 三 双向链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 双向链表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
