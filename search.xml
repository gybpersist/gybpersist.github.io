<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构六（顺序栈sequenceStack）</title>
      <link href="/2025/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/"/>
      <url>/2025/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个顺序栈实现对顺序栈内元素的<br> ——入栈<br> ——出栈<br> ——遍历顺序栈</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/%E9%A1%BA%E5%BA%8F%E6%A0%88.jpg" alt="顺序栈" title="顺序栈"></p><p>More info: <a href="https://github.com/gybpersist/sequenceStack">sequenceStack</a></p><h2 id="构造顺序栈（sequenceStack）"><a href="#构造顺序栈（sequenceStack）" class="headerlink" title="构造顺序栈（sequenceStack）"></a>构造顺序栈（sequenceStack）</h2><h3 id="构造顺序栈记录参数-顺序栈的栈底地址-顺序栈的容量-顺序栈的栈顶元素的下标"><a href="#构造顺序栈记录参数-顺序栈的栈底地址-顺序栈的容量-顺序栈的栈顶元素的下标" class="headerlink" title="构造顺序栈记录参数(顺序栈的栈底地址 顺序栈的容量 顺序栈的栈顶元素的下标)"></a>构造顺序栈记录参数(顺序栈的栈底地址 顺序栈的容量 顺序栈的栈顶元素的下标)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">typedef struct sequenceStack &#123;</span><br><span class="line">    dataType_t *Bottom;       //顺序栈的栈底地址</span><br><span class="line">    unsigned int size;      //顺序栈的容量</span><br><span class="line">    int Top;               //顺序栈的栈顶元素的下标</span><br><span class="line">&#125; sqStack_t;</span><br></pre></td></tr></table></figure><h2 id="创建顺序栈并对顺序栈进行初始化（sqStack-Create）"><a href="#创建顺序栈并对顺序栈进行初始化（sqStack-Create）" class="headerlink" title="创建顺序栈并对顺序栈进行初始化（sqStack_Create）"></a>创建顺序栈并对顺序栈进行初始化（sqStack_Create）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sqStack_t *sqStack_Create(unsigned int size)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 利用calloc为顺序栈的管理结构体申请堆内存</span><br><span class="line">    sqStack_t *manager = (sqStack_t*)calloc(1,sizeof (manager));</span><br><span class="line"></span><br><span class="line">    if(NULL == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for manager is failed&quot;);</span><br><span class="line">        exit(-1);       //程序终止</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 为所有元素申请堆内存 calloc,并完成错误处理</span><br><span class="line">    manager-&gt;Bottom = (dataType_t*)calloc(size,sizeof(dataType_t));</span><br><span class="line"></span><br><span class="line">    if(NULL == manager-&gt;Bottom)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for element is failed&quot;);</span><br><span class="line">        free(manager);  //释放内存</span><br><span class="line">        exit(-1);       //程序终止</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.3 对管理顺序栈的结构体进行初始化（元素容量 最后元素下标）</span><br><span class="line">    manager-&gt;size = size; //对顺序栈的容量进行初始化</span><br><span class="line">    manager-&gt;Top = -1;   //由于顺序栈为空，则最后元素下标初值为-1</span><br><span class="line"></span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序栈是否以满（sqStack-IsFull）"><a href="#判断顺序栈是否以满（sqStack-IsFull）" class="headerlink" title="判断顺序栈是否以满（sqStack_IsFull）"></a>判断顺序栈是否以满（sqStack_IsFull）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//判断顺序栈是否以满</span><br><span class="line">bool sqStack_IsFull(sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;Top+1 == manager-&gt;size) ? true : false;</span><br><span class="line">//        if(manager-&gt;Top+1 == manager-&gt;size)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return ture;</span><br><span class="line">//    &#125;</span><br><span class="line">//    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入栈-sqStack-Push"><a href="#入栈-sqStack-Push" class="headerlink" title="入栈(sqStack_Push)"></a>入栈(sqStack_Push)</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/%E5%85%A5%E6%A0%88.png" alt="入栈" title="入栈"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool sqStack_Push (sqStack_t *manager,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 判断顺序栈是否以满</span><br><span class="line">    if(sqStack_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;sequenceStack is Full!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 若顺序栈有空闲空间，则把新元素添加到顺序栈尾部</span><br><span class="line">/*    manager-&gt;Bottom++;</span><br><span class="line">    *(manager-&gt;Bottom + manager-&gt;Top) = data;   */</span><br><span class="line">    manager-&gt;Bottom[++manager-&gt;Top] = data;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序栈是否为空（sqStack-IsEmpty）"><a href="#判断顺序栈是否为空（sqStack-IsEmpty）" class="headerlink" title="判断顺序栈是否为空（sqStack_IsEmpty）"></a>判断顺序栈是否为空（sqStack_IsEmpty）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool sqStack_IsEmpty(sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;Top == -1) ? true : false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序栈是否为空（sqStack-IsEmpty）-1"><a href="#判断顺序栈是否为空（sqStack-IsEmpty）-1" class="headerlink" title="判断顺序栈是否为空（sqStack_IsEmpty）"></a>判断顺序栈是否为空（sqStack_IsEmpty）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//判断顺序栈是否为空</span><br><span class="line">bool sqStack_IsEmpty(sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;last == -1) ? true : false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出栈（sqStack-Pop）"><a href="#出栈（sqStack-Pop）" class="headerlink" title="出栈（sqStack_Pop）"></a>出栈（sqStack_Pop）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/%E5%87%BA%E6%A0%88.png" alt="出栈" title="出栈"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dataType_t sqStack_Pop (sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    dataType_t temp=-1;     //记录需要出栈的值</span><br><span class="line"></span><br><span class="line">    //4.1 判断顺序栈是否为空</span><br><span class="line">    if(sqStack_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;SequenceStack is Empty!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 由于删掉一个元素，则顺序栈有效元素下标减一 后--（先赋值后--）</span><br><span class="line">    temp = manager-&gt;Bottom[manager-&gt;Top--];</span><br><span class="line">    return temp;</span><br><span class="line"></span><br><span class="line">    //return manager-&gt;Bottom[manager-&gt;Top--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历顺序栈（sqStack-print）"><a href="#遍历顺序栈（sqStack-print）" class="headerlink" title="遍历顺序栈（sqStack_print）"></a>遍历顺序栈（sqStack_print）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//5 遍历顺序栈中的元素</span><br><span class="line">void sqStack_print (sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;=manager-&gt;Top;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Element[%d]=%d\n&quot;,i,manager-&gt;Bottom[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //1 创建顺序栈</span><br><span class="line">    sqStack_t *manager = sqStack_Create(10);</span><br><span class="line"></span><br><span class="line">    //2 向顺序栈  入栈</span><br><span class="line">    sqStack_Push (manager,5);</span><br><span class="line">    sqStack_Push (manager,2);</span><br><span class="line">    sqStack_Push (manager,1);</span><br><span class="line">    sqStack_Push (manager,4);</span><br><span class="line">    sqStack_Push (manager,6);</span><br><span class="line">    sqStack_Push (manager,8);</span><br><span class="line"></span><br><span class="line">    //3 遍历顺序栈</span><br><span class="line">    sqStack_print (manager);     //5 2 1 4 6</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //6 出栈</span><br><span class="line">    dataType_t temp1,temp2,temp3,temp4;</span><br><span class="line">    </span><br><span class="line">    temp1 = sqStack_Pop (manager);</span><br><span class="line">    printf(&quot; 出栈：%d &quot;,temp1);</span><br><span class="line"></span><br><span class="line">    temp2 = sqStack_Pop (manager);</span><br><span class="line">    printf(&quot; 出栈：%d &quot;,temp2);</span><br><span class="line"></span><br><span class="line">    temp3 = sqStack_Pop (manager);</span><br><span class="line">    printf(&quot; 出栈：%d &quot;,temp3);</span><br><span class="line"></span><br><span class="line">    temp4 = sqStack_Pop (manager);</span><br><span class="line">    printf(&quot; 出栈：%d\n&quot;,temp4);</span><br><span class="line"></span><br><span class="line">    //7 遍历顺序栈</span><br><span class="line">    sqStack_print (manager);     //8 8 4 8 2 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Element[0]=5</span><br><span class="line">Element[1]=2</span><br><span class="line">Element[2]=1</span><br><span class="line">Element[3]=4</span><br><span class="line">Element[4]=6</span><br><span class="line">Element[5]=8</span><br><span class="line"></span><br><span class="line"> 出栈：8  出栈：6  出栈：4  出栈：1</span><br><span class="line">Element[0]=5</span><br><span class="line">Element[1]=2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//构造顺序栈记录参数(顺序栈的栈底地址 顺序栈的容量 顺序栈的栈顶元素的下标)</span><br><span class="line">typedef struct sequenceStack &#123;</span><br><span class="line">    dataType_t *Bottom;       //顺序栈的栈底地址</span><br><span class="line">    unsigned int size;      //顺序栈的容量</span><br><span class="line">    int Top;               //顺序栈的栈顶元素的下标</span><br><span class="line">&#125; sqStack_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//1 创建顺序栈并对顺序栈进行初始化</span><br><span class="line">sqStack_t *sqStack_Create(unsigned int size)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 利用calloc为顺序栈的管理结构体申请堆内存</span><br><span class="line">    sqStack_t *manager = (sqStack_t*)calloc(1,sizeof (manager));</span><br><span class="line"></span><br><span class="line">    if(NULL == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for manager is failed&quot;);</span><br><span class="line">        exit(-1);       //程序终止</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 为所有元素申请堆内存 calloc,并完成错误处理</span><br><span class="line">    manager-&gt;Bottom = (dataType_t*)calloc(size,sizeof(dataType_t));</span><br><span class="line"></span><br><span class="line">    if(NULL == manager-&gt;Bottom)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for element is failed&quot;);</span><br><span class="line">        free(manager);  //释放内存</span><br><span class="line">        exit(-1);       //程序终止</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.3 对管理顺序栈的结构体进行初始化（元素容量 最后元素下标）</span><br><span class="line">    manager-&gt;size = size; //对顺序栈的容量进行初始化</span><br><span class="line">    manager-&gt;Top = -1;   //由于顺序栈为空，则最后元素下标初值为-1</span><br><span class="line"></span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//判断顺序栈是否以满</span><br><span class="line">bool sqStack_IsFull(sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;Top+1 == manager-&gt;size) ? true : false;</span><br><span class="line">//        if(manager-&gt;Top+1 == manager-&gt;size)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return ture;</span><br><span class="line">//    &#125;</span><br><span class="line">//    return false;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//2 顺序栈   入栈</span><br><span class="line">bool sqStack_Push (sqStack_t *manager,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 判断顺序栈是否以满</span><br><span class="line">    if(sqStack_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;sequenceStack is Full!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 若顺序栈有空闲空间，则把新元素添加到顺序栈尾部</span><br><span class="line">/*    manager-&gt;Bottom++;</span><br><span class="line">    *(manager-&gt;Bottom + manager-&gt;Top) = data;   */</span><br><span class="line">    manager-&gt;Bottom[++manager-&gt;Top] = data;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//判断顺序栈是否为空</span><br><span class="line">bool sqStack_IsEmpty(sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;Top == -1) ? true : false;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//4 顺序栈  出栈</span><br><span class="line">dataType_t sqStack_Pop (sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    dataType_t temp=-1;     //记录需要出栈的值</span><br><span class="line"></span><br><span class="line">    //4.1 判断顺序栈是否为空</span><br><span class="line">    if(sqStack_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;SequenceStack is Empty!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 由于删掉一个元素，则顺序栈有效元素下标减一 后--（先赋值后--）</span><br><span class="line">    temp = manager-&gt;Bottom[manager-&gt;Top--];</span><br><span class="line">    return temp;</span><br><span class="line"></span><br><span class="line">    //return manager-&gt;Bottom[manager-&gt;Top--];</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//5 遍历顺序栈中的元素</span><br><span class="line">void sqStack_print (sqStack_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;=manager-&gt;Top;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Element[%d]=%d\n&quot;,i,manager-&gt;Bottom[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //1 创建顺序栈</span><br><span class="line">    sqStack_t *manager = sqStack_Create(10);</span><br><span class="line"></span><br><span class="line">    //2 向顺序栈  入栈</span><br><span class="line">    sqStack_Push (manager,5);</span><br><span class="line">    sqStack_Push (manager,2);</span><br><span class="line">    sqStack_Push (manager,1);</span><br><span class="line">    sqStack_Push (manager,4);</span><br><span class="line">    sqStack_Push (manager,6);</span><br><span class="line">    sqStack_Push (manager,8);</span><br><span class="line"></span><br><span class="line">    //3 遍历顺序栈</span><br><span class="line">    sqStack_print (manager);     //5 2 1 4 6</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //6 出栈</span><br><span class="line">    dataType_t temp1,temp2,temp3,temp4;</span><br><span class="line">    </span><br><span class="line">    temp1 = sqStack_Pop (manager);</span><br><span class="line">    printf(&quot; 出栈：%d &quot;,temp1);</span><br><span class="line"></span><br><span class="line">    temp2 = sqStack_Pop (manager);</span><br><span class="line">    printf(&quot; 出栈：%d &quot;,temp2);</span><br><span class="line"></span><br><span class="line">    temp3 = sqStack_Pop (manager);</span><br><span class="line">    printf(&quot; 出栈：%d &quot;,temp3);</span><br><span class="line"></span><br><span class="line">    temp4 = sqStack_Pop (manager);</span><br><span class="line">    printf(&quot; 出栈：%d\n&quot;,temp4);</span><br><span class="line"></span><br><span class="line">    //7 遍历顺序栈</span><br><span class="line">    sqStack_print (manager);     //8 8 4 8 2 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构—顺序栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构五（双向循环链表DoubleCirLList）</title>
      <link href="/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCircularLinkeList%EF%BC%89/"/>
      <url>/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCircularLinkeList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个双向循环链表实现对双向循环链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历双向循环链表</p><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="双向循环链表" title="双向循环链表"></p><p>More info: <a href="https://github.com/gybpersist/DoubleCirLList">DoubleCirLList</a></p><h2 id="构造双向循环链表（DoubleCirLList）"><a href="#构造双向循环链表（DoubleCirLList）" class="headerlink" title="构造双向循环链表（DoubleCirLList）"></a>构造双向循环链表（DoubleCirLList）</h2><h3 id="构造双向循环链表的结点-双向循环链表中所有结点的数据类型应该是相同的"><a href="#构造双向循环链表的结点-双向循环链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造双向循环链表的结点 双向循环链表中所有结点的数据类型应该是相同的"></a>构造双向循环链表的结点 双向循环链表中所有结点的数据类型应该是相同的</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">typedef struct DoubleCirLList &#123;</span><br><span class="line">    dataType_t data;                 // 双向循环链表的数据域，用于存储具体的数据</span><br><span class="line">    struct DoubleCirLList *prev;   // 双向循环链表的前驱指针域，指向前一个节点</span><br><span class="line">    struct DoubleCirLList *next;   // 双向循环链表的后继指针域，指向后一个节点</span><br><span class="line">&#125; DoubleLList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（DoubleCirLList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（DoubleCirLList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（DoubleCirLList_Create）"></a>创建一个空链表，空链表应该有一个头结点（DoubleCirLList_Create）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t* DoubleCirLList_Create(void) &#123;</span><br><span class="line">    // 创建一个头结点并给头结点申请内存，使用 calloc 函数将内存初始化为 0</span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)calloc(1, sizeof(DoubleLList_t));</span><br><span class="line">    if (Head == NULL) &#123;</span><br><span class="line">        // 若内存分配失败，使用 perror 输出错误信息并退出程序</span><br><span class="line">        perror(&quot;calloc memory for Head is Failed!\n&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对头结点进行初始化，体现循环，将头结点的 prev 和 next 指针都指向自己</span><br><span class="line">    Head-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    // 把头结点的地址返回，方便后续操作</span><br><span class="line">    return Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleCirLList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleCirLList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleCirLList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleCirLList_NewNode）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t *DoubleCirLList_NewNode(dataType_t data) &#123;</span><br><span class="line">    // 创建一个新结点并给新结点申请内存，使用 calloc 函数将内存初始化为 0</span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) calloc(1, sizeof(DoubleLList_t));</span><br><span class="line">    if (NewNode == NULL) &#123;</span><br><span class="line">        // 若内存分配失败，使用 perror 输出错误信息并返回 NULL</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对新结点进行初始化（数据域 指针域2个），体现循环，将新结点的 prev 和 next 指针都指向自己</span><br><span class="line">    NewNode-&gt;prev = NewNode;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    // 把新结点的地址返回，方便后续操作</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入新节点到指定节点之后（insertAfter）"><a href="#插入新节点到指定节点之后（insertAfter）" class="headerlink" title="插入新节点到指定节点之后（insertAfter）"></a>插入新节点到指定节点之后（insertAfter）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void insertAfter(DoubleLList_t *node, DoubleLList_t *newNode) &#123;</span><br><span class="line">    // 将新节点的 next 指针指向指定节点的下一个节点</span><br><span class="line">    newNode-&gt;next = node-&gt;next;</span><br><span class="line">    // 将新节点的 prev 指针指向指定节点</span><br><span class="line">    newNode-&gt;prev = node;</span><br><span class="line">    // 将指定节点的下一个节点的 prev 指针指向新节点</span><br><span class="line">    node-&gt;next-&gt;prev = newNode;</span><br><span class="line">    // 将指定节点的 next 指针指向新节点</span><br><span class="line">    node-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（DoubleCirLList-HeadInsert）"><a href="#头插（DoubleCirLList-HeadInsert）" class="headerlink" title="头插（DoubleCirLList_HeadInsert）"></a>头插（DoubleCirLList_HeadInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleCirLList_HeadInsert(DoubleLList_t *Head, dataType_t data) &#123;</span><br><span class="line">    //3.1建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    if (NewNode == NULL) &#123;</span><br><span class="line">        // 若新节点创建失败，输出提示信息并返回 false</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        Head-&gt;prev = NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 以下四步操作将新节点插入到链表头部</span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    //    insertAfter(Phead, NewNode);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（DoubleCirLList-TailInsert）"><a href="#尾插（DoubleCirLList-TailInsert）" class="headerlink" title="尾插（DoubleCirLList_TailInsert）"></a>尾插（DoubleCirLList_TailInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleCirLList_TailInsert(DoubleLList_t *Head, dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        // 若新节点创建失败，输出提示信息并返回 false</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //把新结点插入到链表尾部</span><br><span class="line">    // 将新节点的 prev 指针指向原尾节点</span><br><span class="line">    NewNode-&gt;prev = Head-&gt;prev;</span><br><span class="line">    // 将原尾节点的 next 指针指向新节点</span><br><span class="line">    Head-&gt;prev-&gt;next = NewNode;</span><br><span class="line">    // 将新节点的 next 指针指向头结点</span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    // 将头结点的 prev 指针指向新节点</span><br><span class="line">    Head-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    //    insertAfter(Phead, NewNode);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（DoubleCirLList-DestInsert）"><a href="#指定插入（DoubleCirLList-DestInsert）" class="headerlink" title="指定插入（DoubleCirLList_DestInsert）"></a>指定插入（DoubleCirLList_DestInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleCirLList_DestInsert(DoubleLList_t *Head, dataType_t destval, dataType_t data) &#123;</span><br><span class="line">    // 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    if (NewNode == NULL) &#123;</span><br><span class="line">        // 若新节点创建失败，输出提示信息并返回 false</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历链表，找到目标结点（比较数据域）</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != Head &amp;&amp; Phead-&gt;data != destval) &#123;</span><br><span class="line">        // 若未找到目标节点且未遍历完链表，将指针移动到下一个节点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (Phead == Head) &#123;</span><br><span class="line">        // 未找到目标节点，释放新节点的内存并返回 false</span><br><span class="line">        free(NewNode);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 以下四步操作将新节点插入到目标节点之后</span><br><span class="line">    NewNode-&gt;next = Phead-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Phead-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">//    insertAfter(Phead, NewNode);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（DoubleCirLList-Print）"><a href="#遍历链表（DoubleCirLList-Print）" class="headerlink" title="遍历链表（DoubleCirLList_Print）"></a>遍历链表（DoubleCirLList_Print）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleCirLList_Print(DoubleLList_t *Head) &#123;</span><br><span class="line">    // 判断当前链表是否为空，为空则直接退出</span><br><span class="line">    if (Head-&gt;next == Head) &#123;</span><br><span class="line">        // 若链表为空，输出提示信息并返回 false</span><br><span class="line">        printf(&quot;Current linkedList is empty!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断当前链表不为空则继续遍历</span><br><span class="line">    int i = 0;</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != Head) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        // 输出当前节点的数据</span><br><span class="line">        printf(&quot;Date[%d] = %d\n&quot;, i, Phead-&gt;data);</span><br><span class="line">        // 将指针移动到下一个节点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除指定节点（deleteNode）"><a href="#删除指定节点（deleteNode）" class="headerlink" title="删除指定节点（deleteNode）"></a>删除指定节点（deleteNode）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void deleteNode(DoubleLList_t *node) &#123;</span><br><span class="line">    // 将指定节点的前一个节点的 next 指针指向指定节点的下一个节点</span><br><span class="line">    node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    // 将指定节点的下一个节点的 prev 指针指向指定节点的前一个节点</span><br><span class="line">    node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    // 将指定节点的 next 和 prev 指针置为 NULL</span><br><span class="line">    node-&gt;next = NULL;</span><br><span class="line">    node-&gt;prev = NULL;</span><br><span class="line">    // 释放指定节点的内存</span><br><span class="line">    free(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除首结点（DoubleCirLList-HeadDel）"><a href="#头删-删除首结点（DoubleCirLList-HeadDel）" class="headerlink" title="头删 删除首结点（DoubleCirLList_HeadDel）"></a>头删 删除首结点（DoubleCirLList_HeadDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleCirLList_HeadDel(DoubleLList_t *Head) &#123;</span><br><span class="line">    // 判断链表是否为空，如果为空则直接退出</span><br><span class="line">    if (Head-&gt;next == Head) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 7.2 对链表的首结点进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    // 7.3 链表非空 删除首结点</span><br><span class="line">    // 将首结点之后的结点的 prev 指针连接到头结点</span><br><span class="line">    Head-&gt;next-&gt;next-&gt;prev = Head;</span><br><span class="line">    // 将头结点的 next 指针指向原先首结点之后的结点</span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    // 7.4 释放首结点的内存</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    //    deleteNode(Head-&gt;next);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（DoubleCirLList-TailDel）"><a href="#尾删-删除尾结点（DoubleCirLList-TailDel）" class="headerlink" title="尾删 删除尾结点（DoubleCirLList_TailDel）"></a>尾删 删除尾结点（DoubleCirLList_TailDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleCirLList_TailDel(DoubleLList_t *Head) &#123;</span><br><span class="line">    // 8.1 判断判断链表是否为空，如果为空则直接退出</span><br><span class="line">    if (Head-&gt;next == Head) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 8.2 记录当前尾结点的地址</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;prev;</span><br><span class="line"></span><br><span class="line">    // 8.3 链表非空 删除尾结点</span><br><span class="line">    // 将头结点的 prev 指针连接到尾结点的前一个结点</span><br><span class="line">    Head-&gt;next-&gt;prev = Phead-&gt;prev;</span><br><span class="line">    // 将尾结点的前一个结点的 next 指针连接到头结点</span><br><span class="line">    Phead-&gt;prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    // 8.4 释放尾结点的内存</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    //    deleteNode(Head-&gt;prev);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个双向循环链表</span><br><span class="line">    DoubleLList_t *Head = DoubleCirLList_Create();</span><br><span class="line"></span><br><span class="line">    // 进行头插操作</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 5);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 8);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 1);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 6);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 3);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 进行尾插操作</span><br><span class="line">    DoubleCirLList_TailInsert(Head, 4);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 在值为 1 的节点后插入新节点</span><br><span class="line">    DoubleCirLList_DestInsert(Head, 1, 9);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 进行头删操作</span><br><span class="line">    DoubleCirLList_HeadDel(Head);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 进行尾删操作</span><br><span class="line">    DoubleCirLList_TailDel(Head);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line"></span><br><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line">Date[6] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 9</span><br><span class="line">Date[5] = 8</span><br><span class="line">Date[6] = 5</span><br><span class="line">Date[7] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 6</span><br><span class="line">Date[2] = 1</span><br><span class="line">Date[3] = 9</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line">Date[6] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 6</span><br><span class="line">Date[2] = 1</span><br><span class="line">Date[3] = 9</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 类型别名，将 int 类型重命名为 dataType_t，方便后续修改数据类型</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 构造双向循环链表的结点</span><br><span class="line">typedef struct DoubleCirLList &#123;</span><br><span class="line">    dataType_t data;                 // 双向循环链表的数据域，用于存储具体的数据</span><br><span class="line">    struct DoubleCirLList *prev;   // 双向循环链表的前驱指针域，指向前一个节点</span><br><span class="line">    struct DoubleCirLList *next;   // 双向循环链表的后继指针域，指向后一个节点</span><br><span class="line">&#125; DoubleLList_t;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 1 创建一个空链表，空链表应该有一个头结点</span><br><span class="line">DoubleLList_t* DoubleCirLList_Create(void) &#123;</span><br><span class="line">    // 创建一个头结点并给头结点申请内存，使用 calloc 函数将内存初始化为 0</span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)calloc(1, sizeof(DoubleLList_t));</span><br><span class="line">    if (Head == NULL) &#123;</span><br><span class="line">        // 若内存分配失败，使用 perror 输出错误信息并退出程序</span><br><span class="line">        perror(&quot;calloc memory for Head is Failed!\n&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对头结点进行初始化，体现循环，将头结点的 prev 和 next 指针都指向自己</span><br><span class="line">    Head-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    // 把头结点的地址返回，方便后续操作</span><br><span class="line">    return Head;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">DoubleLList_t *DoubleCirLList_NewNode(dataType_t data) &#123;</span><br><span class="line">    // 创建一个新结点并给新结点申请内存，使用 calloc 函数将内存初始化为 0</span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) calloc(1, sizeof(DoubleLList_t));</span><br><span class="line">    if (NewNode == NULL) &#123;</span><br><span class="line">        // 若内存分配失败，使用 perror 输出错误信息并返回 NULL</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对新结点进行初始化（数据域 指针域2个），体现循环，将新结点的 prev 和 next 指针都指向自己</span><br><span class="line">    NewNode-&gt;prev = NewNode;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    // 把新结点的地址返回，方便后续操作</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 插入新节点到指定节点之后</span><br><span class="line">void insertAfter(DoubleLList_t *node, DoubleLList_t *newNode) &#123;</span><br><span class="line">    // 将新节点的 next 指针指向指定节点的下一个节点</span><br><span class="line">    newNode-&gt;next = node-&gt;next;</span><br><span class="line">    // 将新节点的 prev 指针指向指定节点</span><br><span class="line">    newNode-&gt;prev = node;</span><br><span class="line">    // 将指定节点的下一个节点的 prev 指针指向新节点</span><br><span class="line">    node-&gt;next-&gt;prev = newNode;</span><br><span class="line">    // 将指定节点的 next 指针指向新节点</span><br><span class="line">    node-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 3 在链表中 头插</span><br><span class="line">bool DoubleCirLList_HeadInsert(DoubleLList_t *Head, dataType_t data) &#123;</span><br><span class="line">    //3.1建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    if (NewNode == NULL) &#123;</span><br><span class="line">        // 若新节点创建失败，输出提示信息并返回 false</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        Head-&gt;prev = NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 以下四步操作将新节点插入到链表头部</span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    //    insertAfter(Phead, NewNode);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 4 在链表中 尾部插</span><br><span class="line">bool DoubleCirLList_TailInsert(DoubleLList_t *Head, dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        // 若新节点创建失败，输出提示信息并返回 false</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //把新结点插入到链表尾部</span><br><span class="line">    // 将新节点的 prev 指针指向原尾节点</span><br><span class="line">    NewNode-&gt;prev = Head-&gt;prev;</span><br><span class="line">    // 将原尾节点的 next 指针指向新节点</span><br><span class="line">    Head-&gt;prev-&gt;next = NewNode;</span><br><span class="line">    // 将新节点的 next 指针指向头结点</span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    // 将头结点的 prev 指针指向新节点</span><br><span class="line">    Head-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    //    insertAfter(Phead, NewNode);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 5 在链表中 指定插入</span><br><span class="line">bool DoubleCirLList_DestInsert(DoubleLList_t *Head, dataType_t destval, dataType_t data) &#123;</span><br><span class="line">    // 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    if (NewNode == NULL) &#123;</span><br><span class="line">        // 若新节点创建失败，输出提示信息并返回 false</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历链表，找到目标结点（比较数据域）</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != Head &amp;&amp; Phead-&gt;data != destval) &#123;</span><br><span class="line">        // 若未找到目标节点且未遍历完链表，将指针移动到下一个节点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (Phead == Head) &#123;</span><br><span class="line">        // 未找到目标节点，释放新节点的内存并返回 false</span><br><span class="line">        free(NewNode);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 以下四步操作将新节点插入到目标节点之后</span><br><span class="line">    NewNode-&gt;next = Phead-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Phead-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">//    insertAfter(Phead, NewNode);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 6 遍历链表</span><br><span class="line">bool DoubleCirLList_Print(DoubleLList_t *Head) &#123;</span><br><span class="line">    // 判断当前链表是否为空，为空则直接退出</span><br><span class="line">    if (Head-&gt;next == Head) &#123;</span><br><span class="line">        // 若链表为空，输出提示信息并返回 false</span><br><span class="line">        printf(&quot;Current linkedList is empty!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断当前链表不为空则继续遍历</span><br><span class="line">    int i = 0;</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != Head) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        // 输出当前节点的数据</span><br><span class="line">        printf(&quot;Date[%d] = %d\n&quot;, i, Phead-&gt;data);</span><br><span class="line">        // 将指针移动到下一个节点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 删除指定节点</span><br><span class="line">void deleteNode(DoubleLList_t *node) &#123;</span><br><span class="line">    // 将指定节点的前一个节点的 next 指针指向指定节点的下一个节点</span><br><span class="line">    node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    // 将指定节点的下一个节点的 prev 指针指向指定节点的前一个节点</span><br><span class="line">    node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    // 将指定节点的 next 和 prev 指针置为 NULL</span><br><span class="line">    node-&gt;next = NULL;</span><br><span class="line">    node-&gt;prev = NULL;</span><br><span class="line">    // 释放指定节点的内存</span><br><span class="line">    free(node);</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 7 头删 删除首结点</span><br><span class="line">bool DoubleCirLList_HeadDel(DoubleLList_t *Head) &#123;</span><br><span class="line">    // 判断链表是否为空，如果为空则直接退出</span><br><span class="line">    if (Head-&gt;next == Head) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 7.2 对链表的首结点进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    // 7.3 链表非空 删除首结点</span><br><span class="line">    // 将首结点之后的结点的 prev 指针连接到头结点</span><br><span class="line">    Head-&gt;next-&gt;next-&gt;prev = Head;</span><br><span class="line">    // 将头结点的 next 指针指向原先首结点之后的结点</span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    // 7.4 释放首结点的内存</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    //    deleteNode(Head-&gt;next);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">// 8 尾删 删除尾结点</span><br><span class="line">bool DoubleCirLList_TailDel(DoubleLList_t *Head) &#123;</span><br><span class="line">    // 8.1 判断判断链表是否为空，如果为空则直接退出</span><br><span class="line">    if (Head-&gt;next == Head) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 8.2 记录当前尾结点的地址</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;prev;</span><br><span class="line"></span><br><span class="line">    // 8.3 链表非空 删除尾结点</span><br><span class="line">    // 将头结点的 prev 指针连接到尾结点的前一个结点</span><br><span class="line">    Head-&gt;next-&gt;prev = Phead-&gt;prev;</span><br><span class="line">    // 将尾结点的前一个结点的 next 指针连接到头结点</span><br><span class="line">    Phead-&gt;prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    // 8.4 释放尾结点的内存</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    //    deleteNode(Head-&gt;prev);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个双向循环链表</span><br><span class="line">    DoubleLList_t *Head = DoubleCirLList_Create();</span><br><span class="line"></span><br><span class="line">    // 进行头插操作</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 5);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 8);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 1);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 6);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, 3);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 进行尾插操作</span><br><span class="line">    DoubleCirLList_TailInsert(Head, 4);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 在值为 1 的节点后插入新节点</span><br><span class="line">    DoubleCirLList_DestInsert(Head, 1, 9);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 进行头删操作</span><br><span class="line">    DoubleCirLList_HeadDel(Head);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 进行尾删操作</span><br><span class="line">    DoubleCirLList_TailDel(Head);</span><br><span class="line"></span><br><span class="line">    // 遍历链表并输出结果</span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构—双向循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构四（单向循环链表CircularLinkedList）</title>
      <link href="/2025/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/"/>
      <url>/2025/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个单向循环链表实现对单向循环链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历单向循环链表</p><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="单向循环链表" title="单向循环链表"></p><p>More info: <a href="https://github.com/gybpersist/CircularLinkedList">CircularLinkedList</a></p><h2 id="构造单向循环链表（CircularLinkedList）"><a href="#构造单向循环链表（CircularLinkedList）" class="headerlink" title="构造单向循环链表（CircularLinkedList）"></a>构造单向循环链表（CircularLinkedList）</h2><h3 id="构造单向循环链表的结点-单向循环链表中所有结点的数据类型应该是相同的"><a href="#构造单向循环链表的结点-单向循环链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造单向循环链表的结点 单向循环链表中所有结点的数据类型应该是相同的"></a>构造单向循环链表的结点 单向循环链表中所有结点的数据类型应该是相同的</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">typedef struct CircularLinkedList &#123;</span><br><span class="line">    dataType_t data;                 //单向循环链表的数据域</span><br><span class="line">    struct CircularLinkedList *next;      //单向循环链表的指针域</span><br><span class="line">&#125; CricLList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（CricLList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（CricLList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（CricLList_Create）"></a>创建一个空链表，空链表应该有一个头结点（CricLList_Create）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CricLList_t* CricLList_Create(void)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 创建一个头结点并给头结点申请内存</span><br><span class="line">    CricLList_t *Head = (CricLList_t*)calloc(1,sizeof (CricLList_t));</span><br><span class="line">    if(Head == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for Head is Failed!\n&quot;);</span><br><span class="line">        exit(-1);       //退出程序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 对头结点进行初始化，头结点是不存储有效内容的</span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    //1.3 把头结点地地址返回</span><br><span class="line">    return Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（CricLList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（CricLList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（CricLList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（CricLList_NewNode）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CricLList_t *CricLList_NewNode(dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 创建一个新结点并给新结点申请内存</span><br><span class="line">    CricLList_t *NewNode = (CricLList_t *) calloc(1, sizeof(CricLList_t));</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 对新结点进行初始化（数据域 指针域）</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //2.3 把新结点地地址返回</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（CricLList-HeadInsert）"><a href="#头插（CricLList-HeadInsert）" class="headerlink" title="头插（CricLList_HeadInsert）"></a>头插（CricLList_HeadInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool CricLList_HeadInsert(CricLList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.3 如果链表为非空，则把新结点插入到链表头部</span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（CricLList-TailInsert）"><a href="#尾插（CricLList-TailInsert）" class="headerlink" title="尾插（CricLList_TailInsert）"></a>尾插（CricLList_TailInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool CricLList_TailInsert(CricLList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.3 如果链表为非空，则把新结点插入到链表尾部</span><br><span class="line">    //对链表的头结点进行备份</span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line">    while (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（CricLList-DestInsert）"><a href="#指定插入（CricLList-DestInsert）" class="headerlink" title="指定插入（CricLList_DestInsert）"></a>指定插入（CricLList_DestInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">bool CricLList_DestInsert(CricLList_t *Head,dataType_t destval,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span><br><span class="line">    //对链表的首结点进行备份</span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != Head &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        //把结点的直接后继作为新的结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        if(Phead == Head)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;   //代表循环完之后未找到 目标值destval</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.4 说明找到目标结点，则把新结点加入到目标结点后面</span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（CricLList-Print）"><a href="#遍历链表（CricLList-Print）" class="headerlink" title="遍历链表（CricLList_Print）"></a>遍历链表（CricLList_Print）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bool CricLList_Print(CricLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //对链表的头结点的地址进行备份</span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    //判断当前链表是否为空，为空则直接退出</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Current linkedList is empty!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断当前链表不为空则继续遍历</span><br><span class="line">    //记录第几个</span><br><span class="line">    int i=0;</span><br><span class="line">    while (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        //输出头结点的直接后继的数据域</span><br><span class="line">        printf(&quot;Date[%d] = %d\n&quot;,i,Phead-&gt;data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除头结点（CricLList-HeadDel）"><a href="#头删-删除头结点（CricLList-HeadDel）" class="headerlink" title="头删 删除头结点（CricLList_HeadDel）"></a>头删 删除头结点（CricLList_HeadDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool CricLList_HeadDel(CricLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //7.1 对链表的首结点进行备份</span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //7.2 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7.3 链表非空 删除首结点</span><br><span class="line">    Head-&gt;next = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    // 如果链表只有一个节点，删除后让头结点指向自身</span><br><span class="line">    if (Phead-&gt;next == Head) &#123;</span><br><span class="line">        Head-&gt;next = Head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7.4 原先首结点的 next指向NULL，并释放首结点的内存</span><br><span class="line">    Phead-&gt;next = NULL;</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（CricLList-TailDel）"><a href="#尾删-删除尾结点（CricLList-TailDel）" class="headerlink" title="尾删 删除尾结点（CricLList_TailDel）"></a>尾删 删除尾结点（CricLList_TailDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bool CricLList_TailDel(CricLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //8.1 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //8.2 记录当前结点的地址</span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //记录当前结点的直接前驱</span><br><span class="line">    CricLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    //8.3 链表非空 删除尾结点</span><br><span class="line">    while (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    CricLList_t *Head = CricLList_Create();            //创建链表</span><br><span class="line"></span><br><span class="line">    CricLList_HeadInsert(Head,5);            //头插</span><br><span class="line">    CricLList_HeadInsert(Head,8);</span><br><span class="line">    CricLList_HeadInsert(Head,1);</span><br><span class="line">    CricLList_HeadInsert(Head,6);</span><br><span class="line">    CricLList_HeadInsert(Head,3);</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 3 6 1 8 5</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    CricLList_TailInsert(Head,4);               //尾插</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 3 6 1 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    CricLList_DestInsert(Head,1,9);     //destval后面插入</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 3 6 1 9 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    CricLList_HeadDel(Head);                        //头删</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 6 1 9 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    CricLList_TailDel(Head);                        //尾删</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 6 1 9 8 5</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line"></span><br><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line">Date[6] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 9</span><br><span class="line">Date[5] = 8</span><br><span class="line">Date[6] = 5</span><br><span class="line">Date[7] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 6</span><br><span class="line">Date[2] = 1</span><br><span class="line">Date[3] = 9</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line">Date[6] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 6</span><br><span class="line">Date[2] = 1</span><br><span class="line">Date[3] = 9</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//构造单向循环链表的结点 单向链循环表中所以结点的数据类型应该是相同的</span><br><span class="line">typedef struct CircularLinkedList &#123;</span><br><span class="line">    dataType_t data;                 //单向链表的数据域</span><br><span class="line">    struct CircularLinkedList *next;      //单向链表的指针域</span><br><span class="line">&#125; CricLList_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//1 创建一个空链表，空链表应该有一个头结点</span><br><span class="line">CricLList_t* CricLList_Create(void)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 创建一个头结点并给头结点申请内存</span><br><span class="line">    CricLList_t *Head = (CricLList_t*)calloc(1,sizeof (CricLList_t));</span><br><span class="line">    if(Head == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for Head is Failed!\n&quot;);</span><br><span class="line">        exit(-1);       //退出程序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 对头结点进行初始化，头结点是不存储有效内容的,指针域指向自己，体现循环思想</span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    //1.3 把头结点地地址返回</span><br><span class="line">    return Head;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">CricLList_t *CricLList_NewNode(dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 创建一个新结点并给新结点申请内存</span><br><span class="line">    CricLList_t *NewNode = (CricLList_t *) calloc(1, sizeof(CricLList_t));</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 对新结点进行初始化（数据域 指针域）</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //2.3 把新结点地地址返回</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//3 在链表中 头插</span><br><span class="line">bool CricLList_HeadInsert(CricLList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.3 如果链表为非空，则把新结点插入到链表头部</span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//4 在链表中 尾部插</span><br><span class="line">bool CricLList_TailInsert(CricLList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.3 如果链表为非空，则把新结点插入到链表尾部</span><br><span class="line">    //对链表的头结点进行备份</span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line">    while (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next = NewNode;</span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//5 在链表中 指定插入</span><br><span class="line">bool CricLList_DestInsert(CricLList_t *Head,dataType_t destval,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span><br><span class="line">    //对链表的首结点进行备份</span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != Head &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        //把结点的直接后继作为新的结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        if(Phead == Head)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;   //代表循环完之后未找到 目标值destval</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.4 说明找到目标结点，则把新结点加入到目标结点后面</span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//6 遍历链表</span><br><span class="line">bool CricLList_Print(CricLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //对链表的头结点的地址进行备份</span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    //判断当前链表是否为空，为空则直接退出</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Current linkedList is empty!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断当前链表不为空则继续遍历</span><br><span class="line">    //记录第几个</span><br><span class="line">    int i=0;</span><br><span class="line">    while (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        //输出头结点的直接后继的数据域</span><br><span class="line">        printf(&quot;Date[%d] = %d\n&quot;,i,Phead-&gt;data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//7 头删 删除首结点</span><br><span class="line">bool CricLList_HeadDel(CricLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //7.1 对链表的首结点进行备份</span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //7.2 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7.3 链表非空 删除首结点</span><br><span class="line">    Head-&gt;next = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    // 如果链表只有一个节点，删除后让头结点指向自身</span><br><span class="line">    if (Phead-&gt;next == Head) &#123;</span><br><span class="line">        Head-&gt;next = Head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7.4 原先首结点的 next指向NULL，并释放首结点的内存</span><br><span class="line">    Phead-&gt;next = NULL;</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//8 尾删 删除尾结点</span><br><span class="line">bool CricLList_TailDel(CricLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //8.1 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //8.2 记录当前结点的地址</span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //记录当前结点的直接前驱</span><br><span class="line">    CricLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    //8.3 链表非空 删除尾结点</span><br><span class="line">    while (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    CricLList_t *Head = CricLList_Create();            //创建链表</span><br><span class="line"></span><br><span class="line">    CricLList_HeadInsert(Head,5);            //头插</span><br><span class="line">    CricLList_HeadInsert(Head,8);</span><br><span class="line">    CricLList_HeadInsert(Head,1);</span><br><span class="line">    CricLList_HeadInsert(Head,6);</span><br><span class="line">    CricLList_HeadInsert(Head,3);</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 3 6 1 8 5</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    CricLList_TailInsert(Head,4);               //尾插</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 3 6 1 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    CricLList_DestInsert(Head,1,9);     //destval后面插入</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 3 6 1 9 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    CricLList_HeadDel(Head);                        //头删</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 6 1 9 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    CricLList_TailDel(Head);                        //尾删</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         //遍历链表 6 1 9 8 5</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构—单向循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构二（单向链表linkedList）</title>
      <link href="/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/"/>
      <url>/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个单向链表实现对单向链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历单向链表</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="单向链表" title="单向链表"></p><p>More info: <a href="https://github.com/gybpersist/linkedList">linkedList</a></p><h2 id="构造单向链表（linkedList）"><a href="#构造单向链表（linkedList）" class="headerlink" title="构造单向链表（linkedList）"></a>构造单向链表（linkedList）</h2><h3 id="构造单向链表的结点-单向链表中所有结点的数据类型应该是相同的"><a href="#构造单向链表的结点-单向链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造单向链表的结点 单向链表中所有结点的数据类型应该是相同的"></a>构造单向链表的结点 单向链表中所有结点的数据类型应该是相同的</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">typedef struct linkedList &#123;</span><br><span class="line">    dataType_t data;                 //单向链表的数据域</span><br><span class="line">    struct linkedList *next;      //单向链表的指针域</span><br><span class="line">&#125; lList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（lList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（lList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（lList_Create）"></a>创建一个空链表，空链表应该有一个头结点（lList_Create）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lList_t* lList_Create(void)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 创建一个头结点并给头结点申请内存</span><br><span class="line">    lList_t *Head = (lList_t*)calloc(1,sizeof (lList_t));</span><br><span class="line">    if(Head == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for Head is Failed!\n&quot;);</span><br><span class="line">        exit(-1);       //退出程序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 对头结点进行初始化，头结点是不存储有效内容的</span><br><span class="line">    Head-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //1.3 把头结点地地址返回</span><br><span class="line">    return Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（lList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（lList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（lList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（lList_NewNode）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lList_t *lList_NewNode(dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 创建一个新结点并给新结点申请内存</span><br><span class="line">    lList_t *NewNode = (lList_t *) calloc(1, sizeof(lList_t));</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 对新结点进行初始化（数据域 指针域）</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //2.3 把新结点地地址返回</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（lList-HeadInsert）"><a href="#头插（lList-HeadInsert）" class="headerlink" title="头插（lList_HeadInsert）"></a>头插（lList_HeadInsert）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bool lList_HeadInsert(lList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.3 如果链表为非空，则把新结点插入到链表头部</span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（lList-TailInsert）"><a href="#尾插（lList-TailInsert）" class="headerlink" title="尾插（lList_TailInsert）"></a>尾插（lList_TailInsert）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bool lList_TailInsert(lList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.3 如果链表为非空，则把新结点插入到链表尾部</span><br><span class="line">    //对链表的头结点进行备份</span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line">    while (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（lList-DestInsert）"><a href="#指定插入（lList-DestInsert）" class="headerlink" title="指定插入（lList_DestInsert）"></a>指定插入（lList_DestInsert）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">bool lList_DestInsert(lList_t *Head,dataType_t destval,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span><br><span class="line">    //对链表的首结点进行备份</span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != NULL &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        //把结点的直接后继作为新的结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        if(Phead == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.4 说明找到目标结点，则把新结点加入到目标结点后面</span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（lList-Print）"><a href="#遍历链表（lList-Print）" class="headerlink" title="遍历链表（lList_Print）"></a>遍历链表（lList_Print）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void lList_Print(lList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //对链表的头结点进行备份</span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    //记录第几个</span><br><span class="line">    int i=0;</span><br><span class="line">    while (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        //输出头结点的直接后继的数据域</span><br><span class="line">        printf(&quot;Date[%d] = %d\n&quot;,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除首结点（lList-HeadDel）"><a href="#头删-删除首结点（lList-HeadDel）" class="headerlink" title="头删 删除首结点（lList_HeadDel）"></a>头删 删除首结点（lList_HeadDel）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool lList_HeadDel(lList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //7.1 对链表的首结点进行备份</span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //7.2 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7.3 链表非空 删除首结点</span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    //7.4 原先首结点的 next指向NULL，并释放首结点的内存</span><br><span class="line">    Phead-&gt;next = NULL;</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（lList-TailDel）"><a href="#尾删-删除尾结点（lList-TailDel）" class="headerlink" title="尾删 删除尾结点（lList_TailDel）"></a>尾删 删除尾结点（lList_TailDel）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool lList_TailDel(lList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //8.1 记录当前结点的地址</span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //记录当前结点的直接前驱</span><br><span class="line">    lList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //8.2 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //8.3 链表非空 删除尾结点</span><br><span class="line">    while (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    lList_t *Head = lList_Create();            //创建链表</span><br><span class="line">    lList_NewNode(5);                    //创建新结点</span><br><span class="line"></span><br><span class="line">    lList_HeadInsert(Head,5);            //头插</span><br><span class="line">    lList_HeadInsert(Head,8);</span><br><span class="line">    lList_HeadInsert(Head,1);</span><br><span class="line">    lList_HeadInsert(Head,6);</span><br><span class="line">    lList_HeadInsert(Head,3);</span><br><span class="line"></span><br><span class="line">    lList_TailInsert(Head,4);               //尾插</span><br><span class="line"></span><br><span class="line">    lList_DestInsert(Head,1,9);     //destval后面插入</span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         //遍历链表 3 6 1 9 8 5 4</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    lList_HeadDel(Head);                        //头删</span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         //遍历链表 6 1 9 8 5 4</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    lList_TailDel(Head);                        //尾删</span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         //遍历链表 6 1 9 8 5</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 9</span><br><span class="line">Date[5] = 8</span><br><span class="line">Date[6] = 5</span><br><span class="line">Date[7] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 6</span><br><span class="line">Date[2] = 1</span><br><span class="line">Date[3] = 9</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line">Date[6] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 6</span><br><span class="line">Date[2] = 1</span><br><span class="line">Date[3] = 9</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//构造单向链表的结点 单向链表中所有结点的数据类型应该是相同的</span><br><span class="line">typedef struct linkedList &#123;</span><br><span class="line">    dataType_t data;                 //单向链表的数据域</span><br><span class="line">    struct linkedList *next;      //单向链表的指针域</span><br><span class="line">&#125; lList_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//1 创建一个空链表，空链表应该有一个头结点</span><br><span class="line">lList_t* lList_Create(void)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 创建一个头结点并给头结点申请内存</span><br><span class="line">    lList_t *Head = (lList_t*)calloc(1,sizeof (lList_t));</span><br><span class="line">    if(Head == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for Head is Failed!\n&quot;);</span><br><span class="line">        exit(-1);       //退出程序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 对头结点进行初始化，头结点是不存储有效内容的</span><br><span class="line">    Head-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //1.3 把头结点地地址返回</span><br><span class="line">    return Head;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">lList_t *lList_NewNode(dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 创建一个新结点并给新结点申请内存</span><br><span class="line">    lList_t *NewNode = (lList_t *) calloc(1, sizeof(lList_t));</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 对新结点进行初始化（数据域 指针域）</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //2.3 把新结点地地址返回</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//3 ccccccccc</span><br><span class="line">bool lList_HeadInsert(lList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.3 如果链表为非空，则把新结点插入到链表头部</span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//4 在链表中 尾部插</span><br><span class="line">bool lList_TailInsert(lList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.3 如果链表为非空，则把新结点插入到链表尾部</span><br><span class="line">    //对链表的头结点进行备份</span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line">    while (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//5 在链表中 指定插入</span><br><span class="line">bool lList_DestInsert(lList_t *Head,dataType_t destval,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span><br><span class="line">    //对链表的首结点进行备份</span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != NULL &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        //把结点的直接后继作为新的结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        if(Phead == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.4 说明找到目标结点，则把新结点加入到目标结点后面</span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//6 遍历链表</span><br><span class="line">void lList_Print(lList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //对链表的头结点进行备份</span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    //记录第几个</span><br><span class="line">    int i=0;</span><br><span class="line">    while (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        //输出头结点的直接后继的数据域</span><br><span class="line">        printf(&quot;Date[%d] = %d\n&quot;,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//7 头删 删除首结点</span><br><span class="line">bool lList_HeadDel(lList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //7.1 对链表的首结点进行备份</span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //7.2 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7.3 链表非空 删除首结点</span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    //7.4 原先首结点的 next指向NULL，并释放首结点的内存</span><br><span class="line">    Phead-&gt;next = NULL;</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//8 尾删 删除尾结点</span><br><span class="line">bool lList_TailDel(lList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //8.1 记录当前结点的地址</span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //记录当前结点的直接前驱</span><br><span class="line">    lList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //8.2 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //8.3 链表非空 删除尾结点</span><br><span class="line">    while (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    lList_t *Head = lList_Create();            //创建链表</span><br><span class="line">    lList_NewNode(5);                    //创建新结点</span><br><span class="line"></span><br><span class="line">    lList_HeadInsert(Head,5);            //头插</span><br><span class="line">    lList_HeadInsert(Head,8);</span><br><span class="line">    lList_HeadInsert(Head,1);</span><br><span class="line">    lList_HeadInsert(Head,6);</span><br><span class="line">    lList_HeadInsert(Head,3);</span><br><span class="line"></span><br><span class="line">    lList_TailInsert(Head,4);               //尾插</span><br><span class="line"></span><br><span class="line">    lList_DestInsert(Head,1,9);     //destval后面插入</span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         //遍历链表 3 6 1 9 8 5 4</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    lList_HeadDel(Head);                        //头删</span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         //遍历链表 6 1 9 8 5 4</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    lList_TailDel(Head);                        //尾删</span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         //遍历链表 6 1 9 8 5</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构—单向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构一（顺序表sequenceList）</title>
      <link href="/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8sequenceList%EF%BC%89/"/>
      <url>/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8sequenceList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个顺序表实现对顺序表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历顺序表</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8sequenceList%EF%BC%89/%E9%A1%BA%E5%BA%8F%E8%A1%A8.png" alt="顺序表" title="顺序表"></p><p>More info: <a href="https://github.com/gybpersist/sequenceList">sequenceList</a></p><h2 id="构造顺序表（sequenceList）"><a href="#构造顺序表（sequenceList）" class="headerlink" title="构造顺序表（sequenceList）"></a>构造顺序表（sequenceList）</h2><h3 id="构造顺序表记录参数-顺序表的首地址-顺序表的容量-顺序表的有效元素的下标"><a href="#构造顺序表记录参数-顺序表的首地址-顺序表的容量-顺序表的有效元素的下标" class="headerlink" title="构造顺序表记录参数(顺序表的首地址 顺序表的容量 顺序表的有效元素的下标)"></a>构造顺序表记录参数(顺序表的首地址 顺序表的容量 顺序表的有效元素的下标)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">typedef struct sequenceList &#123;</span><br><span class="line">    dataType_t *Addr;       //顺序表的首地址</span><br><span class="line">    unsigned int size;      //顺序表的容量</span><br><span class="line">    int last;               //顺序表的有效元素的下标</span><br><span class="line">&#125; sqList_t;</span><br></pre></td></tr></table></figure><h2 id="创建顺序表并对顺序表进行初始化（sqList-Create）"><a href="#创建顺序表并对顺序表进行初始化（sqList-Create）" class="headerlink" title="创建顺序表并对顺序表进行初始化（sqList_Create）"></a>创建顺序表并对顺序表进行初始化（sqList_Create）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sqList_t *sqList_Create(unsigned int size)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 利用calloc为顺序表的管理结构体申请堆内存</span><br><span class="line">    sqList_t *manager = (sqList_t*)calloc(1,sizeof (manager));</span><br><span class="line"></span><br><span class="line">    if(NULL == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for manager is failed&quot;);</span><br><span class="line">        exit(-1);       //程序终止</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 为所有元素申请堆内存 calloc,并完成错误处理</span><br><span class="line">    manager-&gt;Addr = (dataType_t*)calloc(size,sizeof(dataType_t));</span><br><span class="line"></span><br><span class="line">    if(NULL == manager-&gt;Addr)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for element is failed&quot;);</span><br><span class="line">        free(manager);  //释放内存</span><br><span class="line">        exit(-1);       //程序终止</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.3 对管理顺序表的结构体进行初始化（元素容量 最后元素下标）</span><br><span class="line">    manager-&gt;size = size; //对顺序表的容量进行初始化</span><br><span class="line">    manager-&gt;last = -1;   //由于顺序表为空，则最后元素下标初值为-1</span><br><span class="line"></span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序表是否以满（sqList-IsFull）"><a href="#判断顺序表是否以满（sqList-IsFull）" class="headerlink" title="判断顺序表是否以满（sqList_IsFull）"></a>判断顺序表是否以满（sqList_IsFull）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//判断顺序表是否以满</span><br><span class="line">bool sqList_IsFull(sqList_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;last+1 == manager-&gt;size) ? true : false;</span><br><span class="line">//        if(manager-&gt;last+1 == manager-&gt;size)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return ture;</span><br><span class="line">//    &#125;</span><br><span class="line">//    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（sqList-endAdd）"><a href="#尾插（sqList-endAdd）" class="headerlink" title="尾插（sqList_endAdd）"></a>尾插（sqList_endAdd）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//向顺序表的尾部插入元素</span><br><span class="line">bool sqList_endAdd (sqList_t *manager,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 判断顺序表是否以满</span><br><span class="line">    if(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;sequenceList is Full!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 若顺序表有空闲空间，则把新元素添加到顺序表尾部</span><br><span class="line">/*    manager-&gt;last++;</span><br><span class="line">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span><br><span class="line">    manager-&gt;Addr[++manager-&gt;last] = data;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（sqList-headAdd）"><a href="#头插（sqList-headAdd）" class="headerlink" title="头插（sqList_headAdd）"></a>头插（sqList_headAdd）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//3 向顺序表的头部插入元素</span><br><span class="line">bool sqList_headAdd (sqList_t *manager,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 判断顺序表是否以满</span><br><span class="line">    if(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;sequenceList is Full!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 若顺序表有空闲空间，则把新元素添加到顺序表头部 顺序表中所以元素向后移动1个单位</span><br><span class="line">/*    manager-&gt;last++;</span><br><span class="line">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span><br><span class="line">    for(int i = manager-&gt;last;i &gt;= 0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i+1] = manager-&gt;Addr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.3 把新元素放到顺序表的头部,并且更新管理结构体中的元素下标+1</span><br><span class="line">    manager-&gt;Addr[0] = data;</span><br><span class="line">    manager-&gt;last++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序表是否为空（sqList-IsEmpty）"><a href="#判断顺序表是否为空（sqList-IsEmpty）" class="headerlink" title="判断顺序表是否为空（sqList_IsEmpty）"></a>判断顺序表是否为空（sqList_IsEmpty）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//判断顺序表是否为空</span><br><span class="line">bool sqList_IsEmpty(sqList_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;last == -1) ? true : false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定删除（sqList-delAdd）"><a href="#指定删除（sqList-delAdd）" class="headerlink" title="指定删除（sqList_delAdd）"></a>指定删除（sqList_delAdd）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//4 向顺序表删除元素</span><br><span class="line">bool sqList_delAdd (sqList_t *manager,dataType_t destVal)</span><br><span class="line">&#123;</span><br><span class="line">    int temp=-1;     //记录需要删除的下标</span><br><span class="line"></span><br><span class="line">    //4.1 判断顺序表是否为空</span><br><span class="line">    if(sqList_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;SequenceList is Empty!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 需要查找目标值是否在顺序表中</span><br><span class="line">    for(int i=0;i &lt;= manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果目标值与顺序表中的值相同</span><br><span class="line">        if(destVal == manager-&gt;Addr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            temp=i;     //把目标元素的下标备份到变量temp中</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.3 如果顺序表中没有目标值的元素则终止函数</span><br><span class="line">    if(temp==-1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;destval [%d] is not found\n&quot;,destVal);</span><br><span class="line">        return  false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.4 如果顺序表中有目标值的元素，则将该元素的后继元素向前移动一位</span><br><span class="line">    for (int i = temp; i &lt; manager-&gt;last; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i] = manager-&gt;Addr[i+1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.5 由于删掉一个元素，则顺序表有效元素下标减一</span><br><span class="line">    manager-&gt;last--;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历顺序表（sqList-print）"><a href="#遍历顺序表（sqList-print）" class="headerlink" title="遍历顺序表（sqList_print）"></a>遍历顺序表（sqList_print）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//5 遍历顺序表中的元素</span><br><span class="line">void sqList_print (sqList_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;=manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Element[%d]=%d\n&quot;,i,manager-&gt;Addr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //1 创建顺序表</span><br><span class="line">    sqList_t *manager = sqList_Create(10);</span><br><span class="line"></span><br><span class="line">    //2 向顺序表尾部插入新元素</span><br><span class="line">    sqList_endAdd (manager,5);</span><br><span class="line">    sqList_endAdd (manager,2);</span><br><span class="line">    sqList_endAdd (manager,1);</span><br><span class="line">    sqList_endAdd (manager,4);</span><br><span class="line">    sqList_endAdd (manager,6);</span><br><span class="line"></span><br><span class="line">    //3 遍历顺序表</span><br><span class="line">    sqList_print (manager);     //5 2 1 4 6</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //4 向顺序表头部插入新元素</span><br><span class="line">    sqList_headAdd (manager,8);</span><br><span class="line">    sqList_headAdd (manager,4);</span><br><span class="line">    sqList_headAdd (manager,8);</span><br><span class="line">    sqList_headAdd (manager,8);</span><br><span class="line"></span><br><span class="line">    //5 遍历顺序表</span><br><span class="line">    sqList_print (manager);     //8 8 4 8 5 2 1 4 6</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //6 删除顺序表中元素</span><br><span class="line">    sqList_delAdd (manager,20);</span><br><span class="line">    sqList_delAdd (manager,5);</span><br><span class="line">    sqList_delAdd (manager,1);</span><br><span class="line">    sqList_delAdd (manager,6);</span><br><span class="line"></span><br><span class="line">    //7 遍历顺序表</span><br><span class="line">    sqList_print (manager);     //8 8 4 8 2 4</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Element[0]=5</span><br><span class="line">Element[1]=2</span><br><span class="line">Element[2]=1</span><br><span class="line">Element[3]=4</span><br><span class="line">Element[4]=6</span><br><span class="line"></span><br><span class="line">Element[0]=8</span><br><span class="line">Element[1]=8</span><br><span class="line">Element[2]=4</span><br><span class="line">Element[3]=8</span><br><span class="line">Element[4]=5</span><br><span class="line">Element[5]=2</span><br><span class="line">Element[6]=1</span><br><span class="line">Element[7]=4</span><br><span class="line">Element[8]=6</span><br><span class="line"></span><br><span class="line">destval [20] is not found</span><br><span class="line">Element[0]=8</span><br><span class="line">Element[1]=8</span><br><span class="line">Element[2]=4</span><br><span class="line">Element[3]=8</span><br><span class="line">Element[4]=2</span><br><span class="line">Element[5]=4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//构造顺序表记录参数(顺序表的首地址 顺序表的容量 顺序表的有效元素的下标)</span><br><span class="line">typedef struct sequenceList &#123;</span><br><span class="line">    dataType_t *Addr;       //顺序表的首地址</span><br><span class="line">    unsigned int size;      //顺序表的容量</span><br><span class="line">    int last;               //顺序表的有效元素的下标</span><br><span class="line">&#125; sqList_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//1 创建顺序表并对顺序表进行初始化</span><br><span class="line">sqList_t *sqList_Create(unsigned int size)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 利用calloc为顺序表的管理结构体申请堆内存</span><br><span class="line">    sqList_t *manager = (sqList_t*)calloc(1,sizeof (manager));</span><br><span class="line"></span><br><span class="line">    if(NULL == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for manager is failed&quot;);</span><br><span class="line">        exit(-1);       //程序终止</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 为所有元素申请堆内存 calloc,并完成错误处理</span><br><span class="line">    manager-&gt;Addr = (dataType_t*)calloc(size,sizeof(dataType_t));</span><br><span class="line"></span><br><span class="line">    if(NULL == manager-&gt;Addr)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for element is failed&quot;);</span><br><span class="line">        free(manager);  //释放内存</span><br><span class="line">        exit(-1);       //程序终止</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.3 对管理顺序表的结构体进行初始化（元素容量 最后元素下标）</span><br><span class="line">    manager-&gt;size = size; //对顺序表的容量进行初始化</span><br><span class="line">    manager-&gt;last = -1;   //由于顺序表为空，则最后元素下标初值为-1</span><br><span class="line"></span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//判断顺序表是否以满</span><br><span class="line">bool sqList_IsFull(sqList_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;last+1 == manager-&gt;size) ? true : false;</span><br><span class="line">//        if(manager-&gt;last+1 == manager-&gt;size)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return ture;</span><br><span class="line">//    &#125;</span><br><span class="line">//    return false;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//2 向顺序表的尾部插入元素</span><br><span class="line">bool sqList_endAdd (sqList_t *manager,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 判断顺序表是否以满</span><br><span class="line">    if(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;sequenceList is Full!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 若顺序表有空闲空间，则把新元素添加到顺序表尾部</span><br><span class="line">/*    manager-&gt;last++;</span><br><span class="line">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span><br><span class="line">    manager-&gt;Addr[++manager-&gt;last] = data;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//3 向顺序表的头部插入元素</span><br><span class="line">bool sqList_headAdd (sqList_t *manager,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 判断顺序表是否以满</span><br><span class="line">    if(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;sequenceList is Full!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 若顺序表有空闲空间，则把新元素添加到顺序表头部 顺序表中所以元素向后移动1个单位</span><br><span class="line">/*    manager-&gt;last++;</span><br><span class="line">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span><br><span class="line">    for(int i = manager-&gt;last;i &gt;= 0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i+1] = manager-&gt;Addr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.3 把新元素放到顺序表的头部,并且更新管理结构体中的元素下标+1</span><br><span class="line">    manager-&gt;Addr[0] = data;</span><br><span class="line">    manager-&gt;last++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//判断顺序表是否为空</span><br><span class="line">bool sqList_IsEmpty(sqList_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    return (manager-&gt;last == -1) ? true : false;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//4 向顺序表删除元素</span><br><span class="line">bool sqList_delAdd (sqList_t *manager,dataType_t destVal)</span><br><span class="line">&#123;</span><br><span class="line">    int temp=-1;     //记录需要删除的下标</span><br><span class="line"></span><br><span class="line">    //4.1 判断顺序表是否为空</span><br><span class="line">    if(sqList_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;SequenceList is Empty!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 需要查找目标值是否在顺序表中</span><br><span class="line">    for(int i=0;i &lt;= manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果目标值与顺序表中的值相同</span><br><span class="line">        if(destVal == manager-&gt;Addr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            temp=i;     //把目标元素的下标备份到变量temp中</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.3 如果顺序表中没有目标值的元素则终止函数</span><br><span class="line">    if(temp==-1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;destval [%d] is not found\n&quot;,destVal);</span><br><span class="line">        return  false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.4 如果顺序表中有目标值的元素，则将该元素的后继元素向前移动一位</span><br><span class="line">    for (int i = temp; i &lt; manager-&gt;last; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i] = manager-&gt;Addr[i+1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.5 由于删掉一个元素，则顺序表有效元素下标减一</span><br><span class="line">    manager-&gt;last--;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//5 遍历顺序表中的元素</span><br><span class="line">void sqList_print (sqList_t *manager)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;=manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Element[%d]=%d\n&quot;,i,manager-&gt;Addr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //1 创建顺序表</span><br><span class="line">    sqList_t *manager = sqList_Create(10);</span><br><span class="line"></span><br><span class="line">    //2 向顺序表尾部插入新元素</span><br><span class="line">    sqList_endAdd (manager,5);</span><br><span class="line">    sqList_endAdd (manager,2);</span><br><span class="line">    sqList_endAdd (manager,1);</span><br><span class="line">    sqList_endAdd (manager,4);</span><br><span class="line">    sqList_endAdd (manager,6);</span><br><span class="line"></span><br><span class="line">    //3 遍历顺序表</span><br><span class="line">    sqList_print (manager);     //5 2 1 4 6</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //4 向顺序表头部插入新元素</span><br><span class="line">    sqList_headAdd (manager,8);</span><br><span class="line">    sqList_headAdd (manager,4);</span><br><span class="line">    sqList_headAdd (manager,8);</span><br><span class="line">    sqList_headAdd (manager,8);</span><br><span class="line"></span><br><span class="line">    //5 遍历顺序表</span><br><span class="line">    sqList_print (manager);     //8 8 4 8 5 2 1 4 6</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //6 删除顺序表中元素</span><br><span class="line">    sqList_delAdd (manager,20);</span><br><span class="line">    sqList_delAdd (manager,5);</span><br><span class="line">    sqList_delAdd (manager,1);</span><br><span class="line">    sqList_delAdd (manager,6);</span><br><span class="line"></span><br><span class="line">    //7 遍历顺序表</span><br><span class="line">    sqList_print (manager);     //8 8 4 8 2 4</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构—顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构三（双向链表DoubleLinkedList）</title>
      <link href="/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/"/>
      <url>/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个双向链表实现对双向链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历双向链表</p><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表" title="双向链表"></p><p>More info: <a href="https://github.com/gybpersist/DoubleLinkedList">DoubleLinkedList</a></p><h2 id="构造双向链表（DoubleLinkedList）"><a href="#构造双向链表（DoubleLinkedList）" class="headerlink" title="构造双向链表（DoubleLinkedList）"></a>构造双向链表（DoubleLinkedList）</h2><h3 id="构造双向链表的结点-双向链表中所有结点的数据类型应该是相同的"><a href="#构造双向链表的结点-双向链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造双向链表的结点 双向链表中所有结点的数据类型应该是相同的"></a>构造双向链表的结点 双向链表中所有结点的数据类型应该是相同的</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">typedef struct DoubleLinkedList &#123;</span><br><span class="line">    dataType_t data;                 //双向链表的数据域</span><br><span class="line">    struct DoubleLinkedList *prev;      //双向链表的后继指针域</span><br><span class="line">    struct DoubleLinkedList *next;      //双向链表的前驱指针域</span><br><span class="line">&#125; DoubleLList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（DoubleLList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（DoubleLList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（DoubleLList_Create）"></a>创建一个空链表，空链表应该有一个头结点（DoubleLList_Create）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t* DoubleLList_Create(void)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 创建一个头结点并给头结点申请内存</span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)calloc(1,sizeof (DoubleLList_t));</span><br><span class="line">    if(Head == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for Head is Failed!\n&quot;);</span><br><span class="line">        exit(-1);       //退出程序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 对头结点进行初始化</span><br><span class="line">    Head-&gt;prev = NULL;</span><br><span class="line">    Head-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //1.3 把头结点地地址返回</span><br><span class="line">    return Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleLList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleLList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleLList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleLList_NewNode）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t *DoubleLList_NewNode(dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 创建一个新结点并给新结点申请内存</span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) calloc(1, sizeof(DoubleLList_t));</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 对新结点进行初始化（数据域 指针域2个）</span><br><span class="line">    NewNode-&gt;prev = NULL;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //2.3 把新结点地地址返回</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（DoubleLList-HeadInsert）"><a href="#头插（DoubleLList-HeadInsert）" class="headerlink" title="头插（DoubleLList_HeadInsert）"></a>头插（DoubleLList_HeadInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleLList_HeadInsert(DoubleLList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.3 如果链表为非空，则把新结点插入到链表头部</span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line">    NewNode-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（DoubleLList-TailInsert）"><a href="#尾插（DoubleLList-TailInsert）" class="headerlink" title="尾插（DoubleLList_TailInsert）"></a>尾插（DoubleLList_TailInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleLList_TailInsert(DoubleLList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.3 如果链表为非空，则把新结点插入到链表尾部</span><br><span class="line">    //对链表的头结点进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line">    while (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（DoubleLList-DestInsert）"><a href="#指定插入（DoubleLList-DestInsert）" class="headerlink" title="指定插入（DoubleLList_DestInsert）"></a>指定插入（DoubleLList_DestInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleLList_DestInsert(DoubleLList_t *Head,dataType_t destval,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span><br><span class="line">    //对链表的首结点进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != NULL &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        //把结点的直接后继作为新的结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        if(Phead == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.4 说明找到目标结点，则把新结点加入到目标结点后面</span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（DoubleLList-Print）"><a href="#遍历链表（DoubleLList-Print）" class="headerlink" title="遍历链表（DoubleLList_Print）"></a>遍历链表（DoubleLList_Print）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleLList_Print(DoubleLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //对链表的头结点的地址进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    //判断当前链表是否为空，为空则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Current linkedList is empty!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断当前链表不为空则继续遍历</span><br><span class="line">    //记录第几个</span><br><span class="line">    int i=0;</span><br><span class="line">    while (Phead-&gt;next != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        //输出头结点的直接后继的数据域</span><br><span class="line">        printf(&quot;Date[%d] = %d\n&quot;,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除首结点（DoubleLList-HeadDel）"><a href="#头删-删除首结点（DoubleLList-HeadDel）" class="headerlink" title="头删 删除首结点（DoubleLList_HeadDel）"></a>头删 删除首结点（DoubleLList_HeadDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleLList_HeadDel(DoubleLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //7.1 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7.2 对链表的首结点进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //7.3 链表非空 删除首结点</span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">    //7.4 原先首结点的 next指向NULL，并释放首结点的内存</span><br><span class="line">    Phead-&gt;next = NULL;</span><br><span class="line">    Phead-&gt;prev = NULL;</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（DoubleLList-TailDel）"><a href="#尾删-删除尾结点（DoubleLList-TailDel）" class="headerlink" title="尾删 删除尾结点（DoubleLList_TailDel）"></a>尾删 删除尾结点（DoubleLList_TailDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bool DoubleLList_TailDel(DoubleLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //8.1 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //8.2 记录当前结点的地址</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //记录当前结点的直接前驱</span><br><span class="line">    DoubleLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    //8.3 链表非空 删除尾结点</span><br><span class="line">    while (Phead-&gt;next != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DoubleLList_t *Head = DoubleLList_Create();            //创建链表</span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadInsert(Head,5);            //头插</span><br><span class="line">    DoubleLList_HeadInsert(Head,8);</span><br><span class="line">    DoubleLList_HeadInsert(Head,1);</span><br><span class="line">    DoubleLList_HeadInsert(Head,6);</span><br><span class="line">    DoubleLList_HeadInsert(Head,3);</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        //3 6 1 8 5</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailInsert(Head,4);               //尾插</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        //3 6 1 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    DoubleLList_DestInsert(Head,1,9);     //destval后面插入</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         //遍历链表 3 6 1 9 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadDel(Head);                        //头删</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         //遍历链表 6 1 9 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailDel(Head);                        //尾删</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         //遍历链表 6 1 9 8 5</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line"></span><br><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line">Date[6] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 3</span><br><span class="line">Date[2] = 6</span><br><span class="line">Date[3] = 1</span><br><span class="line">Date[4] = 9</span><br><span class="line">Date[5] = 8</span><br><span class="line">Date[6] = 5</span><br><span class="line">Date[7] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 6</span><br><span class="line">Date[2] = 1</span><br><span class="line">Date[3] = 9</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line">Date[6] = 4</span><br><span class="line"></span><br><span class="line">Date[1] = 6</span><br><span class="line">Date[2] = 1</span><br><span class="line">Date[3] = 9</span><br><span class="line">Date[4] = 8</span><br><span class="line">Date[5] = 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//类型别名</span><br><span class="line">typedef int dataType_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//构造双向链表的结点 双向链表中所以结点的数据类型应该是相同的</span><br><span class="line">typedef struct DoubleLinkedList &#123;</span><br><span class="line">    dataType_t data;                 //双向链表的数据域</span><br><span class="line">    struct DoubleLinkedList *prev;      //双向链表的后继指针域</span><br><span class="line">    struct DoubleLinkedList *next;      //双向链表的前驱指针域</span><br><span class="line">&#125; DoubleLList_t;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//1 创建一个空链表，空链表应该有一个头结点</span><br><span class="line">DoubleLList_t* DoubleLList_Create(void)</span><br><span class="line">&#123;</span><br><span class="line">    //1.1 创建一个头结点并给头结点申请内存</span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)calloc(1,sizeof (DoubleLList_t));</span><br><span class="line">    if(Head == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for Head is Failed!\n&quot;);</span><br><span class="line">        exit(-1);       //退出程序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.2 对头结点进行初始化</span><br><span class="line">    Head-&gt;prev = NULL;</span><br><span class="line">    Head-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //1.3 把头结点地地址返回</span><br><span class="line">    return Head;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">DoubleLList_t *DoubleLList_NewNode(dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //2.1 创建一个新结点并给新结点申请内存</span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) calloc(1, sizeof(DoubleLList_t));</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;calloc memory for NewNode is Failed!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.2 对新结点进行初始化（数据域 指针域2个）</span><br><span class="line">    NewNode-&gt;prev = NULL;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //2.3 把新结点地地址返回</span><br><span class="line">    return NewNode;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//3 在链表中 头插</span><br><span class="line">bool DoubleLList_HeadInsert(DoubleLList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = NULL; // 新节点是链表最后一个节点，next 指针置为 NULL</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.3 如果链表为非空，则把新结点插入到链表头部</span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//4 在链表中 尾部插</span><br><span class="line">bool DoubleLList_TailInsert(DoubleLList_t *Head,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.3 如果链表为非空，则把新结点插入到链表尾部</span><br><span class="line">    //对链表的头结点进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line">    while (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//5 在链表中 指定插入</span><br><span class="line">bool DoubleLList_DestInsert(DoubleLList_t *Head,dataType_t destval,dataType_t data)</span><br><span class="line">&#123;</span><br><span class="line">    //5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    if(NewNode == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Can not insert new node!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.2 判断链表是否为空，如果为则直接插入</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span><br><span class="line">    //对链表的首结点进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    while (Phead != NULL &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        //把结点的直接后继作为新的结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        if(Phead == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.4 说明找到目标结点，则把新结点加入到目标结点后面</span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//6 遍历链表</span><br><span class="line">bool DoubleLList_Print(DoubleLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //对链表的头结点的地址进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    //判断当前链表是否为空，为空则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Current linkedList is empty!\n&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断当前链表不为空则继续遍历</span><br><span class="line">    //记录第几个</span><br><span class="line">    int i=0;</span><br><span class="line">    while (Phead-&gt;next != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        //输出头结点的直接后继的数据域</span><br><span class="line">        printf(&quot;Date[%d] = %d\n&quot;,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//7 头删 删除首结点</span><br><span class="line">bool DoubleLList_HeadDel(DoubleLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //7.1 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7.2 对链表的首结点进行备份</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //7.3 链表非空 删除首结点</span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">    //7.4 原先首结点的 next指向NULL，并释放首结点的内存</span><br><span class="line">    Phead-&gt;next = NULL;</span><br><span class="line">    Phead-&gt;prev = NULL;</span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">//8 尾删 删除尾结点</span><br><span class="line">bool DoubleLList_TailDel(DoubleLList_t *Head)</span><br><span class="line">&#123;</span><br><span class="line">    //8.1 判断判断链表是否为空，如果为则直接退出</span><br><span class="line">    if(Head-&gt;next == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //8.2 记录当前结点的地址</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    //记录当前结点的直接前驱</span><br><span class="line">    DoubleLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    //8.3 链表非空 删除尾结点</span><br><span class="line">    while (Phead-&gt;next != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        //把头结点的直接后继作为新的头结点 指针向后移一位</span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    free(Phead);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">///////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DoubleLList_t *Head = DoubleLList_Create();            //创建链表</span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadInsert(Head,5);            //头插</span><br><span class="line">    DoubleLList_HeadInsert(Head,8);</span><br><span class="line">    DoubleLList_HeadInsert(Head,1);</span><br><span class="line">    DoubleLList_HeadInsert(Head,6);</span><br><span class="line">    DoubleLList_HeadInsert(Head,3);</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        //3 6 1 8 5</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailInsert(Head,4);               //尾插</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        //3 6 1 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    DoubleLList_DestInsert(Head,1,9);     //destval后面插入</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         //遍历链表 3 6 1 9 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadDel(Head);                        //头删</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         //遍历链表 6 1 9 8 5 4</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailDel(Head);                        //尾删</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         //遍历链表 6 1 9 8 5</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构—双向链表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
