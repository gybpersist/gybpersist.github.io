<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>汇总</title>
      <link href="/2025/05/21/%E6%B1%87%E6%80%BB/%E6%B1%87%E6%80%BB/"/>
      <url>/2025/05/21/%E6%B1%87%E6%80%BB/%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="第01章-C语言入门"><a href="#第01章-C语言入门" class="headerlink" title="第01章_C语言入门"></a>第01章_C语言入门</h1><h2 id="本章专题脉络"><a href="#本章专题脉络" class="headerlink" title="本章专题脉络"></a>本章专题脉络</h2><p> <img src="/img/images/%E7%AC%AC1%E7%AB%A0_C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8.png" alt="第1章_C语言入门" title="第1章_C语言入门"></p><h2 id="1、初识计算机语言"><a href="#1、初识计算机语言" class="headerlink" title="1、初识计算机语言"></a>1、初识计算机语言</h2><h3 id="1-1-计算机语言是什么"><a href="#1-1-计算机语言是什么" class="headerlink" title="1.1 计算机语言是什么"></a>1.1 计算机语言是什么</h3><ul><li><p><strong>人类语言</strong>：是人与人之间用于沟通的一种方式。例如：中国人与中国人用普通话沟通。而中国人要和英国人交流，可以使用普通话或英语。</p></li><li><p><strong>计算机编程语言</strong>，就是人与计算机交流的方式。人们可以使用<code>编程语言</code>对计算机下达<code>命令</code>，让计算机完成人们需要的功能。</p><ul><li>计算机语言有很多种。如：C 、C++、Java、Go、JavaScript、Python，Scala等。</li></ul></li></ul><blockquote><p>体会：语言 &#x3D; 语法 + 逻辑</p></blockquote><h3 id="1-2-计算机语言简史"><a href="#1-2-计算机语言简史" class="headerlink" title="1.2 计算机语言简史"></a>1.2 计算机语言简史</h3><ul><li><p><strong>第一代：机器语言（相当于人类的石器时代）</strong></p><ul><li><p>1946年2月14日，世界上第一台计算机<code>ENAC</code>诞生，使用的是最原始的<code>穿孔卡片</code>。这种卡片上使用的是用<code>二进制代码</code>表示的语言，与人类语言差别极大，这种语言就称为<code>机器语言</code>。比如一段典型的机器码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.0000,0000,000000010000 代表 LOAD A, 16</span><br><span class="line">2.0000,0001,000000000001 代表 LOAD B, 1</span><br><span class="line">3.0001,0001,000000010000 代表 STORE B, 16</span><br></pre></td></tr></table></figure></li><li><p>这种语言本质上是计算机能识别的<code>唯一语言</code>，人类很难理解。可以大胆想象”<code>此时的程序员99.9%都是异类！</code>“</p><p><img src="/img/images/image-20220309223406537.png" alt="image-20220309223406537"></p></li></ul></li><li><p><strong>第二代：汇编语言（相当于人类的青铜&amp;铁器时代）</strong></p><ul><li><p>使用英文缩写的<code>助记符</code>来表示基本的操作，这些助记符构成了汇编语言的基础。比如：<code>LOAD</code>、<code>MOVE</code>等，使人更容易使用。因此，汇编语言也称为<code>符号语言</code>。</p></li><li><p>优点：能编写<code>高效率</code>的程序。</p></li><li><p>缺点：汇编语言是<code>面向机器的</code>，不同计算机会有不同的汇编语言，程序不易移植。</p><p><img src="/img/images/1689152350231.png" alt="1689152350231"></p></li><li><p>目前仍然应用于工业电子编程领域、软件的加密解密、计算机病毒分析等。</p></li></ul></li><li><p><strong>第三代：高级语言（相当于人类的信息时代）</strong></p><ul><li><p>高级语言，是一种<code>接近于人们使用习惯</code>的程序设计语言。它允许程序员使用<code>接近日常英语</code>的指令来编写程序，程序中的符号和算式也与<code>日常用的数学式子</code>差不多，接近于自然语言和数学语言，容易为人们掌握。比如：</p><p><img src="/img/images/1689152910950.png" alt="1689152910950"></p></li><li><p>高级语言<code>独立于计算机硬件</code>，有一定的通用性；计算机不能直接识别和执行用高级语言编写的程序，需要使用<strong>编译器或者解释器</strong>，<code>转换为机器语言</code>才能被识别和执行。</p><p><img src="/img/images/1689153225780.png" alt="1689153225780"></p></li><li><p>使用普遍的高级语言有Fortran、ALGOL、Basic、COBOL、LISP、Pascal、PROLOG、C、C++、VC、VB、Delphi、Java等。</p></li></ul></li></ul><h2 id="2、初识C语言"><a href="#2、初识C语言" class="headerlink" title="2、初识C语言"></a>2、初识C语言</h2><h3 id="2-1-C语言的由来"><a href="#2-1-C语言的由来" class="headerlink" title="2.1 C语言的由来"></a>2.1 C语言的由来</h3><p><strong>C 语言最初是作为 Unix 系统的开发工具而发明的。</strong></p><p>1969年，美国贝尔实验室的肯·汤普森（Ken Thompson）与丹尼斯·里奇（Dennis Ritchie）一起开发了Unix 操作系统。Unix 是用<code>汇编语言</code>写的，依赖于计算机硬件。为了程序的<code>可读性</code>和<code>可移植性</code>，他们决定使用高级语言重写。但是，当时的高级语言无法满足他们的要求，汤普森就在 BCPL 语言的基础上发明了 <code>B 语言</code>。</p><p>1972年，丹尼斯·里奇（Dennis Ritchie）在 B 语言的基础上重新设计了一种新语言，这种新语言取代了 B 语言，称为<code> C 语言</code>。</p><p>1973年，<code>整个 Unix 系统都使用 C 语言重写</code>。</p><p><img src="/img/images/image-20230821142911092.png" alt="image-20230821142911092"></p><p>此后，这种语言快速流传，广泛用于各种操作系统和系统软件的开发。如UNIX、MS-DOS、Microsoft Windows及Linux等。</p><p><img src="/img/images/image-20230808143350533.png" alt="image-20230808143350533"></p><p>1988年，美国国家标准协会（ANSI）正式将<code> C语言标准化</code>，标志着 C 语言开始稳定和规范化。</p><h3 id="2-2-为什么要学习C语言"><a href="#2-2-为什么要学习C语言" class="headerlink" title="2.2 为什么要学习C语言"></a>2.2 为什么要学习C语言</h3><p>1、<strong>C语言具有可移植性好、跨平台的特点</strong>，用C编写的代码可以在不同的操作系统和硬件平台上编译和运行。</p><ul><li>C 语言的原始设计目的，是将 Unix 系统移植到其他计算机架构，这使得它从一开始就非常注重可移植性。</li></ul><p>2、**C语言在许多领域应用广泛。**掌握C语言可以让你有更多就业机会。</p><ul><li><code>操作系统</code>：C 广泛用于开发操作系统，如 Unix、Linux 和 Windows。</li><li><code>嵌入式系统</code>：C 是一种用于开发嵌入式系统（如微控制器、微处理器和其他电子设备）的流行语言。</li><li><code>系统软件</code>：C用于开发设备驱动程序、编译器和汇编器等系统软件。</li><li><code>网络</code>：C 语言广泛用于开发网络应用程序，例如 Web 服务器、网络协议和网络驱动程序。</li><li><code>数据库系统</code>：C 用于开发数据库系统，例如 Oracle、MySQL 和 PostgreSQL。</li><li><code>游戏</code>：由于 C 能够处理低级硬件交互，因此经常用于开发计算机游戏。</li><li><code>人工智能</code>：C 用于开发人工智能和机器学习应用程序，例如神经网络和深度学习算法。</li><li><code>科学应用</code>：C 用于开发科学应用程序，例如仿真软件和数值分析工具。</li><li><code>金融应用</code>：C用于开发股票市场分析和交易系统等金融应用。</li></ul><p>3、C 语言能够直接对硬件进行操作、管理内存、跟操作系统对话，这使得它是一种非常接近底层的语言，非常适合写需要<strong>跟硬件交互、有极高性能要求的程序</strong>。</p><p>4、<strong>学习C语言有助于快速上手其他编程语言</strong>，比如C++（原先是C语言的一个扩展，在C语言的基础上嫁接了面向对象编程）、C#、Java、PHP、Javascript、Perl等。这些语言都继承或深受C语言的影响和启发。</p><p>5、C 语言长盛不衰。至今，<strong>依然是最广泛使用、最流行的编程语言之一</strong>。包括很多大学将C语言作为计算机教学的入门语言，拥有庞大而活跃的用户社区，这意味着有许多资源和库可供开发人员使用。</p><h3 id="2-3-计算机语言排行榜"><a href="#2-3-计算机语言排行榜" class="headerlink" title="2.3 计算机语言排行榜"></a>2.3 计算机语言排行榜</h3><p>TIOBE （<a href="https://www.tiobe.com/tiobe-index/%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%81%E8%A1%8C%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%8E%92%E8%A1%8C%EF%BC%8C%E6%AF%8F%E6%9C%88%E6%9B%B4%E6%96%B0%E3%80%82%E6%8E%92%E5%90%8D%E6%9D%83%E9%87%8D%E5%9F%BA%E4%BA%8E%E4%B8%96%E7%95%8C%E8%8C%83%E5%9B%B4%E5%86%85">https://www.tiobe.com/tiobe-index/）是一个流行编程语言排行，每月更新。排名权重基于世界范围内</a> 工程师数量，Google、Bing、Yahoo! 、Wikipedia、Amazon、Youtube和百度这些主流的搜索引擎，也将作为排名权重的参考指标。</p><p><img src="/img/images/image-20230821142412443.png" alt="image-20230821142412443"></p><p>计算机走势图：</p><p><img src="/img/images/image-20230821142441945.png" alt="image-20230821142441945"></p><h3 id="2-4-网友一言话C"><a href="#2-4-网友一言话C" class="headerlink" title="2.4 网友一言话C"></a>2.4 网友一言话C</h3><p><a href="https://www.nowcoder.com/stack/209">https://www.nowcoder.com/stack/209</a></p><p><img src="/img/images/image-20230819162927908.png" alt="image-20230819162927908"></p><h3 id="2-5-C语言的版本选择"><a href="#2-5-C语言的版本选择" class="headerlink" title="2.5 C语言的版本选择"></a>2.5 C语言的版本选择</h3><p>随着微型计算机的日益普及，出现了许多C语言版本。</p><p><strong>版本1：K＆R C</strong></p><p>K&amp;R C 指的是 C 语言的原始版本。1978年，C 语言的发明者布莱恩·柯林（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）合写了一本著名的教材《C 编程语言》（The C programming language）。</p><p>由于 C 语言还没有成文的语法标准，这本书就成了公认标准，以两位作者的姓氏首字母作为版本简称“K&amp;R C”。</p><p><strong>版本2：ANSI C（又称 C89 或 C90）</strong></p><p>C 语言的原始版本非常简单，对很多情况的描述非常模糊，加上 C 语法依然在快速发展，要求将 C 语言标准化的呼声越来越高。</p><p>1989年，美国国家标准协会（ANSI）制定了一套 C 语言标准，并于次年被国际标准化组织（ISO）通过。它被称为“ANSI C”，也可以按照发布年份，称为“C89 或 C90”。</p><p><strong>版本3：C99</strong></p><p>C 语言标准的第一次<code>大型修订</code>，发生在1999年，增加了许多语言特性，比如双斜杠（ &#x2F;&#x2F; ）的注释语法，可变长度数组、灵活的数组成员、复数、内联函数和指定的初始值设定项。这个版本称为 C99，<code>是目前最流行的 C 版本</code>。</p><p><strong>版本4：C11</strong></p><p>2011年，标准化组织再一次对C 语言进行修订，增加了_Generic、static_assert 和原子类型限定符。这个版本称为C11。</p><blockquote><p>需要强调的是，修订标准的原因不是因为原标准不能用，而是需要跟进新的技术。</p></blockquote><p><strong>版本5：C17</strong></p><p>C11 标准在2017年进行了修补，但发布是在2018年。新版本只是解决了 C11 的一些缺陷，没有引入任何新功能。这个版本称为 C17。</p><p><strong>版本6：C23</strong></p><p>2023年预计发布，计划进一步增强安全性，消除实现定义的行为，引入模块化语言概念等新特性，使C语言在安全和可靠性方面有重大提高。</p><h2 id="3、第一个C程序的编写-编译-运行"><a href="#3、第一个C程序的编写-编译-运行" class="headerlink" title="3、第一个C程序的编写-&gt;编译-&gt;运行"></a>3、第一个C程序的编写-&gt;编译-&gt;运行</h2><h3 id="3-1-步骤1：HelloWorld的编写"><a href="#3-1-步骤1：HelloWorld的编写" class="headerlink" title="3.1 步骤1：HelloWorld的编写"></a>3.1 步骤1：HelloWorld的编写</h3><p>C 语言的源代码文件，以<strong>后缀名 .c 结尾</strong>。下面是一个简单的 C 程序 <code>Hello.c</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>              </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>                  </span><br><span class="line">&#123;                               </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,world!!\n&quot;</span>); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-步骤2：编译器的安装与配置"><a href="#3-2-步骤2：编译器的安装与配置" class="headerlink" title="3.2 步骤2：编译器的安装与配置"></a>3.2 步骤2：编译器的安装与配置</h3><p>C 语言是一种<code>编译型语言</code>，源码都是<code>文本文件</code>，本身无法执行。必须通过编译器，生成二进制的可执行文件，才能执行。</p><p>目前，最常见的 C 语言编译器是自由软件基金会推出的 <code>GCC 编译器</code>，可以免费使用。Linux 和 Mac 系统可以直接安装 GCC，Windows 系统可以安装 <code>MinGW</code>。</p><blockquote><p>补充知识：MinGW和GCC的区别：</p><p>GCC是一个跨平台的编译器集合，可用于多种操作系统和处理器架构，包括Windows；而MinGW是GCC在Windows平台上的移植版本，主要用于在Windows上本地编译C和C++代码。</p></blockquote><p>在Windows下，MinGW的详细安装和配置见<code>《第01章附录：MinGW编译器的安装和配置.md》</code>。</p><h3 id="3-3-步骤3：编译和运行"><a href="#3-3-步骤3：编译和运行" class="headerlink" title="3.3 步骤3：编译和运行"></a>3.3 步骤3：编译和运行</h3><p>编译器将代码从文本翻译成二进制指令的过程，就称为编译阶段，又称为“编译时”（compile time），跟运行阶段（又称为“运行时”）相区分。</p><p>假设你已经安装好了 GCC 编译器，可以通过<code>win+r</code>打开cmd命令行，在Hello.c文件所在目录下执行下面的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc Hello.c</span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20230821203629981.png" alt="image-20230821203629981"></p><p>上面命令使用 gcc 编译器，将源文件 Hello.c 编译成二进制代码。</p><p>运行这个命令以后，默认会在当前目录下生成一个编译产物文件 a.exe。执行该文件，就会在屏幕上输出 Hello World 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; a.exe</span><br><span class="line">hello,world!!</span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20230821203807040.png" alt="image-20230821203807040"></p><p><strong>GCC 的 -o 参数（output 的缩写）可以指定编译产物的文件名。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -o Hello Hello.c</span><br></pre></td></tr></table></figure><img src="/img/images/image-20230821204057346.png" alt="image-20230821204057346" style="zoom:80%;" /><p>上面命令的 <code>-o Hello</code> 指定，编译得到的可执行文件名为 Hello.exe ，取代默认的 a.exe。执行该文件，也会得到同样的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Hello.exe</span><br><span class="line">hello,world!!</span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20230821204306119.png" alt="image-20230821204306119"></p><p><strong>GCC 的 <code>-std= 参数</code>（standard 的缩写）还可以指定按照哪个 C 语言的标准进行编译。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -std=c99 Hello.c</span><br></pre></td></tr></table></figure><p>上面命令指定按照 C99 标准进行编译。</p><h2 id="4、IDE的使用"><a href="#4、IDE的使用" class="headerlink" title="4、IDE的使用"></a>4、IDE的使用</h2><p>IDE(Integrated Development Environment，集成开发环境)：相较于文本开发工具，IDE可以把代码编写，编译，执行，调试等多种功能综合到一起的开发工具。</p><h3 id="4-1-开发工具介绍"><a href="#4-1-开发工具介绍" class="headerlink" title="4.1 开发工具介绍"></a>4.1 开发工具介绍</h3><h4 id="方式1：本地安装的IDE工具"><a href="#方式1：本地安装的IDE工具" class="headerlink" title="方式1：本地安装的IDE工具"></a>方式1：本地安装的IDE工具</h4><p><strong>1. Code::Block</strong></p><p>Code::Block是一个免费的跨平台IDE，它支持C、C++和Fortan程序的开发。Code::Block的最大特点是它支持通过插件的方式对IDE自身功能进行扩展，这使得Code::Block具有很强的灵活性，方便用户使用。</p><p>官网地址：<a href="https://www.codeblocks.org/">https://www.codeblocks.org</a></p><p><strong>2. Microsoft Visual C++ 2010</strong></p><p>Visual C++ 2010，简称VC2010，是由微软开发的独立的、免费的 C&#x2F;C++ 编译工具，与Visual Basic等并列，最后微软将它们整合在一起组成了Visual Studio。</p><p>Visual C++从发布起到现在已经有10个大版本了，这里介绍的Visual C++ 2010就是Visual C++ 10，简称VC10。上朔10多年发布的Visual C++ 6.0，被称为史上最经典的VC，现在有很多企业还在用它，大量的教材基于这个版本的VC来写的。但VC6比较弱，被淘汰是迟早的。</p><p><strong>3. Microsoft Visual Studio</strong></p><p>Visual Studio（简称 VS）是由微软公司发布的集成开发环境。它包括了整个软件生命周期中所需要的大部分工具，如UML工具、代码管控工具、集成开发环境（IDE）等。</p><p>Visual Studio 支持 C&#x2F;C++、C#、F#、VB 等多种程序语言的开发和测试，可以用于生成Web应用程序，也可以生成桌面应用程序，功能十分强大。但下载和安装很可能耗时数小时，还可能会塞满磁盘。</p><p>Visual Studio 2019有三种版本：社区版(免费，不支持企业使用)，专业版(第一年1199美元&#x2F; 799美元续订)和企业版(第一年5999美元&#x2F;2569美元续订)。企业版拥有面向架构师的功能、高级调试和测试，这些功能是另两种SKU所没有的。</p><p>Visual Studio旨在成为世界上最好的IDE（集成开发环境），目前最新版本为 Visual Studio 2023。</p><blockquote><p>这就好像Office 2007是由Word 2007、Excel 2007、Access 2007等等组成的一个道理。其中Visual C++就是Visual Studio的一个重要的组成部分。</p></blockquote><p>官网地址：<a href="https://visualstudio.microsoft.com/">https://visualstudio.microsoft.com</a></p><p><strong>4. CLion</strong></p><p>CLion是一款由JetBrains推出的跨平台C&#x2F;C++集成开发环境（IDE），它具有智能编辑器、CMake构建支持、调试器、单元测试、代码分析等功能,可以极大提高C&#x2F;C++开发效率。</p><p>官网地址：<a href="https://www.jetbrains.com/clion">https://www.jetbrains.com/clion</a></p><h4 id="方式2：可在线使用的工具"><a href="#方式2：可在线使用的工具" class="headerlink" title="方式2：可在线使用的工具"></a>方式2：可在线使用的工具</h4><p>CodingGround: <a href="https://tutorialspoint.com/compile_c_online.php">https://tutorialspoint.com/compile_c_online.php</a></p><p><img src="/img/images/image-20230821153059391.png" alt="image-20230821153059391"></p><p>OnlineGDB: <a href="https://onlinegdb.com/online_c_compiler">https://onlinegdb.com/online_c_compiler</a></p><p><img src="/img/images/image-20230821153146970.png" alt="image-20230821153146970"></p><p>Lightly：<a href="https://cde2f3ce.lightly.teamcode.com/">https://cde2f3ce.lightly.teamcode.com/</a></p><p><img src="/img/images/image-20230821153237900.png" alt="image-20230821153237900"></p><h3 id="4-2-CLion的下载与安装"><a href="#4-2-CLion的下载与安装" class="headerlink" title="4.2 CLion的下载与安装"></a>4.2 CLion的下载与安装</h3><p>详细见<code>《第01章附录：C开发利器：CLion的使用.md》</code>。</p><h3 id="4-3-CLion中HelloWorld的执行"><a href="#4-3-CLion中HelloWorld的执行" class="headerlink" title="4.3 CLion中HelloWorld的执行"></a>4.3 CLion中HelloWorld的执行</h3><p>1）选择”New Project”：</p><img src="/img/images/1692686679397.png" alt="1692686679397" style="zoom:80%;" /><p>2）指定创建C可执行文件、工程目录，图中的“untitled1”需要修改为自己的工程名称。如下所示：</p><img src="/img/images/1692687949240.png" alt="1692687949240" style="zoom:80%;" /><p>3）选择C可执行文件，修改工程名称为demo1</p><img src="/img/images/1692687854607.png" alt="1692687854607" style="zoom:80%;" /><p>4）点击“Create”进行下一步，如图所示</p><img src="/img/images/1692688033686.png" alt="1692688033686" style="zoom:80%;" /><p>5）此处选择编译器，默认MinGW即可，点击“OK”按钮，如图所示，默认创建了main.c文件。</p><img src="/img/images/1692688090496.png" alt="1692688090496" style="zoom:60%;" /><p>6）点击执行按钮，如下所示</p><img src="/img/images/1692688278731.png" alt="1692688278731" style="zoom: 60%;" /><h3 id="4-4-C-程序运行机制"><a href="#4-4-C-程序运行机制" class="headerlink" title="4.4 C 程序运行机制"></a>4.4 C 程序运行机制</h3><p><strong>过程1：编辑</strong></p><p>编写C语言源程序代码，并以文件的形式存储到磁盘中。源程序文件以“<code>.c</code>”作为扩展名。</p><p><strong>过程2：编译</strong></p><p>将C语言源程序转换为<code>目标程序(或目标文件)</code>。如果程序没有错误，没有任何提示，就会生成一个扩展名为“<code>.obj</code>”的二进制文件。C语言中的每条可执行语句经过编译后最终都将被转换成二进制的机器指令。</p><p><strong>过程3：链接&#x2F;连接</strong></p><p>将编译形成的目标文件“.obj”和库函数及其他目录文件连接&#x2F;链接，形成统一的<code>可执行的</code>二进制文件“<code>.exe</code>”。</p><blockquote><p>为什么需要链接库文件呢？</p><p>因为我们的C程序中会使用 C程序库的内容，比如&lt;stdio.h&gt; 、&lt;stdlib.h&gt; 中的函数printf()、system()等，这些函数不是程序员自己写的，而是C程序库中提供的，因此需要链接。链接后，生成的.exe 文件，比obj 文件大了很多。</p></blockquote><p><strong>过程4：运行</strong></p><p>有了可执行的exe文件，我们可以在控制台下直接运行此exe文件。</p><p><img src="/img/images/image-20230810153413126.png" alt="image-20230810153413126"></p><blockquote><p>注意：</p><p>对修改后的xxx.c源文件需要<strong>重新编译、链接</strong>，生成新的exe文件后，再执行，才能生效。</p></blockquote><p>练习：</p><blockquote><p>计算机高级语言程序的运行方法有编译执行和解释执行两种，以下叙述中正确的是（　　）。<br>A．C语言程序仅可以编译执行<br>B．C语言程序仅可以解释执行<br>C．C语言程序既可以编译执行，又可以解释执行<br>D．以上说法都不对</p><p>【答案】A</p><p>【解析】编译执行是指程序执行前需要一个专门的编译过程把程序编译成机器语言的文件，再次运行时不需要重新翻译，执行效率高；解释执行是指每个语句都是执行的时候才翻译，执行效率低。用C语言编写的程序必须经过编译器编译后，转换为二进制的机器指令来运行。</p></blockquote><p>练习：</p><blockquote><p>以下叙述中错误的是（　　）。<br>A．C语言的可执行程序是由一系列机器指令构成的<br>B．用C语言编写的源程序不能直接在计算机上运行<br>C．通过编译得到的二进制目标程序需要链接才可以运行<br>D．在没有安装C语言集成开发环境的机器上不能运行C源程序生成的exe文件</p><p>【答案】D</p><p>【解析】A项正确，C语言的可执行程序是由一系列机器指令组成的；BC项正确，用C语言编写的源程序必须经过编译，生成二进制目标代码，再经过连接才能运行；D项错误，C语言经过编译链接后的二进制目标代码可以脱离C语言集成开发环境独立运行。答案选择D选项。</p></blockquote><h2 id="5、注-释-comment"><a href="#5、注-释-comment" class="headerlink" title="5、注 释(comment)"></a>5、注 释(comment)</h2><img src="/img/images/image-20220610113151774.png" alt="image-20220610113151774" style="zoom: 67%;" /><ul><li><p>什么是注释？</p><ul><li>源文件中用于<code>解释</code>、<code>说明</code>程序的文字就是注释。</li><li>注释只是给人看的，程序执行时，<code>编译器会忽略注释</code>，注释对代码执行没有影响</li></ul></li><li><p>注释是一个程序员必须要具有的良好编程习惯。实际开发中，程序员可以先将自己的<code>思想</code>通过注释整理出来，再用<code>代码</code>去体现。</p><blockquote><p>程序员最讨厌两件事：</p><ul><li><p>一件是自己写代码被要求加注释</p></li><li><p>另一件是接手别人代码，发现没有注释</p></li></ul></blockquote></li><li><p>不加注释的危害</p><p><img src="/img/images/%E6%96%B0%E6%9D%A5%E7%9A%84%E8%8F%9C%E9%B8%9F%E7%A8%8B%E5%BA%8F%E5%91%98%E9%97%AF%E7%A5%B8%E4%BA%86%E3%80%82%E3%80%82%E3%80%82%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%A5%BD%E5%A4%9A%E5%B9%B4%E9%83%BD%E6%B2%A1%E4%BA%BA%E6%95%A2%E5%8A%A8%E8%BF%87%E7%9A%84.gif"></p></li><li><p>C语言中的注释类型：</p><ul><li><strong>单行注释</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure><ul><li><strong>多行注释(或块注释)</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是第一行注释</span></span><br><span class="line"><span class="comment">  这是第二行注释</span></span><br><span class="line"><span class="comment">  这是第三行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 我是被注释的文字 */</span></span><br></pre></td></tr></table></figure></li><li><p>举例</p><ul><li>举例1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>              <span class="comment">//这是编译预处理指令</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>                  <span class="comment">//定义主函数</span></span><br><span class="line">&#123;                               <span class="comment">//函数开始的标志</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);    <span class="comment">//输出所指定的一行信息</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                   <span class="comment">//函数执行完毕时返回函数值0</span></span><br><span class="line">&#125;                               <span class="comment">//函数结束的标志</span></span><br></pre></td></tr></table></figure><ul><li>举例2</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>; <span class="comment">// 这里定义了一个变量</span></span><br></pre></td></tr></table></figure><ul><li>举例3</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>); </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">printf(&quot;2&quot;);</span></span><br><span class="line"><span class="comment">printf(&quot;3&quot;);  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;4&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>举例4</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">char</span>* s <span class="comment">/* file name */</span>, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure></li><li><p>注意：</p><ol><li><p>多行注释不能嵌套使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我是注释信息1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我是注释信息2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">我是注释信息<span class="number">3</span></span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p>双引号内使用注释，会被当做普通字符串看待，失去注释作用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;// hello /* atguigu */ &quot;</span>);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>一个段子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">A：嘿 <span class="comment">//是什么意思啊？</span></span><br><span class="line">B：嘿.</span><br><span class="line">A：呃 我问你<span class="comment">//是什么意思？</span></span><br><span class="line">B：问吧.</span><br><span class="line">A：我刚才不是问了么？</span><br><span class="line">B：啊？</span><br><span class="line">A：你再看看记录...</span><br><span class="line">B：看完了.</span><br><span class="line">A：......所以<span class="comment">//是啥？</span></span><br><span class="line">B：所以什么？</span><br><span class="line">A：你存心耍我呢吧？</span><br><span class="line">B：没有啊 你想问什么？</span><br><span class="line">……</span><br><span class="line">不断循环之后，A一气之下和B绝交，自己苦学程序。</span><br><span class="line">N年之后，A终于修成正果，回想起B，又把聊天记录翻出来看，这时，他突然发现B没有耍他……</span><br><span class="line">而他自己也不知道当年他问B的究竟是什么问题……</span><br></pre></td></tr></table></figure></li></ul><p>练习：</p><blockquote><p>以下叙述中错误的是（　　）。<br>A．C语言中的每条可执行语句和非执行语句最终都将被转换成二进制的机器指令<br>B．C程序经过编译、链接步骤之后才能形成一个真正可执行的二进制机器指令文件<br>C．用C语言编写的程序称为源程序，它以ASCII代码形式存放在一个文本文件中<br>D．C语言源程序经编译后生成后缀为.obj的目标程序</p><p>【答案】A</p><p>【解析】A项错误，注释语句不会被翻译成二进制的机器指令。C源程序经过C编译程序编译之后生成后缀为.obj的二进制文件（称为目标文件），然后由“链接程序”（Link）的软件把.obj文件与各种库函数连接起来生成一个后缀为.exe的可执行文件。答案选择A选项。</p></blockquote><h2 id="6、HelloWorld的剖析"><a href="#6、HelloWorld的剖析" class="headerlink" title="6、HelloWorld的剖析"></a>6、HelloWorld的剖析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>              </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>                  </span><br><span class="line">&#123;                               </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-规范的代码风格"><a href="#6-1-规范的代码风格" class="headerlink" title="6.1 规范的代码风格"></a>6.1 规范的代码风格</h3><p><strong>正确的缩进和空白</strong></p><ol><li><p>使用一次tab操作，实现缩进，默认整体向右边移动。相反，使用shift+tab整体向左移</p></li><li><p>运算符两边习惯性各加一个空格。比如：<code>2 + 4 * 5</code>。</p></li><li><p>可以使用代码格式化快捷键 ctrl+alt+L。(在CLion中使用)</p></li></ol><p><strong>代码块的风格</strong></p><p>1）行尾风格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;                                      </span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>2）次行风格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;                                      </span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>正确的注释和注释风格：</strong></p><p>1）如果注释一个函数，可以使用多行注释(或块注释)。</p><p>2）如果注释函数中的某一行语句，可以使用单行注释。</p><h3 id="6-2-代码细节剖析"><a href="#6-2-代码细节剖析" class="headerlink" title="6.2 代码细节剖析"></a>6.2 代码细节剖析</h3><h4 id="①-main"><a href="#①-main" class="headerlink" title="① main()"></a>① main()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>每一个程序(或工程)可以定义很多函数(后面讲)，但有且只有一个main()函数，作为程序执行的入口，在 main()函数结尾结束整个程序的运行。</li><li>空括号()，表示 main 不接受任何参数。</li><li>写在main之前的“int”称为关键字，代表数据类型是整型。它是main()的返回值类型。即在执行main()函数后会得到一个整型值(即函数值)。</li><li>C 语言约定： <code>return 0</code>，表示main()函数终止运行，且运行成功；如果返回其它非零整数，就表示运行失败。默认情况下，如果 main() 里面省略 <code>return 0</code> 这一行，编译器会自动加上，但是为了保持统一的代码风格，不建议省略。</li></ul><h4 id="②-函数体"><a href="#②-函数体" class="headerlink" title="② 函数体"></a>② 函数体</h4><ul><li><p>一对花括号{}定义了函数的主体，所有函数都必须以大括号开头和结尾，成对出现。</p></li><li><p>C 程序中的函数体指的是作为该函数一部分的语句。它可以是任何操作，比如搜索、排序、打印等。</p></li><li><p>每一个执行语句后面都会有一个英文分号“;”作为语句结束的标志。</p></li><li><p>一行内可写几条语句，一条语句也可写在几行上。</p></li></ul><h4 id="③-printf"><a href="#③-printf" class="headerlink" title="③ printf()"></a>③ printf()</h4><p>printf()函数是产生格式化输出的函数，作用是将参数文本输出到屏幕。它名字里面的 f 代表 format (格式化)，表示可以指定输出文本的格式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">//将字符串输出到控制台，行尾不换行</span></span><br></pre></td></tr></table></figure><p>为了让光标移到下一行的开头，可以在输出文本的结尾，添加一个换行符 \n 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="④-标准库、头文件"><a href="#④-标准库、头文件" class="headerlink" title="④ 标准库、头文件"></a>④ 标准库、头文件</h4><p>printf() 是在标准库的头文件 <code>stdio.h</code> 中定义的。要想在程序中使用这个函数，必须在源文件头部引入这个头文件。即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>何为标准库？</strong></p><p>程序需要用到的功能，不一定需要自己编写，C 语言可能已经自带了。程序员只要去调用这些自带的功能就可以了。C 语言自带的所有这些功能，统称为<code>“标准库”(standard library)</code>，包含C 内置函数、常量和头文件。</p><p>因为它们是写入标准的，到底包括哪些功能，应该怎么使用，都是规定好的，我们直接调用即可。</p><p><strong>何为头文件？</strong></p><p>不同的功能定义在不同的文件里，这些文件统称为<code>“头文件”(header file)</code>。如果系统自带某一个功能，就一定会自带描述这个功能的头文件，比如 printf() 的头文件就是系统自带的 <code>stdio.h</code> 。头文件的后缀通常是 <code>.h</code> 。</p><p><strong>预处理命令：#include命令</strong></p><p>如果要使用某个功能，就必须先加载其对应的头文件，加载使用的是 <code>#include</code> 命令，声明在各文件模块的开头。C语言中以 # 号开头的命令称为<code>预处理命令</code>。顾名思义，在编译器对当前C程序进行编译前执行预处理操作。</p><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;头文件名&gt;</span></span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>   </span></span><br></pre></td></tr></table></figure><blockquote><p>注意，加载头文件的 #include 语句不需要分号结尾</p></blockquote><p>对比写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>： <span class="comment">//编译系统在系统头文件所在目录搜索</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span>： <span class="comment">//编译系统首先在当前的源文件目录中查找 stdio.h，找不到的话，再转向系统头文件所在目录搜索。</span></span></span><br></pre></td></tr></table></figure><p><code>stdio.h</code>是系统提供的一个文件名，<code>stdio</code>是standard input &amp; output的缩写。</p><p>结论：</p><ul><li>引用系统头文件，两种形式都会可以，<code>#include &lt;&gt; </code>效率高。</li></ul><ul><li>引用用户头文件，只能使用 <code>#include &quot;&quot;</code>。</li></ul><p><strong>常用的C头文件</strong></p><ul><li><code>stdio.h</code>——定义核心输入和输出函数<ul><li>printf()、scanf()、getchar()、putchar()</li></ul></li><li><code>stdlib.h</code>——定义数值转换函数、伪随机网络生成器和内存分配</li><li><code>string.h</code>——定义字符串处理函数</li><li><code>stdint.h</code>——定义精确宽度的整数类型</li><li><code>math.h</code>——定义常用的数学函数<ul><li>sin()、sqrt()</li></ul></li><li><code>stddef.h</code>——定义了几个有用的类型和宏</li></ul><p>练习：</p><blockquote><p>以下叙述中正确的是（　）。<br>A．C程序中的注释只能出现在程序的开始位置和语句的后面<br>B．C程序书写格式严格，要求一行内只能写一个语句<br>C．C程序书写格式自由，一个语句可以写在多行上<br>D．用C语言编写的程序只能放在一个程序文件中</p><p>【答案】C</p><p>【解析】C程序的注释可以出现在C程序的任何位置，注释符号：“&#x2F;&#x2F;”或“&#x2F;<em>…</em>&#x2F;”，选项A错误。C程序中，一行内可写多个语句，每条语句用分号“；”结束，选项B错误，选项C正确。用C语言编写的程序可以放在多个程序文件中，用#include命令行实现文件包含功能，选项D错误。答案选择C选项。</p></blockquote><blockquote><p> 【中央财经大学2018研】以下叙述错误的是（　）。<br> A．在程序中凡是以“#”开始的语句行都是预处理命令行<br> B．预处理命令行的最后不能以分号表示结束<br> C．#include MAX是合法的宏定义命令行<br> D．C程序对预处理命令行的处理是在程序执行的过程中进行的</p><p> 【答案】D</p><p> 【解析】在C语言中，凡是以“#”开头的行都称为编译预处理命令行，为了区别C语句，后面是不加分号的。编译预处理是在编译程序对C源程序进行编译前执行的，而不是在程序执行过程中进行的。</p></blockquote><p><strong>注意：</strong></p><blockquote><p>学习编程最容易犯的错是<code>语法错误</code>。C语言要求必须按照语法规则编写代码。如果你的程序违反了语法规则，例如：忘记了分号、大括号、引号 或者拼错了单词等，C编译器都会报语法错误。<code>尝试着去看懂编译器会报告的错误信息</code>。</p></blockquote><h2 id="7、关于输出"><a href="#7、关于输出" class="headerlink" title="7、关于输出"></a>7、关于输出</h2><h3 id="7-1-printf-标准格式"><a href="#7-1-printf-标准格式" class="headerlink" title="7.1 printf()标准格式"></a>7.1 printf()标准格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(格式控制字符串,输出列表);</span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20230822164051224.png" alt="image-20230822164051224"></p><p>其中，</p><ul><li><p><code>&quot;格式控制字符串&quot;</code>是用双引号括起来的一个字符串。包括：</p><ul><li>普通字符：普通字符即需要在输出时原样输出的字符。</li><li>占位符：由“%”和格式字符组成。这个位置可以用其它值代入。</li></ul></li><li><p><code>&quot;输出列表&quot;</code>是程序需要输出的一些数据，可以是常量、变量或表达式。用于替换占位符的位置。</p></li></ul><blockquote><p>注意：printf() 参数与占位符是一一对应关系。如果参数个数少于对应的占位符， printf() 可能会输出内存中的任意值。</p></blockquote><h3 id="7-2-占位符"><a href="#7-2-占位符" class="headerlink" title="7.2 占位符"></a>7.2 占位符</h3><p>占位符的第一个字符是 <code>%</code> ，第二个字符表示占位符的类型。</p><p>printf() 的占位符有许多种类，与 C 语言的数据类型相对应。</p><p>下面按照字母顺序，列出占位符如下，方便查阅(红色为常用的)：</p><blockquote><p>%a ：浮点数(仅C99有效)<br>%A ：浮点数(仅C99有效)<br><strong>%c ：char型数据</strong><br><strong>%d ：十进制整数(int)</strong><br>%e ：使用科学计数法的浮点数，指数部分的 e 为小写<br>%E ：使用科学计数法的浮点数，指数部分的 E 为大写<br>%i ：整数，基本等同于 %d<br><strong>%f ：浮点数(float)</strong><br>%g ：6个有效数字的浮点数。整数部分一旦超过6位，就会自动转为科学计数法，指数部分的 e 为小写<br>%G ：等同于 %g ，唯一的区别是指数部分的 E 为大写<br>%hd ：十进制 short int 类型<br>%ho ：八进制 short int 类型<br>%hx ：十六进制 short int 类型<br>%hu ：unsigned short int 类型<br><strong>%ld ：十进制整数(long)</strong><br>%lo ：八进制 long int 类型<br>%lx ：十六进制 long int 类型<br>%lu ：unsigned long int 类型<br>%lld ：十进制 long long int 类型<br>%llo ：八进制 long long int 类型<br>%llx ：十六进制 long long int 类型<br>%llu ：unsigned long long int 类型<br>%le ：科学计数法表示的 long double 类型浮点数<br><strong>%lf ：十进制浮点数(double)</strong><br>%n ：已输出的字符串数量。该占位符本身不输出，只将值存储在指定变量之中<br>%o ：八进制整数<br><strong>%p ：指针</strong><br><strong>%s ：字符串</strong><br><strong>%u ：十进制无符号整数（unsigned int）</strong><br>%x ：十六进制整数<br>%zd ： size_t 类型<br>%% ：输出一个百分号</p></blockquote><h3 id="7-3-举例"><a href="#7-3-举例" class="headerlink" title="7.3 举例"></a>7.3 举例</h3><p><strong>举例1：%d</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;count is %d\n&quot;</span>,num);  <span class="comment">//输出：count is 10  </span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;There are %i students\n&quot;</span>, <span class="number">5</span>);   <span class="comment">//输出：There are 5 students</span></span><br></pre></td></tr></table></figure><p><strong>举例2：%lf 和 %f</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f = <span class="number">3.1415926535f</span>;    <span class="comment">// 单精度浮点数</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">3.1415926535</span>;  <span class="comment">// 双精度浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 %f 输出单精度浮点数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Float: %f\n&quot;</span>, f);  <span class="comment">//Float: 3.141593</span></span><br><span class="line"><span class="comment">// 使用 %lf 输出双精度浮点数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Double: %lf\n&quot;</span>, d); <span class="comment">//Double: 3.141593</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 %f 输出单精度浮点数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Float: %.8f\n&quot;</span>, f);  <span class="comment">//Float: 3.14159274</span></span><br><span class="line"><span class="comment">// 使用 %lf 输出双精度浮点数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Double: %.8lf\n&quot;</span>, d); <span class="comment">//Double: 3.14159265</span></span><br></pre></td></tr></table></figure><p><strong>举例3：%c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> level = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this score level is:%c\n&quot;</span>,level); <span class="comment">//输出：this score level is:A</span></span><br></pre></td></tr></table></figure><p><strong>举例4：%s</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s是我最喜欢的冷门歌手.\n&quot;</span>,<span class="string">&quot;孙燕姿&quot;</span>); <span class="comment">//输出：孙燕姿是我最喜欢的冷门歌手.</span></span><br></pre></td></tr></table></figure><p><strong>举例5：多个占位符</strong></p><p>输出文本里面可以使用多个占位符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s有%d部手机\n&quot;</span>, <span class="string">&quot;老板&quot;</span>, <span class="number">2</span>); <span class="comment">//输出：老板有2部手机</span></span><br></pre></td></tr></table></figure><h3 id="7-4-输出格式"><a href="#7-4-输出格式" class="headerlink" title="7.4 输出格式"></a>7.4 输出格式</h3><p>printf() 可以定制占位符的输出格式。</p><p><strong>格式1：限定宽度</strong></p><p>printf() 允许限定占位符的最小宽度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%5d\n&quot;</span>, <span class="number">123</span>); <span class="comment">// 输出为 &quot;  123&quot; </span></span><br></pre></td></tr></table></figure><p>说明：%5d 表示这个占位符的宽度至少为5位。如果不满5位，对应的值的前面会添加空格。</p><p>输出的值默认是右对齐，即输出内容前面会有空格；如果希望改成左对齐，在输出内容后面添加空格，可以在占位符的 % 的后面插入一个 - 号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-5d\n&quot;</span>, <span class="number">123</span>); <span class="comment">// 输出为 &quot;123  &quot;</span></span><br></pre></td></tr></table></figure><p>对于小数，这个限定符会限制所有数字的最小显示宽度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%12f\n&quot;</span>, <span class="number">123.45</span>); <span class="comment">// 输出 &quot;  123.450000&quot;</span></span><br></pre></td></tr></table></figure><p>%12f 表示输出的浮点数最少要占据12位。由于小数的默认显示精度是小数点后6位，所以123.45 输出结果的头部会添加2个空格。</p><p><strong>格式2：总是显示正负号</strong></p><p>默认情况下， printf() 不对正数显示 + 号，只对负数显示 - 号。如果想让正数也输出 + 号，可以在占位符的 % 后面加一个 + 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%+d\n&quot;</span>, <span class="number">11</span>); <span class="comment">// 输出 +11</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%+d\n&quot;</span>, <span class="number">-11</span>); <span class="comment">// 输出 -11</span></span><br></pre></td></tr></table></figure><p><strong>格式3：限定小数位数</strong></p><p>输出小数时，有时希望限定小数的位数。举例来说，希望小数点后面只保留两位，占位符可以写成 %.2f 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Number is %.2f\n&quot;</span>, <span class="number">0.8</span>); <span class="comment">// 输出 Number is 0.80</span></span><br></pre></td></tr></table></figure><p>这种写法可以与限定宽度占位符，结合使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%6.2f\n&quot;</span>, <span class="number">0.8</span>); <span class="comment">// 输出为 &quot;  0.80&quot;</span></span><br></pre></td></tr></table></figure><p>说明：%6.2f 表示输出字符串最小宽度为6，小数位数为2。整体长度不足 6 位时，右对齐显示。</p><p>最小宽度和小数位数这两个限定值，都可以用 * 代替，通过 printf() 的参数传入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%*.*f\n&quot;</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">0.8</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%6.2f\n&quot;</span>, <span class="number">0.8</span>);</span><br></pre></td></tr></table></figure><blockquote><p> 【华南理工大学2018研】十六进制形式输出整数的格式说明符是（　）。</p><p> A．%u<br> B．%ld<br> C．%x<br> D．%o</p><p> 【答案】C</p><p> 【解析】A表示输出的是无符号整型；B表示输出的是有符号长整型；D表示输出的是八进制。</p></blockquote><h2 id="8、练习"><a href="#8、练习" class="headerlink" title="8、练习"></a>8、练习</h2><p>练习1：开发一个 ILoveC.c 程序，可以输出 “某某 is studying c!”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;谷小妹 is studying C!\n&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;%s is studying C!\n&quot;,&quot;谷小妹&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习2：控制台打印：5 + 3 &#x3D; 8</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, <span class="number">5</span>, <span class="number">3</span>, (<span class="number">5</span> + <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//函数结束</span></span><br></pre></td></tr></table></figure><h2 id="附录：C-C-Single-File-Execution插件的安装"><a href="#附录：C-C-Single-File-Execution插件的安装" class="headerlink" title="附录：C&#x2F;C++ Single File Execution插件的安装"></a>附录：C&#x2F;C++ Single File Execution插件的安装</h2><p><strong>1、为何安装C&#x2F;C++ Single File Execution插件？</strong></p><p>前面已经创建了一个demo1工程，项目文件夹内存在一个代码文件，名为<code>main.c</code>。如果再创建一个C源文件，内部如果也包含main()函数，则会报错！因为默认C工程下只能有一个main()函数。如何解决此问题呢？</p><p>2、安装并测试</p><p>1）在 File - Settings - Plugins 中搜索 <code>C/C++ Single File Execution</code> 插件并安装</p><p><img src="/img/images/image-20230823145107293.png" alt="image-20230823145107293"></p><p>2）在需要运行的代码中右键，点击 Add executable for single c&#x2F;cpp file</p><p><img src="/img/images/1692774502830.png" alt="1692774502830"></p><p>3）此时可以在 Cmakelists.text 文件中看到多出的这一行代码，这就是插件帮我们完成的事情</p><p><img src="/img/images/1692774556495.png" alt="1692774556495"></p><p>4）右键项目文件夹，点击 Reload CMake Project 进行刷新</p><p><img src="/img/images/1692774575597.png" alt="1692774575597"></p><p>5）此时右上角标签处已经增加了我们的文件选项，选择需要的标签</p><p><img src="/img/images/1692774598633.png" alt="1692774598633"></p><p>6）点击小三角，或右键代码处点击 Run 选项，即可运行代码。</p><p><img src="/img/images/1692774678384.png" alt="1692774678384"></p><p>7）在该工程下创建main2.c文件，文件中的代码如下所示，执行上面相同的步骤。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World2!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现一个工程中允许存在多个main方法了，而且可以独立允许。</p><h1 id="第02章-变量与进制"><a href="#第02章-变量与进制" class="headerlink" title="第02章_变量与进制"></a>第02章_变量与进制</h1><h2 id="本章专题脉络-1"><a href="#本章专题脉络-1" class="headerlink" title="本章专题脉络"></a>本章专题脉络</h2><p><img src="/img/images/%E7%AC%AC2%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%9B%E5%88%B6.png" alt="第2章_变量与进制"></p><h2 id="1、关键字-keyword"><a href="#1、关键字-keyword" class="headerlink" title="1、关键字(keyword)"></a>1、关键字(keyword)</h2><p>定义：<strong>被C语言赋予了特殊含义，用做专门用途的字符串（或单词）。</strong></p><p>特点：全部关键字都是<code>小写字母</code>。</p><p>举例：HelloWorld案例中，出现的关键字有 <code>int</code>、<code>return</code>等，这些单词已经被C语言定义好了。</p><p>传统的C语言（ANSI C）有32个关键字。如下：</p><table><thead><tr><th>类型</th><th>具体关键字</th></tr></thead><tbody><tr><td>控制语句关键字（12 个）</td><td>break, case, continue, default, do, else, for, goto, if, return, switch, while</td></tr><tr><td>数据类型关键字（12 个）</td><td>char, enum, double, long, float, int, short, signed, struct, unsigned, union, void</td></tr><tr><td>存储类型关键字（4 个）</td><td>auto, extern, register, static</td></tr><tr><td>其他关键字（4 个）</td><td>const, sizeof, typedef, volatile</td></tr></tbody></table><p>后续，1999年，C99标准增加了5个关键字：<code>inline</code>、<code>restrict</code>、<code>_Bool</code>、<code>_Complex</code>和<code>_Imaginary</code>。</p><p>2011年，C11标准又增加了7个关键字：<code>_Alignas</code>、<code>_Alignof</code>、<code>_Atomic</code>、<code>_Static_assert</code>、<code>_Noreturn</code>、<code>_Thread_local</code>和<code>_Generic</code>。</p><blockquote><p>说明：</p><p>1、ANSI C、C99和C11，它们之间差别并不大，在大多数情况下，它们都是和谐共处的。</p><p>2、不需要死记硬背，学到哪里记到哪里即可。</p></blockquote><h2 id="2、标识符-Identifier"><a href="#2、标识符-Identifier" class="headerlink" title="2、标识符(Identifier)"></a>2、标识符(Identifier)</h2><p>C语言中变量、函数、数组名、结构体等要素命名时使用的字符序列，称为标识符。</p><p>技巧：凡是自己可以起名字的地方都叫标识符。</p><p><strong>标识符的命名规则</strong>（必须遵守的<code>硬性规定</code>）</p><ul><li>只能由26个英文字母大小写，0-9 或 _ 组成</li><li>数字不可以开头</li><li>不可以是关键字，但可以包含关键字</li><li>C99和C11允许使用更长的标识符名，但是编译器只识别前63个字符。(会忽略超出的字符)</li><li>不允许有空格。</li><li>严格区分大小写字母。比如：Hello、hello是不同的标识符。</li></ul><p><strong>标识符的命名建议</strong>（建议遵守的<code>软性要求</code>）</p><ul><li><p>在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。如：sum，name，max，year，total 等。</p></li><li><p>不要出现仅靠大小写区分不同的标识符。如：name、Name 容易混淆</p></li><li><p>尽量避免名字中出现数字编号，如value1、value2等，除非逻辑上需要编号。</p></li><li><p>习惯上，所有宏定义、枚举常数、常量(只读变量)全用大写字母命名，用下划线分隔单词。</p><p>比如： const double TAX_RATE &#x3D; 0.08; &#x2F;&#x2F;TAX_RATE 只读变量</p></li><li><p>系统内部使用了一些下划线开头的标识符（比如两个下划线开头的变量名、一个下划线 + 大写英文字母开头的变量名）。比如，C99 标准添加的类型 <code>_Bool</code>。为防止冲突，建议用户尽量避免使用下划线开头的标识符。</p></li><li><p>下划线通常用于连接一个比较长的变量名。如：max_classes_per_student。</p></li><li><p>变量名、函数名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz (驼峰法，小驼峰)。比如：<code>short stuAge = 20; </code>，<code>tankShotGame</code>。</p></li></ul><p>举例：合法的标识符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a、BOOK1、_sun、MAX_SIZE、Mouse、student23、Football、FOOTBALL、max、_add、num_1、sum_of_numbers</span><br></pre></td></tr></table></figure><p>举例：非法的标识符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$zj、3sum、ab#cd、23student、Foot-baii、s.com、b＆c、j**p、book-1、tax rate、don&#x27;t</span><br></pre></td></tr></table></figure><blockquote><p>【武汉科技大学2019研】</p><p>以下均是合法变量名的是（　）。<br>A．#name   total<br>B．node 　value_max<br>C．_var 　long<br>D．stu－code   a＋b</p><p>【答案】B</p><p>【解析】C语言中变量名只能包含数字，字母和下划线，且只能以字母和下划线开始。A项含非法字符#，错误；C中long为关键字，变量不能以关键字命名；D中含非法字符－和＋。</p></blockquote><blockquote><p> 【四川大学2017研】以下不合法的用户标识符是（　　）。<br> A．J2_KEY<br> B．Double<br> C．4d<br> D．_8_</p><p> 【答案】C</p><p> 【解析】标识符只能包含数字，字母，下划线，且不能以数字开头，选项C错误。</p></blockquote><blockquote><p>练习</p><p>下列定义变量的语句中错误的是（　　）。<br>A．double int_；<br>B．float US$；<br>C．char For；<br>D．int _int；</p><p>【答案】B【解析】标识符由字母、数字、下划线组成。$是非法字符，不能出现在标识符中。答案选择B选项。</p></blockquote><h2 id="3、变量-variable"><a href="#3、变量-variable" class="headerlink" title="3、变量(variable)"></a>3、变量(variable)</h2><h3 id="3-1-为什么需要变量"><a href="#3-1-为什么需要变量" class="headerlink" title="3.1 为什么需要变量"></a>3.1 为什么需要变量</h3><p><img src="/img/images/image-20220513235020527.png" alt="image-20220513235020527"></p><p>一花一世界，如果把一个程序看做一个世界或一个社会的话，那么变量就是程序世界的花花草草、万事万物。即，<strong>变量是程序中不可或缺的组成单位，最基本的存储单元</strong>。</p><p><img src="/img/images/image-20220513235828042.png" alt="image-20220513235828042"></p><h3 id="3-2-初识变量"><a href="#3-2-初识变量" class="headerlink" title="3.2 初识变量"></a>3.2 初识变量</h3><ul><li><p>变量的概念：</p><ul><li><p>内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化。</p></li><li><p>通过变量名，可以访问这块内存区域，获取里面存储的值。</p></li><li><p>变量的构成包含三个要素：<code>数据类型</code>、<code>变量名</code>、<code>存储的值</code></p></li><li><p>C语言中变量声明的格式：<code>数据类型 变量名 = 变量值</code></p><p><img src="/img/images/image-20230620171948703.png" alt="image-20230620171948703"></p></li></ul></li><li><p>变量的作用：用于在内存中保存数据。</p></li><li><p>使用变量注意：</p><ul><li>C语言中每个变量必须先声明，后使用。</li><li>不同的数据类型，占用的空间大小不一样。</li><li>一旦声明，变量的类型就不能在运行时修改。</li></ul></li></ul><h3 id="3-3-变量的声明与赋值"><a href="#3-3-变量的声明与赋值" class="headerlink" title="3.3 变量的声明与赋值"></a>3.3 变量的声明与赋值</h3><h4 id="步骤1：变量的声明"><a href="#步骤1：变量的声明" class="headerlink" title="步骤1：变量的声明"></a>步骤1：变量的声明</h4><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型  变量名;  <span class="comment">//声明变量的语句必须以分号结尾</span></span><br></pre></td></tr></table></figure><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> width;</span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> width,height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> width;</span><br><span class="line"><span class="type">int</span> height;</span><br></pre></td></tr></table></figure><h4 id="步骤2：变量的赋值"><a href="#步骤2：变量的赋值" class="headerlink" title="步骤2：变量的赋值"></a>步骤2：变量的赋值</h4><p>变量声明时，就为它分配内存空间，但是不会清除内存里面原来的值。这导致声明变量以后，变量会是一个随机的值。所以，变量一定要赋值以后才能使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age; <span class="comment">//变量的声明</span></span><br><span class="line">age = <span class="number">18</span>;  <span class="comment">//变量的赋值</span></span><br></pre></td></tr></table></figure><p>变量的声明和赋值，也可以写在一行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>多个相同类型变量的赋值，可以写在同一行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = (a = <span class="number">2</span> * a);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b, c, x, y;</span><br><span class="line">a = b = c = x = y = <span class="number">10</span>;  <span class="comment">//连续赋值</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：声明变量以后，不用忘记初始化赋值！定义变量时编译器并不一定清空了这块内存，它的值可能是无效的数据，运行程序，会异常退出。</p></blockquote><h3 id="3-4-变量的作用域-scope"><a href="#3-4-变量的作用域-scope" class="headerlink" title="3.4 变量的作用域(scope)"></a>3.4 变量的作用域(scope)</h3><ul><li><p>变量的作用域：其定义所在的一对{ }内。</p></li><li><p>变量只有在其<code>作用域</code>内才有效。出了作用域，变量不可以再被调用。</p></li><li><p>同一个作用域内，不能定义重名的变量。</p></li><li><p>C 语言的变量作用域主要有两种：文件作用域（file scope）和块作用域（block scope）。</p></li></ul><p><code>文件作用域（file scope）</code>指的是，在源码文件顶层声明的变量，从声明的位置到文件结束都有效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>块作用域（block scope）</code>指的是由大括号（ {} ）组成的代码块，它形成一个单独的作用域。凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, m, n);  <span class="comment">// 10 20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m);  <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);  <span class="comment">// 超出作用域，报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常见的块作用域就是函数，函数内部声明的变量，对于函数外部是不可见的。 for 循环也是一个块作用域，循环变量只对循环体内部可见，外部是不可见的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i); <span class="comment">// 超出作用域，报错</span></span><br></pre></td></tr></table></figure><h3 id="3-5-变量按类型的分类"><a href="#3-5-变量按类型的分类" class="headerlink" title="3.5 变量按类型的分类"></a>3.5 变量按类型的分类</h3><p>变量可以按<code>数据类型</code>来分，也可以按<code>声明的位置</code>来分（全局变量、局部变量）。本节主讲变量的不同类型。</p><p>C 语言中的变量按照数据类型分为：</p><p><img src="/img/images/image-20230810152811098.png" alt="image-20230810152811098"></p><blockquote><p>注意1：这里列举的是C语言的常用类型，后续C语言版本还有新增的类型。</p><p>注意2：空类型：void 表示空类型（无类型）。通常应用于函数的返回值类型、函数的参数、指针类型。</p><p>注意3：在C语言中，没有<code>字符串类型</code>，使用字符数组表示字符串。</p></blockquote><h2 id="4、基本数据类型"><a href="#4、基本数据类型" class="headerlink" title="4、基本数据类型"></a>4、基本数据类型</h2><h3 id="4-1-整数类型"><a href="#4-1-整数类型" class="headerlink" title="4.1 整数类型"></a>4.1 整数类型</h3><h4 id="4-1-1-类型说明"><a href="#4-1-1-类型说明" class="headerlink" title="4.1.1 类型说明"></a>4.1.1 类型说明</h4><ul><li><p>C语言规定了如下的几类整型：短整型(short)、整型(int)、长整型(long)、更长的整型(long long)</p></li><li><p>每种类型都可以被 signed 和unsigned 修饰。其中，</p><ul><li>使用 <code>signed 修饰</code>，表示该类型的变量是带符号位的，有正负号，可以表示负值。<code>默认是signed</code>。</li><li>使用 <code>unsigned 修饰</code>，表示该类型的变量是不带符号位的，没有有正负号，只能表示零和正整数。</li></ul></li><li><p>bit(位)：计算机中的最小存储单位。</p><p>byte(字节)：计算机中基本存储单元。</p><p>1byte &#x3D; 8bit</p></li></ul><table><thead><tr><th>类型</th><th>修饰符</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>short [int]</td><td>signed</td><td>2个字节(&#x3D;16位)</td><td>-32768 ~ 32767 (-$2^{15}$ ~ $2^{15}$-1)</td></tr><tr><td>short [int]</td><td>unsigned</td><td>2个字节(&#x3D;16位)</td><td>0 ~ 65535  (0 ~ $2^{16}$-1)</td></tr><tr><td>int</td><td>signed</td><td>通常4个字节</td><td>-2147483648 ~ 2147483647 (-$2^{31}$ ~ $2^{31}$-1)</td></tr><tr><td>int</td><td>unsigned</td><td>通常4个字节</td><td>0 ~ 4294967295  (0 ~ $2^{32}$-1)</td></tr><tr><td>long [int]</td><td>signed</td><td>4个或8个字节</td><td>4字节时：-2147483648 ~ 2147483647 (-$2^{31}$ ~ $2^{31}$-1)</td></tr><tr><td>long [int]</td><td>unsigned</td><td>4个或8个字节</td><td>4字节时：-0 ~ 4294967295  (0 ~ $2^{32}$-1)</td></tr></tbody></table><p>long long int是<code>C99新增</code>的：</p><table><thead><tr><th>类型</th><th>修饰符</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>long long [int]</td><td>signed</td><td>8个字节(&#x3D;64位)</td><td>-9223372036854775808~ 9223372036854775807(-$2^{63}$ ~ $2^{63}$-1)</td></tr><tr><td>long long [int]</td><td>unsigned</td><td>8个字节(&#x3D;64位)</td><td>0 ~ 18446744073709551615(0 ~ $2^{64}$-1)</td></tr></tbody></table><blockquote><p>说明1：不同计算机的 int 类型的大小是不一样的。比较常见的是使用4个字节（32位）存储一个 int 类型的值，具体情况如下：</p></blockquote><table><thead><tr><th>类型</th><th>16位编译器</th><th>32位编译器</th><th>64位编译器</th></tr></thead><tbody><tr><td>short int</td><td>2字节</td><td>2字节</td><td>2字节</td></tr><tr><td>int</td><td>2字节</td><td>4字节</td><td>4字节</td></tr><tr><td>unsigned int</td><td>2字节</td><td>4字节</td><td>4字节</td></tr><tr><td>long</td><td>4字节</td><td>4字节</td><td>8字节</td></tr><tr><td>unsigned long</td><td>4字节</td><td>4字节</td><td>8字节</td></tr><tr><td>long long</td><td>8字节</td><td>8字节</td><td>8字节</td></tr></tbody></table><blockquote><p>说明2：C标准虽然没有具体规定各种类型数据所占用存储单元的长度，但几条铁定的原则（ANSI&#x2F;ISO制订的）：<br>① sizeof(short int) ≤ sizeof(int) ≤ sizeof(long int) ≤ sizeof(long long)，具体由各编译系统自行决定的。其中，sizeof是测量类型或变量长度的运算符。</p><p>② short int至少应为2字节，long int至少应为4字节。</p></blockquote><p>这样约定的好处就是使得C语言可以长久使用。<code>现在的主流CPU是64位</code>，可以预测不久的将来会推出128位甚至256位的CPU，但是在C语言刚刚出现的时候，CPU还是以8位和16位为主。如果那时候就将整型定死为8位或16位，那么现在我们肯定不会再学习C语言了。</p><blockquote><p>说明3：</p><p>最常用的整型类型为：int类型。</p><p>整数型常量，默认为int类型。</p></blockquote><h4 id="4-1-2-举例"><a href="#4-1-2-举例" class="headerlink" title="4.1.2 举例"></a>4.1.2 举例</h4><p>举例1：对于 int 类型，默认是带有正负号的。即 int 等同于 signed int 。一般情况下，关键字signed省略不写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> m;  <span class="comment">//声明了一个带符号的整数变量 m </span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> m;   <span class="comment">//声明了一个带符号的整数变量 m</span></span><br></pre></td></tr></table></figure><p>举例2：int 类型也可以不带正负号，只表示非负整数。这时就必须使用关键字 unsigned 声明变量。表数范围为：0~4294967295</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a;   <span class="comment">//声明了一个不带符号的整数变量a，表数范围为：0~4294967295</span></span><br></pre></td></tr></table></figure><p>unsigned int 里面的 int 可以省略，所以上面的变量声明也可以写成这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> a;</span><br></pre></td></tr></table></figure><p>举例3：</p><p>int 类型使用4个字节表示一个整数，对于小整数，这样做很浪费空间。另一方面，某些场合需要更大的整数，8个字节还不够。此时，可以使用short int （简写为 short ）、long int （简写为 long ）、long long int （简写为 long long ）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">short</span> <span class="type">int</span> a; </span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> <span class="type">int</span> b;</span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> c;</span><br></pre></td></tr></table></figure><p>默认情况下， short 、 long 、 long long 都是带符号的（signed），即 signed 关键字可以省略。代码简写为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> a; </span><br><span class="line"><span class="type">long</span> b;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c;</span><br></pre></td></tr></table></figure><p>它们也可以声明为不带符号（unsigned），使得能够表示的最大值扩大一倍。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> a;  <span class="comment">//无符号短整型，表数范围：0~65535</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> b;   <span class="comment">//无符号长整型，表数范围：0~4294967295</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> c;  <span class="comment">//无符号长整型，表数范围：0~18446744073709551615</span></span><br></pre></td></tr></table></figure><h4 id="4-1-3-关于后缀"><a href="#4-1-3-关于后缀" class="headerlink" title="4.1.3 关于后缀"></a>4.1.3 关于后缀</h4><p>编译器将一个整数字面量指定为 int 类型，但是如果希望将其指定为 long 类型，需要在该字面量末尾加上后缀 <code>l</code> 或 <code>L</code> ，编译器会把这个字面量的类型指定为 long 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> x = <span class="number">123L</span>; <span class="comment">//或者写成 123l</span></span><br></pre></td></tr></table></figure><p>如果希望字面量指定为long long类型，则后缀以<code>ll</code>或<code>LL</code>结尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> y = <span class="number">123LL</span>;</span><br></pre></td></tr></table></figure><p>如果希望指定为无符号整数 unsigned int ，可以使用后缀 <code>u</code> 或 <code>U</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">123U</span>;</span><br></pre></td></tr></table></figure><p>L 和 U 可以结合使用，表示 unsigned long 类型。 L 和 U 的大小写和组合顺序无所谓。</p><p>u 还可以与其他整数后缀结合，放在前面或后面都可以，比如 10UL 、 10ULL 和 10LLU 都是合法的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>      x = <span class="number">1234UL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> x = <span class="number">1234ULL</span>;</span><br></pre></td></tr></table></figure><h4 id="4-1-4-精确宽度类型-了解"><a href="#4-1-4-精确宽度类型-了解" class="headerlink" title="4.1.4 精确宽度类型(了解)"></a>4.1.4 精确宽度类型(了解)</h4><p>C 语言的整数类型（short、int、long）在不同计算机上，占用的字节宽度可能是不一样的，无法提前知道它们到底占用多少个字节。程序员有时控制准确的字节宽度，这样的话，代码可以有更好的可移植性，头文件 stdint.h 创造了一些新的类型别名。</p><p><strong>精确宽度类型(exact-width integer type)</strong>：保证某个整数类型的宽度是确定的。</p><ul><li><p>int8_t ：8位有符号整数</p></li><li><p>int16_t ：16位有符号整数</p></li><li><p>int32_t ：32位有符号整数</p></li><li><p>int64_t ：64位有符号整数</p></li><li><p>uint8_t ：8位无符号整数</p></li><li><p>uint16_t ：16位无符号整数</p></li><li><p>uint32_t ：32位无符号整数</p></li><li><p>uint64_t ：64位无符号整数</p></li></ul><p>上面这些都是类型别名，编译器会指定它们指向的底层类型。比如，某个系统中，如果 int 类型为32位， int32_t 就会指向 int ；如果 long 类型为32位， int32_t 则会指向 long 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int32_t</span> x32 = <span class="number">45933945</span>;  <span class="comment">//变量 x32 声明为 int32_t 类型，可以保证是32位的宽度。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x32 = %d\n&quot;</span>, x32);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-5-整型的极限值-了解"><a href="#4-1-5-整型的极限值-了解" class="headerlink" title="4.1.5 整型的极限值(了解)"></a>4.1.5 整型的极限值(了解)</h4><p>有时候需要查看，当前系统不同整数类型的最大值和最小值，C 语言的头文件 <code>limits.h</code> 提供了相应的常量。比如：INT_MIN 代表 signed int 类型的最小值 -2147483648， INT_MAX 代表 signed int 类型的最大值 2147483647。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, INT_MIN  );  <span class="comment">// -2147483648</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, INT_MAX  );  <span class="comment">// 2147483647</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了代码的可移植性，需要知道某种整数类型的极限值时，应该尽量使用这些常量。</p><ul><li><p>SCHAR_MIN ， SCHAR_MAX ：signed char 的最小值和最大值。</p></li><li><p>SHRT_MIN ， SHRT_MAX ：short 的最小值和最大值。</p></li><li><p>INT_MIN ， INT_MAX ：int 的最小值和最大值。</p></li><li><p>LONG_MIN ， LONG_MAX ：long 的最小值和最大值。</p></li><li><p>LLONG_MIN ， LLONG_MAX ：long long 的最小值和最大值。</p></li><li><p>UCHAR_MAX ：unsigned char 的最大值。</p></li><li><p>USHRT_MAX ：unsigned short 的最大值。</p></li><li><p>UINT_MAX ：unsigned int 的最大值。</p></li><li><p>ULONG_MAX ：unsigned long 的最大值。</p></li><li><p>ULLONG_MAX ：unsigned long long 的最大值。</p></li></ul><h3 id="4-2-浮点类型"><a href="#4-2-浮点类型" class="headerlink" title="4.2 浮点类型"></a>4.2 浮点类型</h3><h4 id="4-2-1-类型说明"><a href="#4-2-1-类型说明" class="headerlink" title="4.2.1 类型说明"></a>4.2.1 类型说明</h4><p>浮点型变量，也称为实型变量，用来存储小数数值的。因为32位浮点数提供的精度或者数值范围还不够，C 语言又提供了另外两种更大的浮点数类型。</p><p>在C语言中，浮点型变量分为三种：单精度浮点型(float)、双精度浮点型(double)、长双精度浮点型(long double)。</p><table><thead><tr><th>类型</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>4个字节 (&#x3D;32位)</td><td>$-1.4<em>10^{-45}$ ~ $-3.4</em>10^{+38}$，$1.4<em>10^{-45}$ ~ $3.4</em>10^{+38}$</td></tr><tr><td>double</td><td>8个字节 (&#x3D;64位)</td><td>$-4.9<em>10^{-324}$ ~ $-1.7</em>10^{+308}$，$4.9<em>10^{-324}$ ~ $1.7</em>10^{+308}$</td></tr><tr><td>long double</td><td>12个字节(&#x3D;96位)</td><td>太大了…</td></tr></tbody></table><p>其中，</p><table><thead><tr><th>类型</th><th>16位编译器</th><th>32位编译器</th><th>64位编译器</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>4字节</td><td>4字节</td></tr><tr><td>double</td><td>8字节</td><td>8字节</td><td>8字节</td></tr></tbody></table><p>C语言的第3种浮点类型是long double，以满足比double类型更高的精度要求。不过，C只保证long double类型至少与double类型的精度相同。</p><p>浮点型变量不能使用signed或unsigned修饰符。</p><p>最常用的浮点类型为：double 类型，因为精度比float高。</p><p>浮点型常量，默认为 double 类型。</p><p><strong>关于后缀：</strong></p><p>对于浮点数，编译器默认指定为 double 类型，如果希望指定为float类型，需要在小数后面添加后缀 <code>f</code>或<code>F</code>；如果希望指定为long double类型，需要在小数后面添加后缀 <code>l</code>或<code>L</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> x       = <span class="number">3.14f</span>;</span><br><span class="line"><span class="type">double</span> x      = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> x = <span class="number">3.14L</span>;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-举例"><a href="#4-2-2-举例" class="headerlink" title="4.2.2 举例"></a>4.2.2 举例</h4><p><strong>举例1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f = <span class="number">123.4f</span>;　　<span class="comment">//后面必须加上字母f</span></span><br><span class="line"><span class="type">double</span> d1 = <span class="number">101.1</span>;　<span class="comment">//后面可以省略字母d</span></span><br><span class="line"><span class="type">double</span> d2 = <span class="number">299.4</span>;　　<span class="comment">//后面可以加上字母d</span></span><br></pre></td></tr></table></figure><p><strong>举例2：</strong></p><p>C 语言允许使用科学计数法表示浮点数，使用字母 e 来分隔小数部分和指数部分。注意，e 的前后，不能存在空格。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="number">123.456e+3</span>; <span class="comment">// 123.456 x 10^3</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">double</span> x = <span class="number">123.456e3</span>;</span><br></pre></td></tr></table></figure><p>另外，科学计数法的小数部分如果是 0.x 或 x.0 的形式，那么 0 可以省略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.3E6</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">.<span class="number">3E6</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3.0E6</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="number">3.E6</span></span><br></pre></td></tr></table></figure><p>**举例3：**可以在常量的末尾加专用字符，强制指定常量的类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">3.14159f</span>; <span class="comment">//把此3.14159按单精度浮点常量处理</span></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> a = <span class="number">1.23L</span>; <span class="comment">//把此1.23作为long double型处理</span></span><br></pre></td></tr></table></figure><p><strong>举例4：</strong></p><p>有人用温度计测量出用华氏法表示的温度(如64°F），今要求把它转换为以摄氏法表示的温度(如17.8℃)。转换的公式为：$c &#x3D; \frac{5}{9}(f - 32)$。</p><p>其中，f 代表华氏温度，c 代表摄氏温度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> f, c; <span class="comment">//定义f和c分别表示华氏温度、摄氏温度</span></span><br><span class="line">    f = <span class="number">64.0</span>; <span class="comment">//指定f的值</span></span><br><span class="line">    c = (<span class="number">5.0</span> / <span class="number">9</span>) * (f - <span class="number">32</span>); <span class="comment">//利用公式计算c的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f=%f\nc=%f\n&quot;</span>, f, c); <span class="comment">//输出c的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-存储规则-了解"><a href="#4-2-3-存储规则-了解" class="headerlink" title="4.2.3 存储规则(了解)"></a>4.2.3 存储规则(了解)</h4><p>任何有小数点的数值，都会被编译器解释为浮点数。所谓“浮点数”就是使用 m * b^e 的形式，存储一个数值， m 是小数部分， b 是基数， e 是指数部分。</p><p><strong>从十进制的角度：</strong></p><p><img src="/img/images/1688554845769.png" alt="1688554845769"></p><p><strong>从二进制的角度：</strong></p><p>根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：$(-1)^S * M * 2^E$</p><p>其中：</p><ul><li><p>$(-1)^s$表示符号位，当s&#x3D;0，V为正数；当s&#x3D;1，V为负数。</p></li><li><p>M表示有效数字，大于等于1，小于2。</p></li><li><p>$2^E$表示指数位。</p></li></ul><p>举例来说：</p><p>十进制的5.0，写成二进制是 101.0 ，相当于 1.01×2^2 。即，按照上面V的格式，可以得出s&#x3D;0，M&#x3D;1.01，E&#x3D;2。</p><p>十进制的-5.0，写成二进制是 -101.0 ，相当于 -1.01×2^2 。即，s&#x3D;1，M&#x3D;1.01，E&#x3D;2。</p><p><code>IEEE 754规定：</code></p><p>对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。</p><p><img src="/img/images/1688626607436.png" alt="1688626607436"></p><p>对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。</p><p><img src="/img/images/1688626635111.png" alt="1688626635111"></p><p>浮点数的存储方式，决定了浮点数精度控制在一定范围内。有效数字部分可能丢失，造成精度损失。</p><h3 id="4-3-字符类型"><a href="#4-3-字符类型" class="headerlink" title="4.3 字符类型"></a>4.3 字符类型</h3><p>C语言中，使用 char 关键字来表示字符型，用于存储一个<code>单一字符</code>。</p><p>字符型变量赋值时，需要用一对英文半角格式的单引号（<code>&#39;&#39;</code>）把字符括起来。</p><p>每个字符变量，在16位、32位或64位编译器中都是<code>占用 1 个字节(=8位)</code>。</p><p><strong>表示方式1：最常见</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;　<span class="comment">//为一个char类型的变量赋值字符&#x27;A&#x27;</span></span><br></pre></td></tr></table></figure><p>每个字符对应一个整数（由 ASCII 码确定），比如 A 对应整数 65 。</p><p>只要在字符类型的范围之内，整数与字符是可以互换的，都可以赋值给字符类型的变量。</p><p><strong>表示方式2：ASCII 码值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="number">66</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;B&#x27;</span>;</span><br></pre></td></tr></table></figure><p>两个字符类型的变量可以进行数学运算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;B&#x27;</span>; <span class="comment">// 等同于 char a = 66;</span></span><br><span class="line"><span class="type">char</span> b = <span class="string">&#x27;C&#x27;</span>; <span class="comment">// 等同于 char b = 67;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + b); <span class="comment">// 输出133</span></span><br></pre></td></tr></table></figure><p><code>常见的ASCII值与对应的字符如下：(ASCII数值范围为0-127)</code></p><p><img src="/img/images/image-20220513095907601.png" alt="image-20220513095907601"></p><blockquote><p>ASCII码：上个世纪60年代，美国制定了一套字符编码，对<strong>英语字符</strong>与<strong>二进制位之间的关系</strong>，做了统一规定。这被称为ASCII码。ASCII码一共规定了<strong>127</strong>个字符的编码，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0，也就是说，ASCII虽然用8位二进制编码表示字符，但是其有效位为7位。</p></blockquote><p>举例1：字符′1′和整数1是不同的概念。（参看ASCII码表）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c1 = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> c2 = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c1 = %d\n&quot;</span>,c1); <span class="comment">// c1 = 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c2 = %d\n&quot;</span>,c2); <span class="comment">// c2 = 49</span></span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c=<span class="string">&#x27;?&#x27;</span>; <span class="comment">//定义c为字符型变量并使初值为字符&#x27;?&#x27;。&#x27;?&#x27;的ASCII代码是63，系统把整数63赋给变量c。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %c\n&quot;</span>,c,c); <span class="comment">//用&quot;%d&quot;格式输出十进制整数63，用&quot;%c&quot;格式输出字符&#x27;?&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>signed 和 unsigned 修饰：</strong></p><p>根据C90标准，C语言允许在关键字char前面使用signed或unsigned。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">char</span> c; <span class="comment">// 范围为 -128 到 127</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c; <span class="comment">// 范围为 0 到 255</span></span><br></pre></td></tr></table></figure><p>注意，C 语言规定 char 类型默认是否带有正负号，由当前系统决定，这一点与 int 不同， int 等同于 signed int 。这就是说， char 不等同于signed char ，它有可能是 signed char（范围-128 到 127） ，也有可能是 unsigned char （范围0 到255）。不管是哪种，范围都正好都能覆盖 0 到 127 的 ASCII 字符范围。</p><p><strong>表示方式3：使用转义字符</strong></p><p>单引号本身也是一个字符，如果要表示这个字符常量，必须使用反斜杠转义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> t = <span class="string">&#x27;\&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>char还可以用来表示转义字符。比如：</p><table><thead><tr><th>字符形式</th><th>含义</th></tr></thead><tbody><tr><td><code>\n</code></td><td>换行符（光标移动到下行行首）</td></tr><tr><td><code>\t</code></td><td>水平制表符，光标移到下一个Tab位置</td></tr><tr><td><code>\&#39;</code></td><td>单引号字符 ‘</td></tr><tr><td><code>\&quot;</code></td><td>双引号字符 “</td></tr><tr><td><code>\\</code></td><td>反斜杠字符 ’\’</td></tr><tr><td><code>\r</code></td><td>回车符，光标移到本行开头</td></tr><tr><td><code>\0</code></td><td>null 字符，代表没有内容。注意，这个值不等于数字0。</td></tr><tr><td><code>\b</code></td><td>退格键，光标回退一个字符，但不删除字符</td></tr></tbody></table><h3 id="4-4-布尔类型"><a href="#4-4-布尔类型" class="headerlink" title="4.4 布尔类型"></a>4.4 布尔类型</h3><p>C语言标准（C89）没有为布尔值单独设置一个类型，所以在判断真假时，使用整数 0 表示假，所有非0表示真。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> handsome = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (handsome) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我好帅!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述做法不直观，可以借助于C语言的宏定义处理。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义布尔类型的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOL int   <span class="comment">//可以使用 typedef int BOOL; 替换</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    BOOL handsome = TRUE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(handsome)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;好帅~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，C99 标准添加了类型 <code>_Bool</code>，表示布尔值，即逻辑值true和false。但是，这个类型的值其实只是整数类型的别名，还是使用 0 表示false， 1 表示true，其它非0的值都会被存储为1。所以_Bool类型实际上也是一种整数类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">_Bool</span> isFlag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (isFlag)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你好毒~~\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此同时，C99还提供了一个头文件 stdbool.h，文件中定义了<code>bool</code>代表<code>_Bool</code>，并且定义了 true 代表 1 、 false 代表 0 。只要加载这个头文件，就可以使用 bool 定义布尔值类型，以及 false 和 true 表示真假。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">bool</span> isFlag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (isFlag)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你好毒~~\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【武汉科技大学2019研】</p><p>以下选项中不属于C语言类型的是（　　）。<br>A．short int<br>B．unsigned long int<br>C．char<br>D．bool</p><p>【答案】D</p><p>【解析】C语言中没有bool型，只有C++才有boolean型，也称bool。C语言中一般用“0”表示“假”，用“1”表示“真”。</p></blockquote><blockquote><p>【四川大学2017研】有4个圆塔，圆心分别为（2，2）、（－2，2）、（－2，－2）、（2，－2），圆半径为1。这4个塔的高度为10m，塔以外无建筑物。今输入任一点的坐标，求该点的建筑高度（塔外的高度为零）。</p><p>【答案】<br>N-S图如图1所示。</p><p><img src="/img/images/1691981968969-1692326077435.png" alt="1691981968969"></p><p>​图1　计算某点建筑高度的N-S流程图<br>程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> h = <span class="number">10</span>;</span><br><span class="line"> <span class="type">float</span> x1 = <span class="number">2</span>, y1 = <span class="number">2</span>, x2 = <span class="number">-2</span>, y2 = <span class="number">-2</span>, x3 = <span class="number">-2</span>, y3 = <span class="number">-2</span>, x4 = <span class="number">2</span>, y4 = <span class="number">-2</span>;</span><br><span class="line"> <span class="type">float</span> x, y; <span class="comment">//表示随意选中的一个点的坐标</span></span><br><span class="line"> <span class="type">float</span> d1, d2, d3, d4; <span class="comment">//(x,y)这个点的坐标到各个圆心的距离</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;请输入一个点(x,y)：&quot;</span>);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%f,%f&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"> d1 = (x - x1) * (x - x1) + (y - y1) * (y - y1); <span class="comment">//求该点到各中心点距离</span></span><br><span class="line"> d2 = (x - x2) * (x - x2) + (y - y2) * (y - y2);</span><br><span class="line"> d3 = (x - x3) * (x - x3) + (y - y3) * (y - y3);</span><br><span class="line"> d4 = (x - x4) * (x - x4) + (y - y4) * (y - y4); </span><br><span class="line"> <span class="keyword">if</span> (d1 &gt; <span class="number">1</span> &amp;&amp; d2 &gt; <span class="number">1</span> &amp;&amp; d3 &gt; <span class="number">1</span> &amp;&amp; d4 &gt; <span class="number">1</span>) <span class="comment">//判断该点是否在塔外  </span></span><br><span class="line">     h = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;该点高度为%d\n&quot;</span>, h);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="5、变量间的运算规则"><a href="#5、变量间的运算规则" class="headerlink" title="5、变量间的运算规则"></a>5、变量间的运算规则</h2><p>在C语言编程中，经常需要对不同类型的数据进行运算，运算前需要先转换为同一类型，再运算。为了解决数据类型不一致的问题，需要对数据的类型进行转换。</p><h3 id="5-1-隐式类型转换"><a href="#5-1-隐式类型转换" class="headerlink" title="5.1 隐式类型转换"></a>5.1 隐式类型转换</h3><p><strong>情况1：窄类型自动转为宽类型</strong></p><p>即，系统自动将<code>字节宽度较小</code>的类型转换为<code>字节宽度较大</code>的数据类型，它是由系统自动转换完成的。</p><img src="/img/images/image-20220523162200891.png" alt="image-20220523162200891" style="zoom:67%;" /><p>基本数据类型的转换规则如图所示：</p><img src="/img/images/1688632254232.png" alt="image-20230824194145734"  /><blockquote><p>注意：最好避免无符号整数与有符号整数的混合运算。因为这时 C 语言会自动将 signed int 转为unsigned int ，可能不会得到预期的结果。</p></blockquote><p>举例1：</p><ul><li>不同的整数类型混合运算时，宽度较小的类型会提升为宽度较大的类型。比如 short 转为 int ，int 转为 long 等。</li><li>不同的浮点数类型混合运算时，宽度较小的类型转为宽度较大的类型，比如 float 转为double ， double 转为 long double 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> y = <span class="number">12</span> * <span class="number">2</span>; <span class="comment">//整数赋值给浮点数变量时，会自动转为浮点数。结果24.0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//char类型 与 int类型运算，会自动提升为 int 。</span></span><br><span class="line"><span class="type">char</span> c = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> j = c + i;  <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> s1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> num1 = s1;    <span class="comment">//ok</span></span><br><span class="line"><span class="type">double</span> num2 = s1; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> d1 = <span class="number">12.3</span>;</span><br><span class="line"><span class="type">double</span> d2 = i + d1; <span class="comment">//系统自动将i的类型由int转换为double类型，故i+d1结果为double类型</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d;</span><br><span class="line">d = <span class="number">2</span> + <span class="string">&#x27;A&#x27;</span> + <span class="number">1.5F</span>;</span><br></pre></td></tr></table></figure><p>举例2：</p><p>两个相同类型的整数运算时，或者单个整数的运算，一般来说，运算结果也属于同一类型。但是有例外，宽度小于 int 的类型，运算结果会自动提升为 int 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">short</span> s1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> i1 = c1 + s1;  <span class="comment">//char类型和short类型的变量运算的结果默认为int类型</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b = <span class="number">255</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((a - <span class="number">5</span>) &lt; <span class="number">0</span>) </span><br><span class="line">    do_something();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((b + c) &gt; <span class="number">300</span>) </span><br><span class="line">    do_something();</span><br></pre></td></tr></table></figure><p>说明：表达式 a - 5 和 b + c 都会自动转为 int 类型，所以函数 do_something() 会执行两次。</p><p><strong>情况2：宽类型赋值给窄类型</strong></p><p><code>字节宽度较大</code>的类型，赋值给<code>字节宽度较小</code>的变量时，会发生类型降级，自动转为后者的类型。这时可能会发生截值（truncation），系统会自动截去多余的数据位，导致精度损失。</p><blockquote><p>这反映了C语言在检查类型匹配方面不太严格。最好不要养成这样的习惯。</p></blockquote><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">int</span> i = pi; <span class="comment">// i 的值为 3</span></span><br></pre></td></tr></table></figure><p>C编译器把浮点数转换成整数时，会直接丢弃（截断）小数部分，而不进行四舍五入。</p><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3.14</span>; <span class="comment">//浮点数赋予整数变量时，C 语言直接丢弃小数部分。结果 3</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cost = <span class="number">12.99</span>;          <span class="comment">// double类型的值转为int类型,结果为：12</span></span><br><span class="line"><span class="type">float</span> pi = <span class="number">3.1415926536</span>;     <span class="comment">// double类型的值转为float类型,结果为：3.141593</span></span><br></pre></td></tr></table></figure><p>举例3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">322</span>;</span><br><span class="line"><span class="type">char</span> ch = i; <span class="comment">// ch 的值是 66</span></span><br></pre></td></tr></table></figure><p>图示：</p><img src="/img/images/image-20230626213244132.png" alt="image-20230626213244132" style="zoom: 80%;" /><img src="/img/images/image-20230626213317271.png" alt="image-20230626213317271" style="zoom:80%;" /><p>举例4：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f1 = <span class="number">1.1f</span>; <span class="comment">//ok</span></span><br><span class="line"><span class="type">double</span> d2 = <span class="number">4.58667435</span>;</span><br><span class="line">f1 = d2; <span class="comment">// 出现精度损失 (double -&gt; float )</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;f1=%.8f&quot;</span>, f1); <span class="comment">// 期望： 4.58667435</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于存在精度限制，浮点数只是一个近似值，它的计算是不精确的。</p><p>举例5：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">3.14159</span>; <span class="comment">//3.14159为双精度浮点常量，分配8个字节；a为float变量，分配4个字节</span></span><br></pre></td></tr></table></figure><p>编译时系统会发出警告(warning: truncation from ′const double′ to′float′)，提醒用户注意这种转换可能损失精度。</p><h3 id="5-2-强制类型转换"><a href="#5-2-强制类型转换" class="headerlink" title="5.2 强制类型转换"></a>5.2 强制类型转换</h3><p>隐式类型转换中的宽类型赋值给窄类型，编译器是会产生警告的，提示程序存在潜在的隐患。如果非常明确地希望转换数据类型，就需要用到<code>强制(或显式)类型转换</code>。</p><p>形式： <strong>(类型名称)(变量、常量或表达式)</strong></p><p>功能：将“变量、常量或表达式”的运算结果强制转换为“类型名称”所表示的数据类型。</p><p>注意：强制类型转换会导致精度损失。</p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="number">12.3</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> z = (<span class="type">int</span>)x + y; <span class="comment">//将变量x的值转换成int后,再与y相加</span></span><br></pre></td></tr></table></figure><p>将浮点数转换为整数时，将舍弃浮点数的小数部分，只保留整数部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f1,f2;</span><br><span class="line">f1 = (<span class="type">int</span>)<span class="number">1.2</span> + <span class="number">3.4</span>;</span><br><span class="line">f2 = (<span class="type">int</span>)(<span class="number">1.2</span> + <span class="number">3.4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;f1=%f,f2=%f&quot;</span>,f1,f2);</span><br></pre></td></tr></table></figure><p>输出结果：f1&#x3D;4.4，f2&#x3D;4.0。</p><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">40000</span>;</span><br><span class="line"><span class="type">short</span> s = (<span class="type">short</span>)i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s); <span class="comment">//-25536</span></span><br></pre></td></tr></table></figure><p>举例3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> y = (<span class="type">long</span>) <span class="number">10</span> + <span class="number">12</span>; <span class="comment">// (long) 将 10 显式转为 long 类型。这里的显示转换其实是不必要的,因为可以自动转换</span></span><br></pre></td></tr></table></figure><h3 id="5-3-运算的溢出问题"><a href="#5-3-运算的溢出问题" class="headerlink" title="5.3 运算的溢出问题"></a>5.3 运算的溢出问题</h3><p>每一种数据类型都有数值范围，如果存放的数值超出了这个范围（小于最小值或大于最大值），需要更多的二进制位存储，就会发生溢出。大于最大值，叫做<code>向上溢出（overflow）</code>；小于最小值，叫做<code>向下溢出（underflow）</code>。</p><p>一般来说，编译器不会对溢出报错，会正常执行代码，但是会忽略多出来的二进制位，只保留剩下的位，这样往往会得到意想不到的结果。所以，应该避免溢出。</p><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> x = <span class="number">255</span>;</span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p> x 是 unsign char 类型，最大值是255 （二进制 11111111 ），加 1 后就发生了溢出， 256 （二进制 100000000 ）的最高位 1 被丢弃，剩下的值就是 0 。</p><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui = UINT_MAX;  <span class="comment">// 4,294,967,295</span></span><br><span class="line">ui++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ui = %u\n&quot;</span>, ui); <span class="comment">// 0</span></span><br><span class="line">ui--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ui = %u\n&quot;</span>, ui); <span class="comment">// 4,294,967,295</span></span><br></pre></td></tr></table></figure><p>常量 UINT_MAX 是 unsigned int 类型的最大值。如果加 1 ，对于该类型就会溢出，从而得到 0 ；而 0 是该类型的最小值，再减 1 ，又会得到 UINT_MAX 。</p><blockquote><p>溢出很容易被忽视，编译器又不会报错，所以必须非常小心。</p></blockquote><h2 id="6、常量"><a href="#6、常量" class="headerlink" title="6、常量"></a>6、常量</h2><h3 id="6-1-常量分类"><a href="#6-1-常量分类" class="headerlink" title="6.1 常量分类"></a>6.1 常量分类</h3><p>程序运行时，其值不能改变的量，即为<code>常量</code>。</p><p>C语言中的常量分为以下以下几种：</p><ul><li>字面常量</li><li>#define 定义的标识符常量</li><li>const 修饰的常变量</li><li>枚举常量</li></ul><p>举例：字面常量</p><p>1、2、12是整型常量，2.1、12.5、3.14是实型常量，’a’、 ‘b’、’c’是字符型常量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//字面常量</span></span><br><span class="line"><span class="number">3.14</span>;<span class="comment">//字面常量</span></span><br><span class="line"><span class="number">1000</span>;<span class="comment">//字面常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-多种方式定义常量"><a href="#6-2-多种方式定义常量" class="headerlink" title="6.2 多种方式定义常量"></a>6.2 多种方式定义常量</h3><h4 id="6-2-1-使用-define"><a href="#6-2-1-使用-define" class="headerlink" title="6.2.1 使用#define"></a>6.2.1 使用#define</h4><p>这种方式是在文件开头用 #define 来定义常量，也叫作“宏定义”。所谓宏定义，<strong>就是用一个标识符来表示一个常量值</strong>，如果在后面的代码中出现了该标识符，那么编译时就全部替换成指定的常量值。即用宏体替换所有宏名，简称<code>宏替换</code>。</p><p>定义格式：<code>#define 符号常量名 常量值</code></p><ul><li>符号常量名，称为<code>宏体</code>，属于标识符，一般定义时用大写字母表示。</li><li>常量值，称为<code>宏名</code>，可以是数值常量，也可以是字符常量。</li></ul><p>习惯上，<strong>宏名用大写字母表示</strong>，以便于与变量区别。但也允许用小写字母。</p><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZERO 0   <span class="comment">//#define的标识符常量</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;zero = %d\n&quot;</span>, ZERO);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>跟#include一样，“#”开头的语句都是“预处理语句”，在编译之前，预处理器会查找程序中所有的“ZERO”，并把它替换成0，这个过程称为预编译处理。</p><p>然后将预处理的结果和源程序一起再进行通常的编译处理，以得到目标代码 (OBJ文件)。</p></blockquote><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI = 3.14  <span class="comment">// 定义常量 PI，常量值 3.14。因为宏定义不是 C 语句，后面不能有分号</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//PI = 3.1415  可以吗? =&gt; 不可以</span></span><br><span class="line">  <span class="type">double</span> area;</span><br><span class="line">  <span class="type">double</span> r = <span class="number">1.2</span>;</span><br><span class="line">  area = PI * r * r;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;面积 : %.2f&quot;</span>, area);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数结果状态代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -2</span></span><br></pre></td></tr></table></figure><blockquote><p>#define 对于考研数据结构来说没有什么贡献，我们只要认得它就行。</p><p>例如1，<code>#define MAX_Size 50</code>这句，即定义了常量<code>MAX_Size</code>(此时x &#x3D; 50;等价于x &#x3D; MAX_Size;)。</p><p>例如2，你要定义一个数组，如<code>int A[MAX_Size];</code>，加上一句注释“<code>/*MAX_Size为已经定义的常量，其值为50*/</code>”即可。</p></blockquote><h4 id="6-2-2-使用const限定符"><a href="#6-2-2-使用const限定符" class="headerlink" title="6.2.2 使用const限定符"></a>6.2.2 使用const限定符</h4><p>C99中新的声明方式，这种方式跟定义一个变量是一样的，只需要在变量的数据类型前再加上一个const关键字，这被称为“限定符”。</p><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> 数据类型 常量名 = 常量值;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//const 修饰的常变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.14f</span>;</span><br><span class="line"><span class="comment">//PI = 5.14;//是不能直接修改的！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const修饰的对象一旦创建就不能改变，所以必须初始化。</p><p>跟使用 #define定义宏常量相比，const定义的常量有详细的数据类型，而且会在编译阶段进行安全检查，在运行时才完成替换，所以会更加安全和方便。</p><h4 id="6-3-3-定义枚举常量"><a href="#6-3-3-定义枚举常量" class="headerlink" title="6.3.3 定义枚举常量"></a>6.3.3 定义枚举常量</h4><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用enum定义枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span>&#123;</span></span><br><span class="line">    <span class="comment">//括号中的MALE,FEMALE,SECRET是枚举常量</span></span><br><span class="line">MALE,</span><br><span class="line">FEMALE,</span><br><span class="line">SECRET</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//枚举常量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, MALE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, FEMALE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, SECRET);</span><br><span class="line"><span class="comment">//注：枚举常量默认是从0开始，依次向下递增1的</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>【北京航空航天大学2018研】若已知有如下宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  CANBERRA(x,y)  ((x－y)/(x＋y))</span></span><br></pre></td></tr></table></figure><p>则以下表达式中，返回结果值最大的是（　　）。<br>A．CANBERRA（3.0，2.0）；<br>B．CANBERRA（4.0，1.0）；<br>C．CANBERRA（1.0＋2.0，0.0＋2.0）；<br>D．CANBERRA（1.0＋2.0，1.0＋1.0）；</p><p>【答案】C</p><p>【解析】A项中为1.0&#x2F;5.0，结果为0.2；B项中为3.0&#x2F;5.0，结果为0.6；C项中的宏替换后为（1.0＋2.0－0.0＋2.0）&#x2F;（1.0＋2.0＋0＋2.0）＝1.0；D项中宏替换后为（1.0＋2.0－1.0＋1.0）&#x2F;（1.0＋2.0＋1.0＋1.0）＝0.6，因此最后答案为C。</p></blockquote><blockquote><p>【中央财经大学2018研】若有如下宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  N  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  y(n)  ((N＋1)*n)</span></span><br></pre></td></tr></table></figure><p>则执行下列语句：z＝4*(N＋y(5))；后的结果是（　　）。<br>A．语句有错误<br>B．z值为68<br>C．z值为60<br>D．z值为180</p><p>【答案】B</p><p>【解析】y(5)＝15，z＝4*(N＋y(5))＝4*17＝68，答案选B。</p></blockquote><h2 id="7、输入-输出函数"><a href="#7、输入-输出函数" class="headerlink" title="7、输入&#x2F;输出函数"></a>7、输入&#x2F;输出函数</h2><p>所谓输入输出是以计算机主机为主体而言的。</p><ul><li>输出：从计算机向外部输出设备(显示器、打印机)输出数据。</li><li>输入：从输入设备(键盘、鼠标、扫描仪)向计算机输入数据。</li></ul><img src="/img/images/image-20230824232336985.png" alt="image-20230824232336985" style="zoom:50%;" /><p>c语言本身没有提供专门的输入输出语句，所有的输入输出都是由调用标准库函数中的输入输出函数来实现的。</p><p><strong>输入函数：scanf() 、 getchar()、gets()：</strong> </p><ul><li>scanf()，是格式输入函数，可接收<code>任意类型</code>的数据。 </li><li>getchar()，是<code>字符</code>输入函数， 只能接收<code>单个字符</code>。</li><li>gets()，是<code>字符串</code>输入函数。</li></ul><p><strong>输出函数：printf() 、 putchar()、puts()：</strong></p><ul><li>printf()，是格式输出函数，可按指定的格式显示任意类型的数据。</li><li>putchar()，<code>字符</code>显示函数，只能显示<code>单个字符</code>。</li><li>puts()，是<code>字符串</code>输出函数。</li></ul><h3 id="7-1-scanf-的使用"><a href="#7-1-scanf-的使用" class="headerlink" title="7.1 scanf()的使用"></a>7.1 scanf()的使用</h3><p>scanf()函数的作用：把从键盘上输入的数据根据找到的地址存入内存中，即给变量赋值。</p><p>格式： <code>scanf(&quot;格式控制字符串&quot;,参数地址列表); </code></p><ul><li>“格式控制字符串”：约定输入数据的类型和格式，参数的个数必须与变量地址的个数一致。</li><li>“参数地址列表”：以逗号 “, ”分隔的、<code>输入数据变量地址</code>序列。</li></ul><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c)</span><br></pre></td></tr></table></figure><p>其中，&amp;a,&amp;b,&amp;c中的<code>&amp;</code>是寻址操作符，&amp;a表示对象a在内存中的地址。</p><p>注意，</p><ul><li>如果scanf中%d是连着写的，如“<code>%d%d%d</code>”，在输入数据时，数据之间不可以用逗号分隔，只能用空白字符（空格或tab键或者回车键）分隔。即“<code>2(空格)3(tab)4</code>” 或 “<code>2(tab)3(回车)4</code>”等。</li><li>如果是“<code>%d,%d,%d</code>”，则在输入数据时需要加“,”，如“<code>2,3,4</code>”。</li></ul><p>举例1：计算圆的面积，其半径由用户指定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> radius, area;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入半径值：  &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;radius);      <span class="comment">//输入半径</span></span><br><span class="line">    area = <span class="number">3.14</span> * radius * radius;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;area=%f\n&quot;</span>, area); <span class="comment">//输出圆的面积</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：变量名之前要加上&amp;运算符，表示取变量的地址，如“&amp;a，&amp;b”。否则将会出现错误。</p></blockquote><p>举例2：输入一个整数，求其绝对值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入一个整数:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="type">int</span> absNum = num;</span><br><span class="line">    <span class="keyword">if</span>(absNum &lt; <span class="number">0</span>)</span><br><span class="line">        absNum = -absNum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 整数:%d---&gt;绝对值为:%d\n&quot;</span>, num, absNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例3：输入多个变量的值，求乘积</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入整数a,b:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    c=a*b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%d\n&quot;</span>,a,b,c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【武汉科技大学2019研】若有声明语句：int x； char y[20]； double z；则正确的输入语句是（　）。<br>A．scanf（”%d%c%le\n”，&amp;x，&amp;y，&amp;z）；<br>B．scanf（”%2d%s%lf”，&amp;x，&amp;y，&amp;z）；<br>C．scanf（”%d%s%lf”，&amp;x，y，&amp;z）；<br>D．scanf（”%x%s%3.2f”，&amp;x，y，&amp;z）；</p><p>【答案】C</p><p>【解析】y为一维数组名，指向数组首元素的地址，因此不需要再使用取地址运算符&amp;，AB错误；D中%3.2f表示长度为3，小数为2位，但是小数点也占一位，因此D错误，答案选C。</p></blockquote><h3 id="7-2-getchar-与putchar-的使用"><a href="#7-2-getchar-与putchar-的使用" class="headerlink" title="7.2 getchar()与putchar()的使用"></a>7.2 getchar()与putchar()的使用</h3><ul><li><p>getchar()：输入字符数据</p><ul><li>格式：getchar()</li><li>功能：从键盘缓冲区读入一个字符</li></ul></li><li><p>putchar()：输出字符</p><ul><li>格式： putchar(ch)，其中ch是一个字符变量</li><li>功能：从标准输出设备输出一个字符</li></ul></li></ul><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>); <span class="comment">//输出单个字符A</span></span><br><span class="line"><span class="built_in">putchar</span>(c);   <span class="comment">//输出变量c的ASCII对应字符</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>); <span class="comment">//执行换行效果，屏幕不显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    ch = getchar();</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-gets-与puts-的使用-超纲"><a href="#7-3-gets-与puts-的使用-超纲" class="headerlink" title="7.3 gets()与puts()的使用(超纲)"></a>7.3 gets()与puts()的使用(超纲)</h3><p><strong>puts()：</strong></p><p>在C语言中，puts() 是一个用于输出字符串的标准库函数，其原型定义在 <code>&lt;stdio.h&gt;</code> 头文件中。<code>puts()</code> 函数的作用是将一个以 null 字符（<code>\0</code>）结尾的字符串打印到标准输出（通常是控制台）上，并自动添加一个换行符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str1[]=&#123;<span class="string">&quot;China\nBeijing&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(str1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(str2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，puts()函数只能用于输出字符串，而不能输出其他类型的数据。如果需要输出其他类型的数据，应使用 <code>printf()</code> 函数。</p><p><strong>gets()：</strong></p><p>读取标准输入设备输入的字符串，直到遇到【Enter】键才结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">20</span>];   <span class="comment">//定义一个数组</span></span><br><span class="line">gets(str);      <span class="comment">//获取输入的字符串,存放到字符数组中</span></span><br></pre></td></tr></table></figure><p>举例：字符串的读写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str[<span class="number">15</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enter your name:&quot;</span>);</span><br><span class="line">    gets(str);        <span class="comment">//输入字符串至数组变量str</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;your name is &quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(str);        <span class="comment">//输出字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、变量按声明位置的分类-后面讲"><a href="#8、变量按声明位置的分类-后面讲" class="headerlink" title="8、变量按声明位置的分类(后面讲)"></a>8、变量按声明位置的分类(后面讲)</h2><p>变量按照声明的位置，可以分为：局部变量 和 全局变量。</p><ul><li><p><strong>局部变量</strong></p><ul><li>在<code>函数体内定义</code>的变量，也称内部变量。局部变量只能在定义它的函数中使用。</li></ul></li><li><p><strong>全局变量</strong></p><ul><li><p>在<code>函数之外</code>定义的变量称为外部变量，外部变量是<code>全局变量</code>（也称全程变量）。</p></li><li><p>一个程序中，凡是在全局变量之后定义的函数，都可以使用在其之前定义的全局变量。</p></li></ul></li></ul><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global = <span class="number">2023</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> local = <span class="number">2022</span>;<span class="comment">//局部变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面定义的global会不会报错？</span></span><br><span class="line">    <span class="type">int</span> global = <span class="number">2024</span>;<span class="comment">//局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global = %d\n&quot;</span>, global);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当局部变量和全局变量同名的时候，局部变量优先使用。</p></blockquote><h2 id="9、常见的进制"><a href="#9、常见的进制" class="headerlink" title="9、常见的进制"></a>9、常见的进制</h2><h3 id="9-1-二进制概述"><a href="#9-1-二进制概述" class="headerlink" title="9.1 二进制概述"></a>9.1 二进制概述</h3><p><strong>计算机底层如何存储数据呢？</strong></p><blockquote><p>计算机世界中只有二进制，所以计算机中存储和运算的<code>所有数据</code>都要转为<code>二进制</code>。包括数字、字符、图片、声音、视频等。</p></blockquote><img src="/img/images/010101.jpg" alt="010101" style="zoom: 33%;" /><blockquote><p><strong>世界上有10种人 ，认识和不认识二进制的。</strong></p></blockquote><p><strong>二进制的由来</strong></p><p>二进制，是计算技术中广泛采用的一种数制，由德国数理哲学大师<code>莱布尼茨</code>于1679年发明。</p><p>二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“<code>逢二进一</code>”。</p><p><strong>二进制的应用</strong></p><p>二进制广泛应用于我们生活的方方面面。比如，广泛使用的摩尔斯电码（Morse Code），它由两种基本信号组成：短促的点信号“<code>·</code>”，读“<code>滴</code>”；保持一定时间的长信号“<code>—</code>”，读“<code>嗒</code>”。然后，组成了26个字母，从而拼写出相应的单词。</p><img src="/img/images/image-20220520105721126.png" alt="image-20220520105721126" style="zoom:67%;" /><p>我们偶尔会看到的：SOS，即为：</p><p><img src="/img/images/image-20220520110206899.png" alt="image-20220520110206899"></p><h3 id="9-2-进制的分类"><a href="#9-2-进制的分类" class="headerlink" title="9.2 进制的分类"></a>9.2 进制的分类</h3><ul><li><p><strong>十进制（decimal）</strong></p><ul><li>数字组成：0-9</li><li>进位规则：满十进一</li><li>C 语言的整数默认都是十进制数</li></ul></li><li><p><strong>二进制（binary）</strong></p><ul><li>数字组成：0-1</li><li>进位规则：满二进一，以<code>0b</code>或<code>0B</code>开头</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0b101010</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>八进制（octal）：很少使用</strong></p><ul><li>数字组成：0-7</li><li>进位规则：满八进一，以数字<code>0</code>开头表示</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">012</span>; <span class="comment">// 八进制，相当于十进制的10</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">017</span>; <span class="comment">// 八进制，相当于十进制的15</span></span><br></pre></td></tr></table></figure></li><li><p><strong>十六进制</strong></p><ul><li>数字组成：0-9，a-f</li><li>进位规则：满十六进一，以<code>0x</code>或<code>0X</code>开头表示。此处的 a-f 不区分大小写</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0x1A2B</span>; <span class="comment">// 十六进制，相当于十进制的6699</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">0X10</span>;   <span class="comment">// 十六进制，相当于十进制的16</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="9-3-进制的换算举例"><a href="#9-3-进制的换算举例" class="headerlink" title="9.3 进制的换算举例"></a>9.3 进制的换算举例</h3><table><thead><tr><th>十进制</th><th>二进制</th><th>八进制</th><th>十六进制</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>10</td><td>2</td><td>2</td></tr><tr><td>3</td><td>11</td><td>3</td><td>3</td></tr><tr><td>4</td><td>100</td><td>4</td><td>4</td></tr><tr><td>5</td><td>101</td><td>5</td><td>5</td></tr><tr><td>6</td><td>110</td><td>6</td><td>6</td></tr><tr><td>7</td><td>111</td><td>7</td><td>7</td></tr><tr><td>8</td><td>1000</td><td>10</td><td>8</td></tr><tr><td>9</td><td>1001</td><td>11</td><td>9</td></tr><tr><td>10</td><td>1010</td><td>12</td><td>a或A</td></tr><tr><td>11</td><td>1011</td><td>13</td><td>b或B</td></tr><tr><td>12</td><td>1100</td><td>14</td><td>c或C</td></tr><tr><td>13</td><td>1101</td><td>15</td><td>d或D</td></tr><tr><td>14</td><td>1110</td><td>16</td><td>e或E</td></tr><tr><td>15</td><td>1111</td><td>17</td><td>f或F</td></tr><tr><td>16</td><td>10000</td><td>20</td><td>10</td></tr></tbody></table><h3 id="9-4-输出格式"><a href="#9-4-输出格式" class="headerlink" title="9.4 输出格式"></a>9.4 输出格式</h3><p>不同的进制只是整数的书写方法不同，不会对整数的实际存储方式产生影响。不同进制可以混合使用，比如 10 + 015 + 0x20 是一个合法的表达式。</p><p>printf() 的进制相关占位符如下：</p><ul><li><p>%d ：十进制整数。</p></li><li><p>%o ：八进制整数。</p></li><li><p>%x ：十六进制整数。</p></li><li><p>%#o ：显示前缀 0 的八进制整数。</p></li><li><p>%#x ：显示前缀 0x 的十六进制整数。</p></li><li><p>%#X ：显示前缀 0X 的十六进制整数。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dec = %d\n&quot;</span>, x); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;octal = %o\n&quot;</span>, x); <span class="comment">// 144</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hex = %x\n&quot;</span>, x); <span class="comment">// 64</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;octal = %#o\n&quot;</span>, x); <span class="comment">// 0144</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hex = %#x\n&quot;</span>, x); <span class="comment">// 0x64</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hex = %#X\n&quot;</span>, x); <span class="comment">// 0X64</span></span><br></pre></td></tr></table></figure><h3 id="9-5-进制间的转换-了解"><a href="#9-5-进制间的转换-了解" class="headerlink" title="9.5 进制间的转换(了解)"></a>9.5 进制间的转换(了解)</h3><h4 id="9-5-1-二进制如何表示整数？"><a href="#9-5-1-二进制如何表示整数？" class="headerlink" title="9.5.1 二进制如何表示整数？"></a>9.5.1 二进制如何表示整数？</h4><ul><li><p>计算机数据的存储使用二进制<code>补码</code>形式存储，并且<code>最高位是符号位</code>。</p><ul><li>正数：<code>最高位是0</code></li><li>负数：<code>最高位是1</code></li></ul></li><li><p>规定1：正数的补码与反码、原码一样，称为<code>三码合一</code></p></li><li><p>规定2：负数的补码与反码、原码不一样：</p><ul><li>负数的<code>原码</code>：把十进制转为二进制，然后最高位设置为1</li><li>负数的<code>反码</code>：在原码的基础上，最高位不变，其余位取反（0变1,1变0）</li><li>负数的<code>补码</code>：反码+1</li></ul></li></ul><h4 id="9-5-2-二进制与十进制间的转换"><a href="#9-5-2-二进制与十进制间的转换" class="headerlink" title="9.5.2 二进制与十进制间的转换"></a>9.5.2 二进制与十进制间的转换</h4><p><img src="/img/images/1689209516368.png" alt="1689209516368"></p><p><strong>二进制转十进制：权相加法</strong></p><p>针对于一个字节的数据举例来说：</p><p><img src="/img/images/1689212021511.png" alt="1689212021511"></p><ul><li><p>例如：1个字节（8位）</p><p>25 &#x3D;&#x3D;&gt; 原码  0001 1001 &#x3D;&#x3D;&gt; 反码  0001 1001 –&gt;补码  0001 1001</p><p>-25 &#x3D;&#x3D;&gt;原码  1001 1001 &#x3D;&#x3D;&gt; 反码1110 0110 &#x3D;&#x3D;&gt;补码 1110 0111</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">整数：</span><br><span class="line">正数：<span class="number">25</span>   <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">000000000</span> <span class="number">00011001</span>（原码）</span><br><span class="line">正数：<span class="number">25</span>   <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">000000000</span> <span class="number">00011001</span>（反码）</span><br><span class="line">正数：<span class="number">25</span>   <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">000000000</span> <span class="number">00011001</span>（补码）</span><br><span class="line"></span><br><span class="line">负数：-<span class="number">25</span>  <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">000000000</span> <span class="number">00011001</span>（原码）</span><br><span class="line">负数：-<span class="number">25</span>  <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111111111</span> <span class="number">11100110</span>（反码）</span><br><span class="line">负数：-<span class="number">25</span>  <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111111111</span> <span class="number">11100111</span>（补码）</span><br></pre></td></tr></table></figure><p><strong>一个字节可以存储的整数范围是多少？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1个字节：8位</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000</span> <span class="number">0001</span>  ~  <span class="number">0111</span> <span class="number">111</span> ==&gt; <span class="number">1</span>~<span class="number">127</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> <span class="number">0001</span> ~ <span class="number">1111</span> <span class="number">1111</span> ==&gt; -<span class="number">127</span> ~ -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> ==&gt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> ==&gt; -<span class="number">128</span>（特殊规定）=-<span class="number">127</span>-<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>十进制转二进制</strong></p><p>十进制转二进制：<code>除2取余的逆</code></p><p><img src="/img/images/1689214597038.png" alt="1689214597038"></p><h4 id="9-5-3-二进制与八进制、十六进制间的转换"><a href="#9-5-3-二进制与八进制、十六进制间的转换" class="headerlink" title="9.5.3 二进制与八进制、十六进制间的转换"></a>9.5.3 二进制与八进制、十六进制间的转换</h4><p><strong>二进制转八进制</strong></p><p><img src="/img/images/image-20230808151057231.png" alt="image-20230808151057231"></p><p><strong>二进制转十六进制</strong></p><p><img src="/img/images/image-20230808151152468.png" alt="image-20230808151152468"></p><p><strong>八进制、十六进制转二进制</strong></p><p><img src="/img/images/1689216401546.png" alt="1689216401546"></p><p><img src="/img/images/1689216597551.png" alt="1689216597551"></p><blockquote><p>练习：以下叙述中错误的是（　　）。<br>A．C程序在运行过程中所有计算都以十进制方式进行<br>B．C程序在运行过程中所有计算都以二进制方式进行<br>C．所有C程序都需要编译链接无误后才能运行<br>D．C程序中字符变量存放的是字符的ASCII值</p><p>【答案】A</p><p>【解析】C程序在运行过程中所有计算都以二进制方式进行。答案选择A选项。</p></blockquote><blockquote><p> 【华南理工大学2018研】与十进制1100等值的十六进制数是（　　）。<br> A．44A<br> B．44C<br> C．54A<br> D．54C</p><p> 【答案】B</p><p> 【解析】1100转换成二进制为0100 0100 1100，因此转换为十六进制为44C。</p></blockquote><h1 id="第03章-运算符与流程控制"><a href="#第03章-运算符与流程控制" class="headerlink" title="第03章_运算符与流程控制"></a>第03章_运算符与流程控制</h1><h2 id="本章专题脉络-2"><a href="#本章专题脉络-2" class="headerlink" title="本章专题脉络"></a>本章专题脉络</h2><p><img src="/img/images/%E7%AC%AC3%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.png" alt="第3章_运算符与流程控制"></p><h2 id="1-运算符（Operator）"><a href="#1-运算符（Operator）" class="headerlink" title="1. 运算符（Operator）"></a>1. 运算符（Operator）</h2><p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。</p><p>运算符的分类：</p><ul><li>按照<code>功能</code>分为：算术运算符、赋值运算符、比较(或关系)运算符、逻辑运算符、位运算符、条件运算符、sizeof运算符</li></ul><table><thead><tr><th align="center">分类</th><th align="center">运算符</th></tr></thead><tbody><tr><td align="center">算术运算符</td><td align="center">+、-、+、-、*、&#x2F;、%、++、–</td></tr><tr><td align="center">赋值运算符</td><td align="center">&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;等</td></tr><tr><td align="center">比较(或关系)运算符</td><td align="center">&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&#x3D;&#x3D;、!&#x3D;</td></tr><tr><td align="center">逻辑运算符</td><td align="center">&amp;&amp;、||、!</td></tr><tr><td align="center">位运算符</td><td align="center">&amp;、|、^、~、&lt;&lt;、&gt;&gt;</td></tr><tr><td align="center">条件运算符</td><td align="center">(条件表达式)?结果1:结果2</td></tr><tr><td align="center">sizeof运算符</td><td align="center">sizeof()</td></tr></tbody></table><ul><li>按照<code>操作数个数</code>分为：一元运算符（单目运算符）、二元运算符（双目运算符）、三元运算符 （三目运算符）</li></ul><table><thead><tr><th align="center">分类</th><th align="center">运算符</th></tr></thead><tbody><tr><td align="center">一元运算符（单目运算符）</td><td align="center">正号（+）、负号（-）、++、–、!、~</td></tr><tr><td align="center">二元运算符（双目运算符）</td><td align="center">除了一元和三元运算符剩下的都是二元运算符</td></tr><tr><td align="center">三元运算符 （三目运算符）</td><td align="center">(条件表达式)?结果1:结果2</td></tr></tbody></table><h3 id="1-1-算术运算符"><a href="#1-1-算术运算符" class="headerlink" title="1.1 算术运算符"></a>1.1 算术运算符</h3><p>算术运算符专门用于算术运算，主要有下面几种。</p><p><img src="/img/images/image-20230629164033704.png" alt="image-20230629164033704"></p><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">-12</span>;</span><br><span class="line"><span class="type">int</span> y = -x;</span><br><span class="line"><span class="type">int</span> z = +y; <span class="comment">//+可以省略</span></span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">4</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num * num); <span class="comment">// 输出 25</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> x = <span class="number">6</span> / <span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, x); <span class="comment">// 输出 1.000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> x = <span class="number">6.0</span> / <span class="number">4</span>; <span class="comment">// 或者写成 6 / 4.0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, x); <span class="comment">// 输出 1.500000</span></span><br></pre></td></tr></table></figure><p>举例3：%，运算结果的符号与被模数相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x1 = <span class="number">6</span> % <span class="number">4</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="type">int</span> x2 = <span class="number">-6</span> % <span class="number">4</span>; <span class="comment">// -2</span></span><br><span class="line"><span class="type">int</span> x3 = <span class="number">6</span> % <span class="number">-4</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="type">int</span> x4 = <span class="number">-6</span> % <span class="number">-4</span>; <span class="comment">// -2</span></span><br></pre></td></tr></table></figure><p>举例4：自加自减运算</p><p>理解：<code>++</code>  运算，表示<code>自增1</code>。同理，<code>--</code> 运算，表示<code>自减1</code>，用法与++ 一致。</p><p>1、单独使用</p><ul><li>变量在单独运算的时候，变量<code>前++</code>和变量<code>后++</code>，是没有区别的。</li><li>变量<code>前++</code>   ：例如 <code>++a</code> 。</li><li>变量<code>后++</code>   ：例如 <code>a++</code> 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//++a;</span></span><br><span class="line">    a++;</span><br><span class="line">    <span class="comment">//无论是变量前++还是变量后++，结果都是11</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、复合使用</p><ul><li>和<code>其他变量放在一起使用</code>或者和<code>输出语句放在一起使用</code>，<code>前++</code>和<code>后++</code>就产生了不同。</li></ul><ul><li>变量<code>前++</code> ：变量先自增1，然后再运算。</li><li>变量<code>后++</code> ：变量先运算，然后再自增1。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 其他变量放在一起使用</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//int y = ++x; // y的值是4，x的值是4，</span></span><br><span class="line">    <span class="type">int</span> y = x++; <span class="comment">// y的值是3，x的值是4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;==========\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和输出语句一起</span></span><br><span class="line">    <span class="type">int</span> z = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,++z);// 输出结果是6，z的值也是6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,z++);<span class="comment">// 输出结果是5，z的值是6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此对应的：</p><ul><li>变量<code>前--</code> ：变量先自减1，然后再运算。</li><li>变量<code>后--</code> ：变量先运算，然后再自减1。</li></ul><p><strong>案例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">随意给出一个整数，打印显示它的个位数，十位数，百位数的值。</span><br><span class="line">格式如下：</span><br><span class="line">数字xxx的情况如下：</span><br><span class="line">个位数：</span><br><span class="line">十位数：</span><br><span class="line">百位数：</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">数字153的情况如下：</span><br><span class="line">个位数：3</span><br><span class="line">十位数：5</span><br><span class="line">百位数：1</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">153</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bai = num / <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> shi = num % <span class="number">100</span> / <span class="number">10</span>;<span class="comment">//int shi = num / 10 % 10;</span></span><br><span class="line">    <span class="type">int</span> ge = num % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;百位为：%d\n&quot;</span>, bai);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;十位为：%d\n&quot;</span>, shi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;个位为：%d\n&quot;</span>, ge);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**案例2：**为抵抗洪水，战士连续作战89小时，编程计算共多少天零多少小时？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> hours = <span class="number">89</span>;</span><br><span class="line">    <span class="type">int</span> day = hours / <span class="number">24</span>;</span><br><span class="line">    <span class="type">int</span> hour = hours % <span class="number">24</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;为抵抗洪水，战士连续作战%d小时：是%d天%d小时\n&quot;</span>,hours,day,hour);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-赋值运算符"><a href="#1-2-赋值运算符" class="headerlink" title="1.2 赋值运算符"></a>1.2 赋值运算符</h3><ul><li>符号 &#x3D; <ul><li>当“&#x3D;”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理。</li><li>支持<code>连续赋值</code>。</li></ul></li><li>扩展赋值运算符： +&#x3D;、 -&#x3D;、*&#x3D;、 &#x2F;&#x3D;、%&#x3D;</li></ul><table><thead><tr><th>运算符</th><th>名称</th><th>实例</th><th>展开形式</th></tr></thead><tbody><tr><td>+&#x3D;</td><td>复合加赋值</td><td>a+&#x3D;b</td><td>a&#x3D;a+b</td></tr><tr><td>-&#x3D;</td><td>复合减赋值</td><td>a-&#x3D;b</td><td>a&#x3D;a-b</td></tr><tr><td>*&#x3D;</td><td>复合乘赋值</td><td>a*&#x3D;b</td><td>a&#x3D;a*b</td></tr><tr><td>&#x2F;&#x3D;</td><td>复合除赋值</td><td>a&#x2F;&#x3D;b</td><td>a&#x3D;a&#x2F;b</td></tr><tr><td>%&#x3D;</td><td>复合模赋值</td><td>a%&#x3D;b</td><td>a&#x3D;a%b</td></tr></tbody></table><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i += <span class="number">3</span>;  <span class="comment">// 等同于 i = i + 3</span></span><br><span class="line">i -= <span class="number">8</span>;  <span class="comment">// 等同于 i = i - 8</span></span><br><span class="line">i *= <span class="number">9</span>;  <span class="comment">// 等同于 i = i * 9</span></span><br><span class="line">i /= <span class="number">2</span>;  <span class="comment">// 等同于 i = i / 2</span></span><br><span class="line">i %= <span class="number">5</span>;  <span class="comment">// 等同于 i = i % 5</span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连续赋值的测试</span></span><br><span class="line"><span class="comment">//以前的写法</span></span><br><span class="line"><span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连续赋值的写法</span></span><br><span class="line"><span class="type">int</span> a2,b2;</span><br><span class="line">a2 = b2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a3 = <span class="number">10</span>,b3 = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a += <span class="number">1.7</span>;  <span class="comment">// a=a+1.7 =&gt; 11.7 =&gt; 11</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d&quot;</span>, a);  <span class="comment">// a=11</span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">a = (b = <span class="number">5</span>);    <span class="comment">//表达式的值为5,将5赋值给b，接着将b的值赋值给a</span></span><br><span class="line">a = <span class="number">5</span> + (c = <span class="number">6</span>);        <span class="comment">//表达式值为11，a值为11，c值为6</span></span><br><span class="line">a = (b = <span class="number">4</span>) + (c = <span class="number">6</span>);    <span class="comment">//表达式值为10，a值为10，b等于4，c等于6</span></span><br><span class="line">a = (b = <span class="number">10</span>) / (c = <span class="number">2</span>);    <span class="comment">//表达式值为5，a等于5，b等于10，c等于2</span></span><br><span class="line">a = (b = <span class="number">3</span> * <span class="number">4</span>);        <span class="comment">//表达式值为12，a,b值均为12</span></span><br></pre></td></tr></table></figure><blockquote><p>【武汉科技大学2019研】</p><p>若a、b和t都为int变量，则下面不能交换变量a和b值的是（　　）。<br>A．t＝a； a＝b； b＝t；<br>B．a＝t； t＝b； b＝a；<br>C．t＝b； b＝a； a＝t；<br>D．a＝a＋b； b＝a－b； a＝a－b；</p><p>【答案】B</p><p>【解析】B中首先把t的值赋值给了a，则a的值已经被取代了，后面执行b＝a，则ab的值都等于t的值。</p></blockquote><blockquote><p> 【中央财经大学2018研】以下程序运行后的输出结果是（　　）。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;  </span><br><span class="line">  <span class="type">double</span> d;  </span><br><span class="line">  <span class="type">float</span> f;  </span><br><span class="line">  <span class="type">long</span> l;  </span><br><span class="line">  <span class="type">int</span> i;  </span><br><span class="line">  i = f = l = d = <span class="number">20</span>/<span class="number">3</span>;  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %ld %.1f %.1f\n&quot;</span>,i,l,f,d);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p> A．6 6 6.0 6.0<br> B．6 6 6.7 6.7<br> C．6 6 6.0 6.7<br> D．6 6 6.7 6.0</p><p> 【答案】A</p><p> 【解析】赋值运算符是自右向左结合的，所以首先执行d＝20&#x2F;3＝6，同时i、l、f也全为6，在进行输出时，f和d要保留一位小数，所以答案选A。</p></blockquote><blockquote><p>练习：</p><p>以下选项中正确的定义语句是（　　）。<br>A．double a；b；<br>B．double a＝b＝7；<br>C．double a＝7，b＝7；<br>D．double，a，b；</p><p>【答案】C</p><p>【解析】同一类型变量的定义时，不同变量之间需要用“，”分隔，选项A错误；定义变量时初始化赋值不能用等号连接，选项B错误；变量类型说明后面不能用逗号，而是用空格分离，选项D错误。答案选择C选项。</p></blockquote><h3 id="1-3-比较运算符-或关系运算符"><a href="#1-3-比较运算符-或关系运算符" class="headerlink" title="1.3 比较运算符(或关系运算符)"></a>1.3 比较运算符(或关系运算符)</h3><p>常用的比较运算符：</p><table><thead><tr><th>关系运算符</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td><td>num &gt; 10</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td><td>num &gt;&#x3D; 10</td></tr><tr><td>&lt;</td><td>小于</td><td>num &lt; 10</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td><td>num &lt;&#x3D; 10</td></tr><tr><td><code>==</code></td><td>等于</td><td>num &#x3D;&#x3D; 10</td></tr><tr><td>!&#x3D;</td><td>不等于</td><td>num !&#x3D; 10</td></tr></tbody></table><ul><li>比较运算的结果只有两个取值，要么是真(非0 表示，默认使用1)，要么是假(0 表示)。<ul><li>比如， 20 &gt; 12 返回 1 ， 12 &gt; 20 返回 0 。</li></ul></li><li>比较运算符“<code>==</code>”不能误写成“<code>=</code>”</li></ul><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> i2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i1 == i2);<span class="comment">//0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i1 != i2);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i1 &gt;= i2);<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,m == n);<span class="comment">//0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,m = n);<span class="comment">//20</span></span><br></pre></td></tr></table></figure><p>举例2：多个关系运算符不宜连用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i &lt; j &lt; k   <span class="comment">//期望判断j是否大于i，且小于k</span></span><br></pre></td></tr></table></figure><p>这是合法表达式，不会报错，但是通常达不到想要的结果，即不是保证变量 j 的值在 i 和 k 之间。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i &lt; j &lt; k</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">15</span> &lt; j &lt; <span class="number">20</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j大于15,且小于20&quot;</span>); <span class="comment">//输出此语句</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j不在15到20之间&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为关系运算符是从左到右计算，所以实际执行的是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &lt; j) &lt; k; <span class="comment">//i &lt; j 返回 0 或 1 ，所以最终是 0 或 1 与变量 k 进行比较</span></span><br></pre></td></tr></table></figure><p>期望的效果应该写为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i &lt; j &lt; k</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">15</span> &lt; j &amp;&amp; j &lt; <span class="number">20</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j大于15,且小于20&quot;</span>); </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j不在15到20之间&quot;</span>); <span class="comment">//输出此语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 【北京航空航天大学2018研】若变量a，b，c的取值分别是1，2，3，则表达式“!((b＋c)＞(a＋4))”的值是（　）。<br> A．0<br> B．1<br> C．2<br> D．3</p><p> 【答案】B</p><p> 【解析】首先b＋c等于5，a＋4也等于5，因此 (b＋c)＞(a＋4)为“假”，即0，对0取非结果为1，因此答案为B。</p></blockquote><h3 id="1-4-逻辑运算符"><a href="#1-4-逻辑运算符" class="headerlink" title="1.4 逻辑运算符"></a>1.4 逻辑运算符</h3><p>主要有下面三个运算符：</p><table><thead><tr><th>逻辑运算符</th><th>描述</th><th>功能</th><th>举例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>与运算符</td><td>两个条件都要满足</td><td>num1 &gt;&#x3D; 10 &amp;&amp; num2 &gt;&#x3D; 20</td></tr><tr><td>||</td><td>或运算符</td><td>两个条件只需满足其一</td><td>num1 &gt;&#x3D; 10 || num2 &gt;&#x3D; 20</td></tr><tr><td>!</td><td>非运算符</td><td>否定条件</td><td>!(num1 &gt;&#x3D; 10)（等价于 num1 &lt; 10）</td></tr></tbody></table><p>逻辑运算符提供逻辑判断功能，用于构建更复杂的表达式。</p><p>举例：</p><table><thead><tr><th>a</th><th>b</th><th>a &amp;&amp; b</th><th>a || b</th><th>!a</th></tr></thead><tbody><tr><td>1（真）</td><td>1（真）</td><td>1（真）</td><td>1（真）</td><td>0（假）</td></tr><tr><td>1（真）</td><td>0（假）</td><td>0（假）</td><td>1（真）</td><td>0（假）</td></tr><tr><td>0（假）</td><td>1（真）</td><td>0（假）</td><td>1（真）</td><td>1（真）</td></tr><tr><td>0（假）</td><td>0（假）</td><td>0（假）</td><td>0（假）</td><td>1（真）</td></tr></tbody></table><blockquote><p>对于逻辑运算符来说，任何非零值都表示真，零值表示伪。比如， 5 || 0 会返回 1 ， 5 &amp;&amp; 0 会返回0 。</p></blockquote><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">10</span> &amp;&amp; y &gt; <span class="number">20</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;今天天气真晴朗\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>举例2：<strong>短路现象</strong></p><ul><li>&amp;&amp;：a &amp;&amp; b<ul><li>当 a 为假(或0)时，因为a &amp;&amp; b 结果必定为 0，所以不再执行表达式 b</li><li>当 a 为真(非0)时，因为a &amp;&amp; b 结果不确定，所以会继续求解表达式b</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(i &amp;&amp; j++ &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;床前明月光&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我叫郭德纲&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,j); <span class="comment">//10</span></span><br></pre></td></tr></table></figure><ul><li>|| ：a || b<ul><li>当 a 为真(非0)时，因为a || b 结果必定为 1，所以不再执行表达式 b</li><li>当 a 为假(或0)时，因为a || b 结果不确定，所以会继续求解表达式b</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(i || j++ &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;床前明月光&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我叫郭德纲&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,j); <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>练习：请写出如下程序运行后的结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="type">short</span> z = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((z++ == <span class="number">42</span>) &amp;&amp; (y = <span class="number">1</span>)) &#123;</span><br><span class="line">        z++; <span class="comment">// z = 44</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((x = <span class="number">0</span>) || (++z == <span class="number">45</span>)) &#123;</span><br><span class="line">        z++;  <span class="comment">// z = 46</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z=%d&quot;</span>, z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>答案：z&#x3D;46</p></blockquote><blockquote><p> 【华南理工大学2018研】设int a＝3；，下列哪一个表达式的值等于0（　　）。<br> A．a&amp;&amp;(a＞0)<br> B．!a||a<br> C．a%＝a<br> D．a＞＝a</p><p> 【答案】C</p><p> 【解析】A中a!＝0且a＞0所以表达式的值为1；B中||表示或，所以值也为1；D中表达式值也为1；答案选C。</p></blockquote><blockquote><p> 【四川大学2017研】语句：printf(“%d”,(a＝2) &amp;&amp; (b＝－2))；的输出结果是（　　）。<br> A．无输出<br> B．结果不确定<br> C．－1<br> D．1</p><p> 【答案】D</p><p> 【解析】a＝2为真，b＝－2也为真，所以输出1，答案选D。</p></blockquote><h3 id="1-5-位运算符"><a href="#1-5-位运算符" class="headerlink" title="1.5 位运算符"></a>1.5 位运算符</h3><ul><li><p>C 语言提供一些位运算符，用来操作二进制位（bit）。</p></li><li><p>位运算符的运算过程都是基于二进制的补码运算。</p></li></ul><table><thead><tr><th>运算符</th><th>描述</th><th>运算规则</th></tr></thead><tbody><tr><td>&lt;&lt;</td><td>二进制左移</td><td>将一个数的各二进制位全部左移指定的位数，左边的二进制位丢弃，右边补0。</td></tr><tr><td>&gt;&gt;</td><td>二进制右移</td><td>将一个数的各二进制位全部右移指定的位数，正数左补0，负数左补1，右边丢弃。</td></tr><tr><td>&amp;</td><td>按位与</td><td>两个二进制位都为 1，结果为1，否则为0。</td></tr><tr><td>|</td><td>按位或</td><td>两个二进制位只要有一个为1（包含两个都为 1 的情况），结果为1，否则为0。</td></tr><tr><td>^</td><td>按位异或</td><td>两个二进制位一个为0，一个为1，结果为1，否则为0。</td></tr><tr><td>~</td><td>按位取反</td><td>将每一个二进制位变成相反值，即 0 变成 1 ， 1 变成 0 。</td></tr></tbody></table><ul><li>结合赋值运算符的经验，这里有：&lt;&lt;&#x3D; 、 &gt;&gt;&#x3D; 、 &amp;&#x3D; 、 ^&#x3D; 等</li></ul><p><strong>举例1：</strong></p><p><code>（1）左移：&lt;&lt;</code></p><blockquote><p>运算规则：在一定范围内，数据每向左移动一位，相当于原数据*2。（正数、负数都适用）</p></blockquote><p>【注意】当左移的位数n超过该数据类型的总位数时，相当于左移（n-总位数）位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>&lt;&lt;<span class="number">4</span>  类似于  <span class="number">3</span>*<span class="number">2</span>的<span class="number">4</span>次幂 =&gt; <span class="number">3</span>*<span class="number">16</span> =&gt; <span class="number">48</span></span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20200225113651675.png" alt="image-20200225113651675"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-3</span>&lt;&lt;<span class="number">4</span>  类似于  <span class="number">-3</span>*<span class="number">2</span>的<span class="number">4</span>次幂 =&gt; <span class="number">-3</span>*<span class="number">16</span> =&gt; <span class="number">-48</span></span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20200225114707524.png" alt="image-20200225114707524"></p><p><code>（2）右移：&gt;&gt;</code></p><blockquote><p>运算规则：在一定范围内，数据每向右移动一位，相当于原数据&#x2F;2。（正数、负数都适用）</p></blockquote><p>【注意】</p><p>1、如果不能整除，<code>向下取整</code>。</p><p>2、右移运算符最好只用于无符号整数，不要用于负数。因为不同系统对于右移后如何处理负数的符号位，有不同的做法，可能会得到不一样的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">69</span>&gt;&gt;<span class="number">4</span>  类似于  <span class="number">69</span>/<span class="number">2</span>的<span class="number">4</span>次幂 = <span class="number">69</span>/<span class="number">16</span> =<span class="number">4</span></span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20200225115636844.png" alt="image-20200225115636844"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-69</span>&gt;&gt;<span class="number">4</span>  类似于  <span class="number">-69</span>/<span class="number">2</span>的<span class="number">4</span>次幂 = <span class="number">-69</span>/<span class="number">16</span> = <span class="number">-5</span></span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20200225120112188.png" alt="image-20200225120112188"></p><p>练习：高效的方式计算2 * 8的值（经典面试题）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答案：2 &lt;&lt; 3 、  8  &lt;&lt; 1</span><br></pre></td></tr></table></figure><p><strong>举例2：</strong></p><p><code>（1）按位与：&amp;</code></p><p>运算规则：对应位都是1才为1，否则为0。</p><ul><li><p>1 &amp; 1 结果为1</p></li><li><p>1 &amp; 0 结果为0</p></li><li><p>0 &amp; 1 结果为0</p></li><li><p>0 &amp; 0 结果为0</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> &amp; <span class="number">7</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20200225122440953.png" alt="image-20200225122440953"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-9</span> &amp; <span class="number">7</span> = <span class="number">7</span></span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20200225122221616.png" alt="image-20200225122221616"></p><p><code>（2）按位或：|</code></p><p>运算规则：对应位只要有1即为1，否则为0。</p><ul><li><p>1 | 1 结果为1</p></li><li><p>1 | 0 结果为1</p></li><li><p>0 | 1 结果为1</p></li><li><p>0 &amp; 0 结果为0</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> | <span class="number">7</span>  <span class="comment">//结果： 15</span></span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20200225122758851.png" alt="image-20200225122758851"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-9</span> | <span class="number">7</span> <span class="comment">//结果： -9</span></span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20200225123409130.png" alt="image-20200225123409130"></p><p><code>（3）按位异或：^</code></p><p>运算规则：对应位一个为1一个为0，才为1，否则为0。</p><ul><li><p>1 ^ 1 结果为0</p></li><li><p>1 ^ 0 结果为1</p></li><li><p>0 ^ 1 结果为1</p></li><li><p>0 ^ 0 结果为0</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> ^ <span class="number">7</span>  <span class="comment">//结果为14</span></span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20200225123445305.png" alt="image-20200225123445305"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-9</span> ^ <span class="number">7</span> <span class="comment">//结果为-16</span></span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20200225133145727.png" alt="image-20200225133145727"></p><p><code>（4）按位取反：~</code></p><p>运算规则：对应位为1，则结果为0；对应位为0，则结果为1。</p><ul><li><p>~0就是1  </p></li><li><p>~1就是0</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">9</span>  <span class="comment">//结果：-10</span></span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20200225124112662.png" alt="image-20200225124112662"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">-9</span>  <span class="comment">//结果：8</span></span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20200225124156862.png" alt="image-20200225124156862"></p><p>练习1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">12</span>,j = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i &amp; j); <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i | j); <span class="comment">//13</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i ^ j); <span class="comment">//9</span></span><br></pre></td></tr></table></figure><img src="/img/images/snipaste_20220312_002549.jpg" alt="snipaste_20220312_002549" style="zoom: 67%;" /><p><strong>练习2：特定位清零</strong></p><p>技巧：待清零的位与0，其它位与1</p><p>示例：设字符型 x 的当前值为 53，将其最低两位清 0，其余位保持不变</p><p>分析：与二进制的0b11111100数值求&amp;运算即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> x = <span class="number">53</span>; <span class="comment">// 0b00110101</span></span><br><span class="line">    x = x &amp; <span class="number">252</span>; <span class="comment">// 0b11111100</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x); <span class="comment">//0b00110100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：判断特定位是否为零</p><p>技巧：待判定位与 1，其它位与 0；判与运算结果是否为 0</p><p>示例：设字符型 x 的当前值为 53，判定其最高位是否为 0</p><p>分析：与二进制的0b10000000求&amp;运算，若结果为 0，则最高位为 0，否则为 1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> x = <span class="number">53</span>; <span class="comment">// 0b00110101</span></span><br><span class="line">    x = x &amp; <span class="number">128</span>; <span class="comment">// 0b10000000</span></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最高位为0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最高位不为0&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：保留特定位</p><p>技巧：待保留位全部与 1，其余位与 0</p><p>示例：设字符型 x 的当前值为 53，保留其最低 4 位，其余位清零</p><p>分析：与二进制的0b00001111求&amp;运算即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> x = <span class="number">53</span>; <span class="comment">// 0b00110101</span></span><br><span class="line">    x = x &amp; <span class="number">15</span>;  <span class="comment">// 0b00001111</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x); <span class="comment">//0b00000101</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：待置 1 或 1，保持位或 0</p><p>示例：设字符型 x 的当前值为 53，将其最低两位置 1，其余位保持不变</p><p>分析：与二进制0b00000011求或运算即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> x = <span class="number">53</span>; <span class="comment">// 0b00110101</span></span><br><span class="line">    x = x | <span class="number">3</span>;   <span class="comment">// 0b00000011</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x); <span class="comment">//0b00110111</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：特定位取反</p><p>待取反位异或 1，保持位异或 0</p><p>示例：设字符型 x 的当前值为 53，将其最低两位取反，其余位保持不变</p><p>分析：与二进制0b00000011求异或运算即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> x = <span class="number">53</span>; <span class="comment">// 0b00110101</span></span><br><span class="line">    x = x ^ <span class="number">3</span>;   <span class="comment">// 0b00000011</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x); <span class="comment">//0b00110110</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-条件运算符"><a href="#1-6-条件运算符" class="headerlink" title="1.6 条件运算符"></a>1.6 条件运算符</h3><ul><li>条件运算符格式：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(条件表达式)? 表达式<span class="number">1</span>:表达式<span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li><p>说明：条件表达式是如果为 true (非0值)，就执行表达式1，否则执行表达式2。</p><img src="/img/images/image-20220312002841945.png" alt="image-20220312002841945" style="zoom:67%;" /></li><li><p>如果运算后的结果赋给新的变量，要求表达式1和表达式2为同种或兼容的类型</p></li></ul><p>**举例1：**获取两个数中的较大值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取两个数的较大值</span></span><br><span class="line">    <span class="type">int</span> m1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> m2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max1 = (m1 &gt; m2)? m1 : m2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1和m2中的较大值为%d\n&quot;</span>,max1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**举例2：**获取三个数中的最大值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">23</span>;</span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">13</span>;</span><br><span class="line">    <span class="type">int</span> n3 = <span class="number">33</span>;</span><br><span class="line">    <span class="comment">//写法1：</span></span><br><span class="line">    <span class="type">int</span> tempMax = (n1 &gt; n2)? n1:n2;</span><br><span class="line">    <span class="type">int</span> finalMax = (tempMax &gt; n3)? tempMax : n3;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;三个数中最大值为%d\n&quot;</span>,finalMax);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写法2：不推荐，可读性差</span></span><br><span class="line">    <span class="type">int</span> finalMax1 = (((n1 &gt; n2)? n1:n2) &gt; n3)? ((n1 &gt; n2)? n1:n2) : n3;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;三个数中最大值为%d\n&quot;</span>,finalMax1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 【华南理工大学2018研】输入一个字符，判别它是否为大写字母，如果是，将它变为小写字母；如果不是，不转换。然后输出最后得到的字符。请在下面空白处填上适当语句。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line">  <span class="type">char</span> ch;  </span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, ① );  </span><br><span class="line">  ch=(ch&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp; ② )?(ch+<span class="number">32</span>): ③ ;  </span><br><span class="line">  <span class="built_in">printf</span>( ④ ,ch);  </span><br><span class="line">  <span class="keyword">return</span> ⑤ ;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p> 【答案】①&amp;ch②ch＜＝’Z’③ch④”%c”⑤0</p><p> 【解析】程序进行输入时要加上地址符&amp;；main函数中的第三行为一个三目运算符，当ch在A～Z之间时ch为真，此时ch＋32变为小写字母，否则不变；程序进行输出时应用%加上数据类型进行输出，最后用return 0来结束程序。</p></blockquote><h3 id="1-7-sizeof-运算符"><a href="#1-7-sizeof-运算符" class="headerlink" title="1.7 sizeof 运算符"></a>1.7 sizeof 运算符</h3><p>sizeof 运算符：sizeof(参数)</p><ul><li>参数可以是<code>数据类型</code>的关键字，也可以是<code>变量名</code>或某个<code>具体的值</code>。</li><li>返回某种数据类型或某个值占用的字节数量。</li></ul><p>举例1：参数为数据类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="keyword">sizeof</span>(<span class="type">int</span>);  <span class="comment">//通常是 4 或 8</span></span><br></pre></td></tr></table></figure><p>举例2：参数为变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">sizeof</span>(i); <span class="comment">//通常是 4 或 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为数值</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="number">3.14</span>); <span class="comment">//浮点数的字面量一律存储为double类型,故返回 8</span></span><br></pre></td></tr></table></figure><p><strong>sizeof返回值的类型说明</strong></p><p>sizeof 运算符的返回值，C 语言只规定是无符号整数，并没有规定具体的类型，留给系统自己去决定sizeof 到底返回什么类型。不同的系统中，返回值的类型有可能是 unsigned int ，也有可能是unsigned long ，甚至是 unsigned long long ，对应的 printf() 占位符分别是 %u 、 %lu和 %llu 。这样不利于程序的可移植性。</p><p>C 语言提供了一个解决方法，创造了一个类型别名 <code>size_t</code> ，用来统一表示 sizeof 的返回值类型。该别名定义在 <code>stddef.h</code> 头文件里面，对应当前系统的 sizeof 的返回值类型，可能是 unsigned int ，也可能是 unsigned long 。</p><p>printf() 有专门的占位符 <code>%zd</code> 或 <code>%zu</code> ，用来处理 size_t 类型的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>上面代码中，不管 sizeof 返回值的类型是什么， %zd 占位符（或 %zu ）都可以正确输出。</p><p>如果当前系统不支持 %zd 或 %zu ，可使用 %u （unsigned int）或 %lu （unsigned long int）代替。</p><h3 id="1-8-运算符的优先级"><a href="#1-8-运算符的优先级" class="headerlink" title="1.8 运算符的优先级"></a>1.8 运算符的优先级</h3><p>运算符有不同的优先级，所谓优先级就是在表达式运算中的运算符顺序。</p><p>上一行中的运算符总是优先于下一行的。</p><p><img src="/img/images/image-20230812171714087.png" alt="image-20230812171714087"></p><blockquote><p>开发建议：</p><ol><li>不要过多的依赖运算的优先级来控制表达式的执行顺序，这样可读性太差，尽量<code>使用()来控制</code>表达式的执行顺序。</li><li>不要把一个表达式写得过于复杂，如果一个表达式过于复杂，则把它<code>分成几步</code>来完成。例如：<br>​ (num1 + num2) * 2 &gt; num3 &amp;&amp; num2 &gt; num3 ? num3 : num1 + num2;</li></ol></blockquote><h2 id="2-流程控制结构"><a href="#2-流程控制结构" class="headerlink" title="2. 流程控制结构"></a>2. 流程控制结构</h2><ul><li>流程控制结构是用来控制程序中各<code>语句执行顺序</code>的语句，可以把语句组合成能<code>完成一定功能</code>的小逻辑模块。</li><li>程序设计中规定的<code>三种</code>流程结构，即：<ul><li><strong>顺序结构</strong><ul><li>程序从上到下逐行地执行，中间没有任何判断和跳转。</li></ul></li><li><strong>分支结构</strong><ul><li>根据条件，选择性地执行某段代码。</li><li>有<code>if…else</code>和<code>switch-case</code>两种分支语句。</li></ul></li><li><strong>循环结构</strong><ul><li>根据循环条件，重复性的执行某段代码。</li><li>有<code>for</code>、<code>while</code>、<code>do-while</code>三种循环语句。</li></ul></li></ul></li><li>生活中、工业生产中流程控制举例</li></ul><img src="/img/images/洗衣流程.jpg" alt="洗衣流程" style="zoom:100%;" /><h3 id="2-1-顺序结构"><a href="#2-1-顺序结构" class="headerlink" title="2.1 顺序结构"></a>2.1 顺序结构</h3><p>程序<code>从上到下逐行</code>地执行。表达式语句都是顺序执行的。并且上一行对某个变量的修改对下一行会产生影响。</p><p><img src="/img/images/image-20211218093256771.png" alt="image-20211218093256771"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;y = %d\n&quot;</span>, y);</span><br><span class="line">    <span class="comment">//对x、y的值进行修改</span></span><br><span class="line">    x++;</span><br><span class="line">    y = <span class="number">2</span> * x + y;</span><br><span class="line">    x = x * <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;y = %d\n&quot;</span>, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c语言中定义变量时采用合法的<code>前向引用</code>。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> num1 = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> num2 = num1 + <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> num2 = num1 + <span class="number">2</span>; <span class="comment">//use of undeclared identifier &#x27;num1&#x27;</span></span><br><span class="line"><span class="type">int</span> num1 = <span class="number">12</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-分支结构1：if-else"><a href="#2-2-分支结构1：if-else" class="headerlink" title="2.2 分支结构1：if-else"></a>2.2 分支结构1：if-else</h3><h4 id="2-2-1-基本语法"><a href="#2-2-1-基本语法" class="headerlink" title="2.2.1 基本语法"></a>2.2.1 基本语法</h4><p><strong>结构1：单分支</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)｛</span><br><span class="line">  语句块;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p><code>执行流程：</code>条件表达式为真（值不为 0 ）时，就执行语句块。</p><p><code>图示：</code></p><p><img src="/img/images/image-20220514160139926.png" alt="image-20220514160139926"></p><p><code>举例：</code>成年人心率的正常范围是每分钟60-100次。体检时，如果心率不在此范围内，则提示需要做进一步的检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> heartBeats = <span class="number">89</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(heartBeats &lt; <span class="number">60</span> || heartBeats &gt; <span class="number">100</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你需要做进一步的检查&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;体检结束&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结构2：双分支</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式) &#123; </span><br><span class="line">  语句块<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>执行流程：</code></p><ol><li>首先判断条件表达式看其结果是为真（值不为 0 ）还是假（值为0）</li><li>如果是真，就执行语句块1</li><li>如果是假，就执行语句块2</li></ol><p><img src="/img/images/image-20220514160243421.png" alt="image-20220514160243421"></p><p><code>举例：</code>定义一个整数，判定是偶数还是奇数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d是偶数\n&quot;</span>, a);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d是奇数\n&quot;</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结构3：多重分支</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式<span class="number">1</span>) &#123;</span><br><span class="line">  语句块<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">2</span>) &#123;</span><br><span class="line">  语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (条件表达式n) &#123;</span><br><span class="line"> 语句块n;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  语句块n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>执行流程：</code></p><ol><li>首先判断关系表达式1看其结果是真（值不为0）还是假（值为0）</li><li>如果是真，就执行语句块1，然后结束当前多分支</li><li>如果是假，就继续判断条件表达式2，看其结果是真还是假</li><li>如果是真，就执行语句块2，然后结束当前多分支</li><li>如果是假，就继续判断条件表达式…看其结果是真还是假</li></ol><p>​    …</p><p>   n.  如果没有任何关系表达式为真，就执行语句块n+1，然后结束当前多分支。</p><p><img src="/img/images/image-20220514160538651.png" alt="image-20220514160538651"></p><p><code>举例：</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">岳小鹏参加C语言考试，他和父亲岳不群达成承诺：</span><br><span class="line">如果：</span><br><span class="line">成绩为100分时，奖励一辆跑车；</span><br><span class="line">成绩为(80，99]时，奖励一辆山地自行车；</span><br><span class="line">当成绩为[60,80]时，奖励环球影城一日游；</span><br><span class="line">其它时，胖揍一顿。</span><br><span class="line"></span><br><span class="line">说明：默认成绩是在[0,100]范围内</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score = <span class="number">67</span>;<span class="comment">//岳小鹏的期末成绩</span></span><br><span class="line">    <span class="comment">//写法一：默认成绩范围为[0,100]</span></span><br><span class="line">    <span class="keyword">if</span> (score == <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;奖励一辆跑车&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">80</span> &amp;&amp; score &lt;= <span class="number">99</span>) &#123;    <span class="comment">//错误的写法：&#125;else if(80 &lt; score &lt;= 99)&#123;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;奖励一辆山地自行车&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span> &amp;&amp; score &lt;= <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;奖励环球影城玩一日游&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//else&#123;</span></span><br><span class="line">    <span class="comment">//printf(&quot;胖揍一顿&quot;);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写法二：</span></span><br><span class="line">    <span class="comment">// 默认成绩范围为[0,100]</span></span><br><span class="line">    <span class="keyword">if</span> (score == <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;奖励一辆跑车&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;奖励一辆山地自行车&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;奖励环球影城玩一日游&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;胖揍一顿&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当条件表达式之间是“<code>互斥</code>”关系时（即彼此没有交集），条件判断语句及执行语句间顺序无所谓。</p><p>当条件表达式之间是“<code>包含</code>”关系时，“<code>小上大下 / 子上父下</code>”，否则范围小的条件表达式将不可能被执行。</p></blockquote><blockquote><p>当if-else结构是“多选一”时，最后的<code>else是可选的</code>，根据需要可以省略</p></blockquote><blockquote><p>语句块只有一条执行语句时，一对<code>&#123;&#125;可以省略</code>，但建议保留</p></blockquote><p>练习：判断输出结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span> (number &gt; <span class="number">6</span>)</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">12</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The number &gt;= 6,且 &lt;= 12.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;判断不成功.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：</p><p>如果有多个 if 和 else ，没有{}的情况下， else 总是跟最接近的 if 匹配。</p><p>为了提供代码的可读性，建议使用大括号，明确 else 匹配哪一个 if 。</p></blockquote><p>如果希望else与外层的if匹配，改写为如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span> (number &gt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">12</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The number &gt;= 6,且 &lt;= 12.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;判断不成功.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-2-2-举例"><a href="#2-2-2-举例" class="headerlink" title="2.2.2 举例"></a>2.2.2 举例</h4><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未成年\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成年\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例2：</p><p>编写一个程序，判定某个年份是否为闰年。年份满足如下条件之一，即是闰年：</p><p>⑴ year 是 400 的整倍数： year%400&#x3D;&#x3D;0</p><p>(2) 能被4整除，但不能被100整除：year % 4 &#x3D;&#x3D; 0 &amp;&amp; year % 100 !&#x3D; 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> year;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入年份: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;year);</span><br><span class="line">    <span class="keyword">if</span> (year % <span class="number">400</span> == <span class="number">0</span> || (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d 是闰年\n&quot;</span>, year);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d 不是闰年\n&quot;</span>, year);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例3：解方程</p><p>设计求解一元二次方程 $ax^2+bx+c&#x3D;0$ （a≠0）的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> a, b, c;</span><br><span class="line">    <span class="type">float</span> x1, x2, d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入方程中的系数与常量 a,b,c: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f%f%f&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    d = b * b - <span class="number">4</span> * a * c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        x1 = (-b + <span class="built_in">sqrt</span>(d)) / (<span class="number">2</span> * a);</span><br><span class="line">        x2 = (-b - <span class="built_in">sqrt</span>(d)) / (<span class="number">2</span> * a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x1=%f,x2=%f\n&quot;</span>, x1, x2);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;方程没有根\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例4：判断水的温度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果大于95℃，则打印“开水”；</span><br><span class="line"></span><br><span class="line">如果大于70℃且小于等于95℃，则打印“热水”；</span><br><span class="line"></span><br><span class="line">如果大于40℃且小于等于70℃，则打印“温水”；</span><br><span class="line"></span><br><span class="line">如果小于等于40℃，则打印“凉水”。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> waterTemperature = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waterTemperature &gt; <span class="number">95</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;开水&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (waterTemperature &gt; <span class="number">70</span> &amp;&amp; waterTemperature &lt;= <span class="number">95</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;热水&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (waterTemperature &gt; <span class="number">40</span> &amp;&amp; waterTemperature &lt;= <span class="number">70</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;温水&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;凉水&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例5：<strong>if-else的嵌套</strong></p><p>出票系统：根据淡旺季的月份和年龄，打印票价。要求，月份和年龄从键盘获取输入。</p><p>4_10 旺季：<br>成人（18-60）：60<br>儿童（&lt; 18）   :  半价<br>老人（&gt; 60）   :  1&#x2F;3<br>淡季：<br>成人   :  40<br>其他   :  20</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> month, age;</span><br><span class="line">    <span class="type">double</span> price = <span class="number">60.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入月份（1-12）：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;month);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入年龄：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (month &gt;= <span class="number">4</span> &amp;&amp; month &lt;= <span class="number">10</span>) &#123;  <span class="comment">// 旺季</span></span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            price = price / <span class="number">2</span>;  <span class="comment">// 半价</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &gt; <span class="number">60</span>) &#123;</span><br><span class="line">            price = price / <span class="number">3</span>;  <span class="comment">// 1/3价格</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 淡季</span></span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">            price = <span class="number">40.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            price = <span class="number">20.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您的票价是：￥%.2f\n&quot;</span>, price);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【武汉科技大学2019研】对下述程序段的描述正确的是（　　）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(a&gt;b)  </span><br><span class="line">a=b;b=a;</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">a++;b++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d&quot;</span>,a,b); </span><br></pre></td></tr></table></figure><p>A．若输入4，5则输出a＝5，b＝6<br>B．若输入5，4则输出a＝4，b＝5<br>C．若输入5，4则输出a＝5，b＝5<br>D．有语法错误，不能通过编译</p><p>【答案】D</p><p>【解析】if（表达式）后面如果没有用花括号括起来，那么if的子语句只包括第一条语句，即在程序中只有a＝b是属于if语句块的，if和else中间隔了一条语句b＝a，编译无法通过。</p></blockquote><blockquote><p> 【华南理工大学2018研】两次运行下面的程序，如果从键盘上分别输入6和4，则输出的结果是（　　）</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">  <span class="keyword">if</span>(x++&gt;<span class="number">5</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x--);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p> A．7和5<br> B．6和3<br> C．7和4<br> D．6和4</p><p> 【答案】A</p><p> 【解析】当输入6时，判断 x++＞5为真，进入if语句块，此时x＝7，输出7；当输入4时，进入else语句块，此时x＝5，然后因为–是先运算后自减，所以先输出5，后x的值为4，答案选A。</p></blockquote><h3 id="2-3-分支结构2：switch-case"><a href="#2-3-分支结构2：switch-case" class="headerlink" title="2.3 分支结构2：switch-case"></a>2.3 分支结构2：switch-case</h3><h4 id="2-3-1-基本语法"><a href="#2-3-1-基本语法" class="headerlink" title="2.3.1 基本语法"></a>2.3.1 基本语法</h4><p>switch 语句用于判断条件有多个常量结果的情况。它把多重的 else if 改成更易用、可读性更好的形式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量值<span class="number">1</span>: </span><br><span class="line">        语句块<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//break;</span></span><br><span class="line"><span class="keyword">case</span> 常量值<span class="number">2</span>: </span><br><span class="line">        语句块<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//break;</span></span><br><span class="line">┇ ┇</span><br><span class="line"><span class="keyword">case</span> 常量值n: </span><br><span class="line">        语句块n; </span><br><span class="line">        <span class="comment">//break;</span></span><br><span class="line">[<span class="keyword">default</span>: </span><br><span class="line">        语句块n+<span class="number">1</span>;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程图：</strong></p><p><img src="/img/images/image-20220514101841710.png" alt="image-20220514101841710"></p><p><strong>执行过程：</strong></p><p>第1步：根据switch中表达式的值，依次匹配各个case。如果表达式的值等于某个case中的常量值，则执行对应case中的执行语句。</p><p>第2步：执行完此case的执行语句以后，<br>​              情况1：如果遇到break，则执行break并跳出当前的switch-case结构<br>​        情况2：如果没有遇到break，则会继续执行当前case之后的其它case中的执行语句。—&gt;<code>case穿透</code><br>​         …<br>​        直到遇到break关键字或执行完所有的case及default的执行语句，跳出当前的switch-case结构</p><p><strong>使用注意点：</strong></p><ul><li><p>case子句中的值必须是常量，不能是变量名或不确定的表达式值或范围。</p></li><li><p>同一个switch语句，所有case子句中的常量值互不相同。</p></li><li><p>如果没有break，程序会顺序执行到switch结尾；从使用频率说，一般switch-case结构中，都需要编写break。</p></li><li><p>default子句是可选的。同时，位置也是灵活的。当没有匹配的case时，执行default语句。</p></li></ul><h4 id="2-3-2-举例"><a href="#2-3-2-举例" class="headerlink" title="2.3.2 举例"></a>2.3.2 举例</h4><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> grade = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;zero\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;one\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;two\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;three\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;other\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与如下代码对比：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> grade = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;zero\n&quot;</span>);</span><br><span class="line">            <span class="comment">//break;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;one\n&quot;</span>);</span><br><span class="line">            <span class="comment">//break;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;two\n&quot;</span>);</span><br><span class="line">            <span class="comment">//break;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;three\n&quot;</span>);</span><br><span class="line">            <span class="comment">//break;</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;other\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：使用switch-case实现：对学生成绩大于60分的，输出“合格”。低于60分的，输出“不合格”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score = <span class="number">83</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式1：</span></span><br><span class="line">    <span class="keyword">switch</span>(score / <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;成绩输入有误&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果多个 case 分支对应同样的语句体，可以改写如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score = <span class="number">83</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式2：体会case穿透</span></span><br><span class="line">    <span class="keyword">switch</span>(score / <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;成绩输入有误&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从算法层面，还可以优化下代码，改为如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score = <span class="number">83</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式3：算法层面优化</span></span><br><span class="line">    <span class="keyword">switch</span>(score / <span class="number">60</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;成绩输入有误&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> key = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">        <span class="keyword">case</span> key &gt; <span class="number">0</span> :  <span class="comment">//提示：Expression is not an integer constant expression</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正数&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> key &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;负数&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;零&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【武汉科技大学2019研】若有定义：int a＝1，b＝2； float x＝3，w； 则合法的switch语句是（　）。</p><p>A.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (a) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  w = a / b;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  w = a % b;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B．</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (b) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  z = a % b;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  z = a / b;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C．</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  w = a % b;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  w = a / b;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D．</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (a + b);&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">w = a % b;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【答案】A</p><p>【解析】B中，变量z未定义；C中x为浮点型，switch后面的表达式不能是浮点型，只能是整型和字符型；D中swith表达式后面不能加分号，答案选A。</p></blockquote><blockquote><p>【北京航空航天大学2018研】对于下列代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(option)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome &quot;</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Bye&quot;</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若option的取值为’W’，则该代码段的输出结果是（　　）。<br>A．Welcome<br>B．Welcome Bye<br>C．Hello Welcome Bye<br>D．以上结果都不对</p><p>【答案】B</p><p>【解析】由于option为’W’，所以首先应该输出Welcome，但是由于该语句后面没有break语句来终止选择语句switch，因此会继续执行下面的语句，直到遇上break，所以最后输出Welcome Bye，答案为B。</p></blockquote><h4 id="2-3-3-if-else与switch-case比较"><a href="#2-3-3-if-else与switch-case比较" class="headerlink" title="2.3.3 if-else与switch-case比较"></a>2.3.3 if-else与switch-case比较</h4><ul><li><p>结论：凡是使用switch-case的结构都可以转换为if-else结构。反之，不成立。</p></li><li><p>开发经验：如果既可以使用switch-case，又可以使用if-else，建议使用switch-case。因为效率稍高。</p></li><li><p>细节对比：</p><ul><li>if-else语句优势<ul><li>if语句的条件可以用于范围的判断，也可以用于等值的判断，<code>使用范围更广</code>。</li><li>switch语句的条件是一个常量值，只能判断某个变量或表达式的结果是否等于某个常量值，<code>使用场景较狭窄</code>。</li></ul></li><li>switch语句优势<ul><li>当条件是判断某个变量或表达式是否等于某个固定的常量值时，使用if和switch都可以，习惯上使用switch更多。因为<code>效率稍高</code>。当条件是区间范围的判断时，只能使用if语句。</li><li>使用switch可以利用<code>穿透性</code>，同时执行多个分支，而if…else没有穿透性。</li></ul></li></ul></li></ul><h3 id="2-4-循环结构之1：for循环"><a href="#2-4-循环结构之1：for循环" class="headerlink" title="2.4 循环结构之1：for循环"></a>2.4 循环结构之1：for循环</h3><ul><li><p>循环结构的理解：循环语句具有在<code>某些条件</code>满足的情况下，<code>反复执行</code>特定代码的功能。</p></li><li><p>循环结构分类：</p><ul><li>for 循环</li><li>while 循环</li><li>do-while 循环</li></ul></li><li><p>循环结构<code>四要素</code>：</p><ul><li>初始化部分</li><li>循环条件部分</li><li>循环体部分</li><li>迭代部分</li></ul></li></ul><h4 id="2-4-1-基本语法"><a href="#2-4-1-基本语法" class="headerlink" title="2.4.1 基本语法"></a>2.4.1 基本语法</h4><p><strong>语法格式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (①初始化部分; ②循环条件部分; ④迭代部分)｛</span><br><span class="line">         ③循环体部分;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>**执行过程：**①-②-③-④-②-③-④-②-③-④-…..-②</p><p><strong>图示：</strong></p><img src="/img/images/image-20220315013023236.png" alt="image-20220315013023236" style="zoom:80%;" /><p><strong>说明：</strong></p><ul><li>for(;;)中的两个；不能多也不能少</li><li>①初始化部分，用于初始化循环变量，只执行一次。可以声明多个变量，但必须是同一个类型，用逗号分隔</li><li>②循环条件部分，只要为 true ，就会不断执行循环体；当值为false时，退出循环</li><li>④迭代部分，每轮循环结束后执行，使得循环变量发生变化。可以有多个变量更新，用逗号分隔</li></ul><h4 id="2-4-2-举例"><a href="#2-4-2-举例" class="headerlink" title="2.4.2 举例"></a>2.4.2 举例</h4><p><strong>案例1：使用for循环重复执行某些语句</strong></p><p>题目：输出5行HelloWorld</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写法1：</span></span><br><span class="line"><span class="comment">//    printf(&quot;Hello World!\n&quot;);</span></span><br><span class="line"><span class="comment">//    printf(&quot;Hello World!\n&quot;);</span></span><br><span class="line"><span class="comment">//    printf(&quot;Hello World!\n&quot;);</span></span><br><span class="line"><span class="comment">//    printf(&quot;Hello World!\n&quot;);</span></span><br><span class="line"><span class="comment">//    printf(&quot;Hello World!\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写法2：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例2：格式的多样性</strong></p><p>题目：写出输出的结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">printf</span>(<span class="string">&quot;a&quot;</span>);num &lt; <span class="number">3</span>;<span class="built_in">printf</span>(<span class="string">&quot;c&quot;</span>),num++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">999</span>; i &lt; <span class="number">10</span>; i++, j--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例3：累加的思想</strong></p><p>题目：遍历1-100以内的偶数，并获取偶数的个数，获取所有的偶数的和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//记录偶数的个数</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//记录偶数的和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">            count++;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printf(&quot;偶数的个数为：&quot; + count);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;偶数的个数为：%d\n&quot;</span>, count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;偶数的总和为：%d\n&quot;</span>, sum);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例4：结合分支结构使用</strong></p><p>题目：输出所有的水仙花数，所谓水仙花数是指一个3位数，其各个位上数字立方和等于其本身。例如： <code>153 = 1*1*1 + 3*3*3 + 5*5*5</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义统计变量，初始化值是0</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取三位数，用for循环实现</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">100</span>; x &lt; <span class="number">1000</span>; x++) &#123;</span><br><span class="line">        <span class="comment">//获取三位数的个位，十位，百位</span></span><br><span class="line">        <span class="type">int</span> ge = x % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> shi = x / <span class="number">10</span> % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> bai = x / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断这个三位数是否是水仙花数，如果是，统计变量++</span></span><br><span class="line">        <span class="keyword">if</span> ((ge * ge * ge + shi * shi * shi + bai * bai * bai) == x) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;水仙花数：%d\n&quot;</span>, x);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出统计结果就可以了</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;水仙花数共有%d个&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拓展：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印出四位数字中“个位+百位”等于“十位+千位”并且个位数为偶数，千位数为奇数的数字，并打印符合条件的数字的个数。</span><br></pre></td></tr></table></figure><p><strong>案例5：结合break的使用</strong></p><p>说明：输入两个正整数m和n，求其最大公约数和最小公倍数。</p><p>比如：12和20的最大公约数是4，最小公倍数是60。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需求1：最大公约数</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">12</span>, n = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//取出两个数中的较小值</span></span><br><span class="line">    <span class="type">int</span> min = (m &lt; n) ? m : n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = min; i &gt;= <span class="number">1</span>; i--) &#123;<span class="comment">//for(int i = 1;i &lt;= min;i++)&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m % i == <span class="number">0</span> &amp;&amp; n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;最大公约数是：%d\n&quot;</span>, i); <span class="comment">//公约数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//跳出当前循环结构</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//需求2：最小公倍数</span></span><br><span class="line">    <span class="comment">//取出两个数中的较大值</span></span><br><span class="line">    <span class="type">int</span> max = (m &gt; n) ? m : n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = max; i &lt;= m * n; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i % m == <span class="number">0</span> &amp;&amp; i % n == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;最小公倍数是：%d\n&quot;</span>, i);<span class="comment">//公倍数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>说明：</p><p>1、我们可以在循环中使用break。一旦执行break，就跳出当前循环结构。</p><p>2、小结：如何结束一个循环结构？</p><p>​      结束情况1：循环结构中的循环条件部分返回false</p><p>​      结束情况2：循环结构中执行了break。</p><p>3、如果一个循环结构不能结束，那就是一个死循环！我们开发中要避免出现死循环。</p></blockquote><blockquote><p>【华南理工大学2018研】有一个分数序列$2&#x2F;1,3&#x2F;2,5&#x2F;3,8&#x2F;5,13&#x2F;8,21&#x2F;13,…$,求这个数列的前20项之和。请在下面空白处填上适当语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;  </span><br><span class="line"> <span class="type">int</span> i,n=<span class="number">20</span>;  </span><br><span class="line"> <span class="type">double</span> a=<span class="number">2</span>,b=<span class="number">1</span>,s=<span class="number">0</span>,t;  </span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">1</span>; ① ;i++)&#123;    </span><br><span class="line">    s= ② ;        </span><br><span class="line">    ③ ;   </span><br><span class="line">    a=a+b;        </span><br><span class="line">    ④ ;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;sum=%16.10f\n&quot;</span>, ⑤ );  </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>【答案】①i＜＝n②s＋a&#x2F;b③t＝a④b＝t⑤s</p><p>【解析】此程序循环是从＝1开始，所以要计算数列前20项，则循环条件应为i＜＝n；s用来累加求和，所以每次进行累加操作，即s＝s＋a&#x2F;b；通过分析数列可知，数列中分子是上一项的分子分母之和，而分母是上一项的分子，依照此关系可以通过中间变量t进行换算，最后输出所求结果s。</p></blockquote><blockquote><p>【华南理工大学2018研】从键盘输入10个整数，编程求其中大于3且小于100的数的平均值并输出结果。</p><p>【答案】<br>此题可以先利用循环从屏幕读取10个数，然后依次判断数值是否大于3且小于100的数，最后取平均值进行输出，程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> num; <span class="comment">//输入的整数</span></span><br><span class="line"> <span class="type">int</span> sum; <span class="comment">//记录总和</span></span><br><span class="line"> <span class="type">int</span> count;<span class="comment">//记录个数</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(num &gt; <span class="number">3</span> &amp;&amp; num &lt; <span class="number">100</span>)&#123;</span><br><span class="line">         sum += num;</span><br><span class="line">         count++;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//    printf(&quot;%d\n&quot;,sum);</span></span><br><span class="line"><span class="comment">//    printf(&quot;%d\n&quot;,count);</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum / count);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-5-循环结构之2：while循环"><a href="#2-5-循环结构之2：while循环" class="headerlink" title="2.5 循环结构之2：while循环"></a>2.5 循环结构之2：while循环</h3><h4 id="2-5-1-基本语法"><a href="#2-5-1-基本语法" class="headerlink" title="2.5.1 基本语法"></a>2.5.1 基本语法</h4><p><strong>语法格式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①初始化部分</span><br><span class="line"><span class="keyword">while</span>(②循环条件部分)｛</span><br><span class="line">    ③循环体部分;</span><br><span class="line">    ④迭代部分;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**执行过程：**①-②-③-④-②-③-④-②-③-④-…-②</p><p><strong>图示：</strong></p><img src="/img/images/image-20220315013023236.png" alt="image-20220315013023236" style="zoom:80%;" /><p><strong>说明：</strong></p><ul><li>while(循环条件部分)中循环条件为非零值，表示true、真；为零值，表示false、伪。</li><li>注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。</li><li>for循环和while循环<code>可以相互转换</code>。二者没有性能上的差别。实际开发中，根据具体结构的情况，选择哪个格式更合适、美观。</li><li>for循环与while循环的区别：<code>初始化条件部分的作用域不同</code>。</li></ul><h4 id="2-5-2-举例"><a href="#2-5-2-举例" class="headerlink" title="2.5.2 举例"></a>2.5.2 举例</h4><p>**案例1：**输出5行HelloWorld!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**案例2：**遍历1-100的偶数，并计算所有偶数的和、偶数的个数（累加的思想）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//遍历1-100的偶数，并计算所有偶数的和、偶数的个数（累加的思想）</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//记录1-100所有的偶数的和</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//记录1-100之间偶数的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (num &lt;= <span class="number">100</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line">            sum += num;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代条件</span></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;偶数的总和为：%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;偶数的个数为：%d\n&quot;</span>, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>案例3：折纸珠穆朗玛峰</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">世界最高山峰是珠穆朗玛峰，它的高度是8848.86米，假如我有一张足够大的纸，它的厚度是0.1毫米。</span><br><span class="line">请问，我折叠多少次，可以折成珠穆朗玛峰的高度?</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个计数器，初始值为0</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义珠穆朗玛峰的高度</span></span><br><span class="line">    <span class="type">int</span> zf = <span class="number">8848860</span>;<span class="comment">//单位：毫米</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> paper = <span class="number">0.1</span>;<span class="comment">//单位：毫米</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (paper &lt; zf) &#123;</span><br><span class="line">        <span class="comment">//在循环中执行累加，对应折叠了多少次</span></span><br><span class="line">        count++;</span><br><span class="line">        paper *= <span class="number">2</span>;<span class="comment">//循环的执行过程中每次纸张折叠，纸张的厚度要加倍</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印计数器的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;需要折叠：%d次\n&quot;</span>, count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;折纸的高度为%f米，超过了珠峰的高度&quot;</span>, paper / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 【武汉科技大学2019研】如果有定义：int x＝0，s＝0； 则下面程序段的执行结果是（　　）。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!x!= <span class="number">0</span>)  </span><br><span class="line">s+=x++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,s);</span><br></pre></td></tr></table></figure><p> A．1<br> B．0<br> C．无限循环<br> D．控制表达式非法，无法编译</p><p> 【答案】B</p><p> 【解析】while后面的表达式中，首先执行!运算符，然后再执行!＝运算符，第一次判断中，x＝0则!x!＝0满足条件，进入循环中，执行s +&#x3D; x++，x++是先运算，再自加，执行完后s＝0，x＝1，再回到while的判断条件，判断为false，跳出循环，输出s的值为0，答案选B。</p></blockquote><h3 id="2-6-循环结构之3：do-while循环"><a href="#2-6-循环结构之3：do-while循环" class="headerlink" title="2.6 循环结构之3：do-while循环"></a>2.6 循环结构之3：do-while循环</h3><p>do-while 结构是 while 的变体，它会先执行一次循环体，然后再判断是否满足条件。如果满足的话，就继续执行循环体，否则跳出循环。</p><h4 id="2-6-1-基本语法"><a href="#2-6-1-基本语法" class="headerlink" title="2.6.1 基本语法"></a>2.6.1 基本语法</h4><p><strong>语法格式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①初始化部分;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">③循环体部分</span><br><span class="line">④迭代部分</span><br><span class="line">&#125;<span class="keyword">while</span>(②循环条件部分); </span><br></pre></td></tr></table></figure><p>**执行过程：**①-③-④-②-③-④-②-③-④-…-②</p><p><strong>图示：</strong></p><img src="/img/images/image-20220512165558698.png" alt="image-20220512165558698" style="zoom:80%;" /><p><strong>说明：</strong></p><ul><li>do{}while();最后有一个分号</li><li>do-while结构的循环体语句是至少会执行一次，这个和for和while是不一样的</li><li>循环的三个结构for、while、do-while三者是可以相互转换的。</li></ul><h4 id="2-6-2-举例"><a href="#2-6-2-举例" class="headerlink" title="2.6.2 举例"></a>2.6.2 举例</h4><p>**案例1：**遍历1-100的偶数，并计算所有偶数的和、偶数的个数（累加的思想）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//遍历1-100的偶数，并计算所有偶数的和、偶数的个数（累加的思想）</span></span><br><span class="line">    <span class="comment">//初始化部分</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//记录1-100所有的偶数的和</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//记录1-100之间偶数的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//循环体部分</span></span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line">            sum += num;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        num++;<span class="comment">//迭代部分</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (num &lt;= <span class="number">100</span>); <span class="comment">//循环条件部分</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;偶数的总和为：%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;偶数的个数为：%d\n&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**案例2：**体会do-while至少会执行一次循环体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//while循环:</span></span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num1 &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello:while\n&quot;</span>);</span><br><span class="line">        num1--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//do-while循环:</span></span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello:do-while\n&quot;</span>);</span><br><span class="line">        num2--;</span><br><span class="line">    &#125; <span class="keyword">while</span> (num2 &gt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例3：ATM取款</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">声明变量balance并初始化为0，用以表示银行账户的余额，下面通过ATM机程序实现存款，取款等功能。</span><br><span class="line"></span><br><span class="line">=========ATM========</span><br><span class="line">   1、存款</span><br><span class="line">   2、取款</span><br><span class="line">   3、显示余额</span><br><span class="line">   4、退出</span><br><span class="line">请选择(1-4)：</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//初始化条件</span></span><br><span class="line">    <span class="type">double</span> balance = <span class="number">0.0</span>;<span class="comment">//表示银行账户的余额</span></span><br><span class="line">    <span class="type">int</span> selection; <span class="comment">//记录客户的选择</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> addMoney, minusMoney; <span class="comment">//分别记录存钱、取钱的额度</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> isFlag = <span class="number">1</span>;<span class="comment">//用于控制循环的结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=========ATM========\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t1、存款\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t2、取款\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t3、显示余额\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t4、退出\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请选择(1-4)：&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;selection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (selection) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;要存款的额度为：&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;addMoney);</span><br><span class="line">                <span class="keyword">if</span> (addMoney &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    balance += addMoney;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;要取款的额度为：&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;minusMoney);</span><br><span class="line">                <span class="keyword">if</span> (minusMoney &gt; <span class="number">0</span> &amp;&amp; balance &gt;= minusMoney) &#123;</span><br><span class="line">                    balance -= minusMoney;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;您输入的数据非法或余额不足\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;当前的余额为：%lf\n&quot;</span>, balance);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;欢迎下次进入此系统。^_^\n&quot;</span>);</span><br><span class="line">                isFlag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;请重新选择！\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (isFlag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-6-3-小结：三种循环结构"><a href="#2-6-3-小结：三种循环结构" class="headerlink" title="2.6.3 小结：三种循环结构"></a>2.6.3 小结：三种循环结构</h4><ul><li><strong>三种循环结构都具有四个要素：</strong><ul><li>循环变量的初始化条件</li><li>循环条件</li><li>循环体语句块</li><li>循环变量的修改的迭代表达式</li></ul></li></ul><ul><li><strong>从循环次数角度分析</strong><ul><li>do-while循环至少执行一次循环体语句。</li><li>for和while循环先判断循环条件语句是否成立，然后决定是否执行循环体。</li></ul></li><li><strong>如何选择</strong><ul><li>遍历有明显的循环次数（范围）的需求，选择for循环</li><li>遍历没有明显的循环次数（范围）的需求，选择while循环</li><li>如果循环体语句块至少执行一次，可以考虑使用do-while循环</li><li>本质上：三种循环之间完全可以互相转换，都能实现循环的功能</li></ul></li></ul><h3 id="2-7-“无限”循环"><a href="#2-7-“无限”循环" class="headerlink" title="2.7 “无限”循环"></a>2.7 “无限”循环</h3><img src="/img/images/类似：死循环.jpg" alt="类似：死循环" style="zoom:80%;" /><h4 id="2-7-1-基本语法"><a href="#2-7-1-基本语法" class="headerlink" title="2.7.1 基本语法"></a>2.7.1 基本语法</h4><p><strong>语法格式：</strong></p><ul><li>最简单”无限”循环格式：<code>while(1)</code> , <code>for(;;)</code></li></ul><p><strong>适用场景：</strong></p><ul><li>开发中，有时并不确定需要循环多少次，需要根据循环体内部某些条件，来控制循环的结束（使用break）。</li><li>如果此循环结构不能终止，则构成了死循环！开发中要避免出现死循环。</li></ul><h4 id="2-7-2-举例"><a href="#2-7-2-举例" class="headerlink" title="2.7.2 举例"></a>2.7.2 举例</h4><p>**案例1：**实现爱你到永远…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我爱你！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;end\n&quot;);//永远无法到达的语句</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; )&#123; <span class="comment">//循环变量没有修改，条件永远成立，死循环</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我爱你！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：如下代码执行效果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &gt;= <span class="number">10</span>;) &#123; <span class="comment">//一次都不执行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我爱你！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**案例2：**从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时结束程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> positiveNumber = <span class="number">0</span>;<span class="comment">//统计正数的个数</span></span><br><span class="line">    <span class="type">int</span> negativeNumber = <span class="number">0</span>;<span class="comment">//统计负数的个数</span></span><br><span class="line">    <span class="type">int</span> num;  <span class="comment">//记录输入的整数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;   <span class="comment">//for (;;)&#123;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数(输入为0时结束程序):&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            positiveNumber++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            negativeNumber++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;程序结束\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正数的个数为：%d\n&quot;</span>, positiveNumber);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;负数的个数为：%d\n&quot;</span>, negativeNumber);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-嵌套循环-或多重循环"><a href="#2-8-嵌套循环-或多重循环" class="headerlink" title="2.8 嵌套循环(或多重循环)"></a>2.8 嵌套循环(或多重循环)</h3><h4 id="2-8-1-使用说明"><a href="#2-8-1-使用说明" class="headerlink" title="2.8.1 使用说明"></a>2.8.1 使用说明</h4><ul><li><strong>所谓嵌套循环</strong>，是指一个循环结构A的循环体是另一个循环结构B。比如，for循环里面还有一个for循环，就是嵌套循环。其中，for ,while ,do-while均可以作为外层循环或内层循环。<ul><li>外层循环：循环结构A</li><li>内层循环：循环结构B</li></ul></li></ul><p><img src="/img/images/image-20230808152109498.png" alt="image-20230808152109498"></p><ul><li>实质上，<code>嵌套循环就是把内层循环当成外层循环的循环体</code>。只有当内层循环的循环条件为false（值为0）时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的外层循环。</li><li>设外层循环次数为<code>m</code>次，内层为<code>n</code>次，则内层循环体实际上需要执行<code>m*n</code>次。</li><li>**技巧：**从二维图形的角度看，外层循环控制<code>行数</code>，内层循环控制<code>列数</code>。</li><li>**开发经验：**实际开发中，我们最多见到的嵌套循环是两层。一般不会出现超过三层的嵌套循环。如果将要出现，一定要停下来重新梳理业务逻辑，重新思考算法的实现，控制在三层以内。否则，可读性会很差。</li></ul><p>例如：两个for嵌套循环格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句①; 循环条件语句②; 迭代语句⑦) &#123;</span><br><span class="line">    <span class="keyword">for</span>(初始化语句③; 循环条件语句④; 迭代语句⑥) &#123;</span><br><span class="line">      循环体语句⑤;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行过程：① - ② - ③ - ④ - ⑤ - ⑥ - ④ - ⑤ - ⑥ - ... - ④ - ⑦ - ② - ③ - ④ - ⑤ - ⑥ - ④..</span></span><br></pre></td></tr></table></figure><p>**执行特点：**外层循环执行一次，内层循环执行一轮。</p><h4 id="2-8-2-举例"><a href="#2-8-2-举例" class="headerlink" title="2.8.2 举例"></a>2.8.2 举例</h4><p>**案例1：*<em>打印5行6个</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ******</span></span><br><span class="line"><span class="comment">    ******</span></span><br><span class="line"><span class="comment">    ******</span></span><br><span class="line"><span class="comment">    ******</span></span><br><span class="line"><span class="comment">    ******</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**案例2：**打印5行直角三角形</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**案例3：**打印5行倒直角三角形</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ij(*的上限)   i + j = 6  --&gt; j = 6 - i</span><br><span class="line">*****   15</span><br><span class="line">****24</span><br><span class="line">***33</span><br><span class="line">**42</span><br><span class="line">*51</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">6</span> - i; j++) &#123;</span><br><span class="line">            printf(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例4：九九乘法表</strong></p><p><img src="/img/images/image-20221113193013204.png" alt="image-20221113193013204"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%d\t&quot;</span>, i, j, i * j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【北京航空航天大学2018研】对于下列for循环语句，请将其改写为功能完全相同的while循环语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,j,count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;  </span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">100</span>;j&gt;=i;j-=<span class="number">2</span>)  &#123;    </span><br><span class="line">count+=j-i;  </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>【答案】<br>此题可以在定义时先令i＝0，j＝100，在第一层while循环时只需判断i＜100即可，在第二层while循环时只需判断j＞＝i即可，j－＝2放在内层循环体中即可，具体程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">100</span>, count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">100</span>)&#123;  </span><br><span class="line"><span class="keyword">while</span>(j&gt;=i)  &#123;    </span><br><span class="line">count+=j-i;    </span><br><span class="line">j-=<span class="number">2</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">i++;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></blockquote><h3 id="2-9-break和continue关键字"><a href="#2-9-break和continue关键字" class="headerlink" title="2.9 break和continue关键字"></a>2.9 break和continue关键字</h3><h4 id="2-9-1-使用说明"><a href="#2-9-1-使用说明" class="headerlink" title="2.9.1 使用说明"></a>2.9.1 使用说明</h4><table><thead><tr><th>关键字</th><th>适用范围</th><th>循环结构中的作用</th><th>相同点</th></tr></thead><tbody><tr><td>break</td><td>switch-case</td><td>-</td><td>-</td></tr><tr><td>break</td><td>循环结构</td><td>一旦执行，就结束(或跳出)当前循环结构</td><td>此关键字的后面，不能声明语句</td></tr><tr><td>continue</td><td>循环结构</td><td>一旦执行，就结束(或跳出)当次循环结构</td><td>此关键字的后面，不能声明语句</td></tr></tbody></table><p>代码验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//123</span></span><br><span class="line">            <span class="comment">//continue;//123567910</span></span><br><span class="line">            <span class="comment">//如下的语句不可能被执行!</span></span><br><span class="line">            <span class="comment">//printf(&quot;今晚迪丽热巴要约我吃饭&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n####\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//嵌套循环中的使用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//结束的是包裹break关键字的最近的一层循环！</span></span><br><span class="line">                <span class="comment">//continue;//结束的是包裹break关键字的最近的一层循环的当次！</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-9-2-举例"><a href="#2-9-2-举例" class="headerlink" title="2.9.2 举例"></a>2.9.2 举例</h4><p>举例1：在全系1000名学生中举行慈善募捐，当总数达到10万元时就结束，统计此时捐款的人数以及平均每人捐款的数目。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUM 100000 <span class="comment">//指定符号常量SUM代表10万</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在全系1000名学生中举行慈善募捐，当总数达到10万元时就结束，统计此时捐款的人数以及平均每人捐款的数目。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> amount, total = <span class="number">0</span>;<span class="comment">//分别代表着每人捐款的数额，总捐款额</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">//捐款人数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入你的捐款额:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;amount);</span><br><span class="line">        total = total + amount;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (total &gt;= SUM)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> aver = total / count; <span class="comment">//人均捐款额度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捐款总人数是：%d\n人均捐款额为：%10.2f\n&quot;</span>, count, aver);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：要求输出100～200之间的不能被3整除的数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">100</span>; n &lt;= <span class="number">200</span>; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【华南理工大学2018研】编程求100～200间的全部素数。</p><p>【答案】<br>素数意思是只能被1和本身整除，因此将1到本身之间的数做除数，进行求余，如果余数为0，则不是素数，否则是素数。根据经验，假设所要判断的数为n，则一般只需要判断1到根号n之间的数即可，具体程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">//记录是否有约数</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">100</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= <span class="built_in">sqrt</span>(i); j++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (i % j == <span class="number">0</span>)&#123;</span><br><span class="line">             count++;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">     count = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>【武汉科技大学2019研】以下正确的描述是（　　）。<br>A．从多层循环嵌套中退出时，只能使用break语句<br>B．在循环体内使用continue和break语句，作用相同<br>C．只能在循环体内和switch体内使用break语句<br>D．continue语句的作用是结束整个循环的执行</p><p>【答案】C</p><p>【解析】从多层嵌套中退出不是只能使用break语句，也可以使用return或者程序自己执行完，A错误；在循环体内continue代表不执行该次循环中的剩余未执行语句，break代表直接跳出本层循环，BD错误，答案选C。</p></blockquote><blockquote><p> 【北京航空航天大学2018研】以下关于循环语句的叙述中，正确的是（　　）。<br> A．for循环语句的三个部分必须都要有表达式<br> B．while循环语句的循环体内至少要有一条语句<br> C．do…while循环语句的循环体至少会被执行一次<br> D．continue语句可以退出包含它的整个循环体</p><p> 【答案】C</p><p> 【解析】for循环的三个表达式都可以省略，但是之间的分号不能省略，同时要有退出循环的机制，因此A项错误；while循环语句的循环体内可以为空，并不违反相应语法，只不过循环什么也不执行，因此B项错误；continue语句只是不执行本次循环的剩余语句，而并非退出整个循环，因此D项错误，答案选C。</p></blockquote><h3 id="2-10-goto关键字"><a href="#2-10-goto关键字" class="headerlink" title="2.10 goto关键字"></a>2.10 goto关键字</h3><p>使用goto，可以实现无条件的语句的转移。</p><p><strong>一般格式：</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> 标号;</span><br></pre></td></tr></table></figure><blockquote><p>其中，标号，属于标识符，以“:”为标记，位于某语句前面。</p></blockquote><p>执行 goto 语句后，程序将跳转到指定标号处执行。这样可以随意将控制转移到程序中的任意一条语句上，然后执行它。</p><p><strong>举例1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    loop_label:<span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> loop_label;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop_label是一个标签名，可以放在正常语句的前面。程序执行到 goto 语句，就会跳转到它指定的标签名位置继续执行。因此，上面的代码会产生无限循环。</p><p>实际使用中，goto语句通常与条件语句配合。可用来实现条件转移，跳出循环体等功能。</p><p>**举例2：**录入学生成绩，并计算学生的平均分。当输入-1时程序结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score, i = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    next:<span class="built_in">printf</span>(<span class="string">&quot;请输入第 %d 个学生成绩(输入-1结束)：&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score);</span><br><span class="line">    <span class="keyword">if</span> (score != <span class="number">-1</span>) &#123;</span><br><span class="line">        sum += score;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">goto</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d个学生的平均分是 %d\n&quot;</span>,i, sum / i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：goto 只能在同一个函数之中跳转，并不能跳转到其他函数。</p></blockquote><p>**举例3：**goto 的一个主要用法是跳出多层循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(...) &#123;</span><br><span class="line">  <span class="keyword">for</span> (...) &#123;</span><br><span class="line">    <span class="keyword">while</span> (...) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (some_error_condition)</span><br><span class="line">          <span class="keyword">goto</span> bail;    </span><br><span class="line">     &#125; <span class="keyword">while</span>(...);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">bail:</span><br><span class="line"><span class="comment">// ... ...</span></span><br></pre></td></tr></table></figure><p>上面代码有很复杂的嵌套循环，不使用 goto 的话，想要完全跳出所有循环，写起来很麻烦。</p><p>**举例4：**goto 的另一个用途是提早结束多重判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (do_something() == ERR)</span><br><span class="line">  <span class="keyword">goto</span> error;</span><br><span class="line"><span class="keyword">if</span> (do_something2() == ERR)</span><br><span class="line">  <span class="keyword">goto</span> error;</span><br><span class="line"><span class="keyword">if</span> (do_something3() == ERR)</span><br><span class="line">  <span class="keyword">goto</span> error;</span><br><span class="line"><span class="keyword">if</span> (do_something4() == ERR)</span><br><span class="line">  <span class="keyword">goto</span> error;</span><br></pre></td></tr></table></figure><p>上面示例有四个判断，只要有一个发现错误，就使用 goto 跳过后面的判断。</p><blockquote><p>小结：</p><p>从理论上 goto语句是没有必要的，实践中没有goto语句也可以很容易的写出代码。使用goto反而容易造成程序流程的混乱，致使程序容易出错。故建议不要轻易使用。</p><p>这里只是为了语法的完整，介绍一下它的用法。</p></blockquote><h1 id="第04章-数组"><a href="#第04章-数组" class="headerlink" title="第04章_数组"></a>第04章_数组</h1><h2 id="本章专题脉络-3"><a href="#本章专题脉络-3" class="headerlink" title="本章专题脉络"></a>本章专题脉络</h2><p><img src="/img/images/%E7%AC%AC4%E7%AB%A0_%E6%95%B0%E7%BB%84.png" alt="第4章_数组"></p><h2 id="1、数组的概述"><a href="#1、数组的概述" class="headerlink" title="1、数组的概述"></a>1、数组的概述</h2><h3 id="1-1-为什么需要数组"><a href="#1-1-为什么需要数组" class="headerlink" title="1.1 为什么需要数组"></a>1.1 为什么需要数组</h3><p><strong>需求分析1：</strong></p><p>需要统计某公司50个员工的工资情况，例如计算平均工资、找到最高工资等。用之前知识，首先需要声明<code>50个变量</code>来分别记录每位员工的工资，这样会很麻烦。因此我们可以将所有的数据全部存储到一个容器中统一管理，并使用容器进行计算。</p><p><strong>需求分析2：</strong></p><img src="/img/images/snipaste_20220317_000101.jpg" alt="snipaste_20220317_000101" style="zoom: 50%;" /><p>容器的概念：</p><ul><li>**生活中的容器：**水杯（装水等液体），衣柜（装衣服等物品），集装箱（装货物等）。</li><li>**程序中的容器：**将多个数据存储到一起，每个数据称为该容器的元素。</li></ul><h3 id="1-2-数组的概念"><a href="#1-2-数组的概念" class="headerlink" title="1.2 数组的概念"></a>1.2 数组的概念</h3><ul><li><p>数组(Array)，是多个<code>相同类型</code>数据按<code>一定顺序</code>排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</p></li><li><p>数组中的概念</p><ul><li>数组名</li><li>下标（或索引、index）</li><li>元素</li><li>数组的长度</li></ul></li></ul><p><img src="/img/images/image-20220317000952499.png" alt="image-20220317000952499"></p><p><strong>数组的特点：</strong></p><ul><li>数组中的元素在内存中是依次紧密排列的，有序的。</li><li>创建数组对象会在内存中开辟一整块<code>连续的空间</code>。占据的空间的大小，取决于数组的长度和数组中元素的类型。</li><li>我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快。</li><li>数组，一旦初始化完成，其长度就是确定的。数组的<code>长度一旦确定，就不能修改</code>。</li><li>数组名中引用的是这块连续空间的首地址。</li></ul><h3 id="1-3-数组的分类"><a href="#1-3-数组的分类" class="headerlink" title="1.3 数组的分类"></a>1.3 数组的分类</h3><p><strong>按照数组维度分：</strong></p><ul><li>一维数组：存储一组数据</li><li>二维数组：存储多组数据，相当于二维表，一行代表一组数据。每一行长度可以不同。</li><li>三维数组、四维数组、….</li></ul><p><img src="/img/images/image-20230808152439557.png" alt="image-20230808152439557"></p><p><strong>按照元素的数据类型分：</strong></p><ul><li>int类型数组</li><li>char类型数组</li><li>double类型数组</li><li>….</li></ul><h2 id="2、一维数组的定义"><a href="#2、一维数组的定义" class="headerlink" title="2、一维数组的定义"></a>2、一维数组的定义</h2><h3 id="2-1-数组的定义方式1"><a href="#2-1-数组的定义方式1" class="headerlink" title="2.1 数组的定义方式1"></a>2.1 数组的定义方式1</h3><p>数组通过变量名后加方括号表示，方括号里面是数组可以容纳的成员数量（即长度）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];  <span class="comment">//数组 arr ，里面包含10个成员，每个成员都是 int 类型</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 10</span></span><br><span class="line"><span class="type">int</span> arr1[NUM];</span><br></pre></td></tr></table></figure><p>注意，声明数组时，必须给出数组的大小。</p><img src="/img/images/image-20230809143245377.png" alt="image-20230809143245377" style="zoom: 67%;" /><h3 id="2-2-数组元素的调用"><a href="#2-2-数组元素的调用" class="headerlink" title="2.2 数组元素的调用"></a>2.2 数组元素的调用</h3><ul><li><p>格式：<code>数组名[下标]</code></p></li><li><p>数组的<code>下标从0开始</code>，用“int arr[10];”定义数组，则<code>最大下标值为9</code>，不存在数组元素arr[10]。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="number">13</span>;       <span class="comment">//对该位置数组元素进行赋值</span></span><br><span class="line"><span class="type">int</span> score = arr[<span class="number">0</span>]; <span class="comment">//调用此位置的元素值</span></span><br></pre></td></tr></table></figure><p><strong>数组角标越界：</strong></p><p>假设数组有n个元素，如果使用的数组的下标小于0，或者大于n-1，就是数组越界访问了，超出了数组合法空间的访问。</p><p>C语言不做数组下标越界的检查，编译器也不一定报错，但是编译器不报错，并不意味着程序就是正确！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores[<span class="number">20</span>];</span><br><span class="line">scores[<span class="number">20</span>] = <span class="number">51</span>;</span><br></pre></td></tr></table></figure><blockquote><p>说明：数组 scores 只有20个成员，因此 scores[20] 这个位置是不存在的。但是，引用这个位置并不会报错。赋值操作会导致紧跟在 scores 后面的那块内存区域被赋值(这实际是其它变量的区域)，因此不知不觉就更改了其它变量的值。这很容易引发错误，而且难以发现。</p></blockquote><h3 id="2-3-关于长度"><a href="#2-3-关于长度" class="headerlink" title="2.3 关于长度"></a>2.3 关于长度</h3><p><strong>数组的字节长度</strong></p><p>sizeof 运算符会返回整个数组的字节长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数组的字节长度为：%zd\n&quot;</span>,<span class="keyword">sizeof</span>(arr)); <span class="comment">//40</span></span><br></pre></td></tr></table></figure><p><strong>数组的长度</strong></p><p>在定义数组时，需要指定数组中元素的个数，方括号中的常量表达式用来表示元素的个数，即数组长度。</p><p>由于数组成员都是同一个类型，每个成员的字节长度都是一样的，所以数组整体的字节长度除以某个数组元素的字节长度，就可以得到数组的成员数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中元素的个数：</span></span><br><span class="line"><span class="type">int</span> arrLen = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数组的字节长度为：%zu\n&quot;</span>, <span class="keyword">sizeof</span>(a));   <span class="comment">// 40</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数组每个元素的字节长度为：%zu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数组的长度为：%zu\n&quot;</span>, <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><blockquote><p>复习： sizeof 返回值的数据类型是 <code>size_t</code> ，所以 sizeof(a) &#x2F; sizeof(a[0]) 的数据类型也是size_t 。在 printf() 里面的占位符，要用 %zd 或 %zu 。</p></blockquote><p>注意：数组一旦声明&#x2F;定义了，其<strong>长度就固定了，不能动态变化</strong>。</p><h3 id="2-4-数组的遍历"><a href="#2-4-数组的遍历" class="headerlink" title="2.4 数组的遍历"></a>2.4 数组的遍历</h3><p>将数组中的每个元素分别获取出来，就是<code>遍历</code>。for循环与数组的遍历是绝配。</p><p>举例1：声明长度为10的int类型数组，给数组元素依次赋值为0,1,2,3,4,5,6,7,8,9，并遍历数组所有元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给数组中的每个元素赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="type">int</span>); i++) &#123; <span class="comment">//对数组元素arr[0]~arr[9]赋值</span></span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历数组中的元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;遍历数组中的元素：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="type">int</span>); i++) &#123; <span class="comment">//输出arr[0]~arr[9]共10个数组元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-数组的其它定义方式"><a href="#2-5-数组的其它定义方式" class="headerlink" title="2.5 数组的其它定义方式"></a>2.5 数组的其它定义方式</h3><p><strong>定义方式2：</strong>(定义方式1在2.1节讲的)</p><p>数组可以在声明时，使用大括号，同时对每一个成员赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">90</span>, <span class="number">48</span>, <span class="number">95</span>&#125;;</span><br></pre></td></tr></table></figure><p><code>变形形式1：</code>C 语言允许省略方括号里面的数组成员数量，这时根据大括号里面的值的数量，自动确定数组的长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;  <span class="comment">//数组 arr 的长度，将根据大括号里面的值的数量，确定为 3</span></span><br></pre></td></tr></table></figure><p><code>变形形式2：</code></p><p>对数组部分元素赋初值：如果大括号里面的值，少于数组的成员数量，那么未赋值的成员自动初始化为 0 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p><code>变形方式3</code>：</p><p>将整个数组的每一个成员都设置为零，最简单的方式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p><code>错误方式：</code></p><p>使用大括号赋值时，大括号里面的值不能多于数组的长度，否则编译时会报错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>**定义方式3：**数组初始化时，可以指定为哪些位置的成员赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">15</span>] = &#123;[<span class="number">2</span>] = <span class="number">10</span>, [<span class="number">5</span>] = <span class="number">20</span>, [<span class="number">14</span>] = <span class="number">30</span>&#125;;  <span class="comment">//非角标2、5、14的位置自动赋值为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">15</span>] = &#123;[<span class="number">5</span>] = <span class="number">20</span>, [<span class="number">14</span>] = <span class="number">30</span>, [<span class="number">2</span>] = <span class="number">10</span>&#125;; <span class="comment">//指定位置的赋值可以不按角标从小到大的顺序</span></span><br></pre></td></tr></table></figure><p><code>变形形式1：</code>指定位置的赋值与顺序赋值，可以结合使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">15</span>] = &#123;<span class="number">1</span>, [<span class="number">5</span>] = <span class="number">10</span>, <span class="number">11</span>, [<span class="number">10</span>] = <span class="number">20</span>, <span class="number">21</span>&#125;; <span class="comment">//角标0、5、6、10、11的位置被赋值</span></span><br></pre></td></tr></table></figure><p><code>变形形式2：</code>省略成员数量时，如果同时采用指定位置的赋值，那么数组长度将是最大的指定位置再加1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;[<span class="number">2</span>] = <span class="number">6</span>, [<span class="number">9</span>] = <span class="number">12</span>&#125;;  <span class="comment">//此时数组的长度是10</span></span><br></pre></td></tr></table></figure><h2 id="3、一维数组内存分析"><a href="#3、一维数组内存分析" class="headerlink" title="3、一维数组内存分析"></a>3、一维数组内存分析</h2><h3 id="3-1-数组内存图"><a href="#3-1-数组内存图" class="headerlink" title="3.1 数组内存图"></a>3.1 数组内存图</h3><p>针对于如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>对应的内存结构：</p><img src="/img/images/image-20230811192849889.png" alt="image-20230811192849889" style="zoom: 70%;" /><p>说明：</p><p>1）数组名，记录该数组的首地址 ，即 a[0]的地址。</p><p>2）数组的各个元素是连续分布的， 假如 a[0] 地址是0x1122，则<code>a[1]地址= a[0]的地址+int字节数(4)</code> &#x3D; 0x1122 + 4 &#x3D; 0x1126，后面 <code>a[2] 地址 = a[1]地址 + int 字节数(4)</code> &#x3D; 0x1126 + 4 &#x3D; 0x112A，依次类推…</p><h3 id="3-2-注意事项"><a href="#3-2-注意事项" class="headerlink" title="3.2 注意事项"></a>3.2 注意事项</h3><p>**C 语言规定，数组变量一旦声明，数组名指向的地址就不可更改。**因为声明数组时，编译器会自动为数组分配内存地址，这个地址与数组名是绑定的，不可更改。</p><p>因此，当数组定义后，再用大括号重新赋值，是不允许的。下面的代码会报错。</p><p>错误举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums[<span class="number">5</span>];</span><br><span class="line">nums = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>, <span class="number">18</span>, <span class="number">95</span>&#125;; <span class="comment">// 使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。</span></span><br></pre></td></tr></table></figure><p>错误举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">nums = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>错误举例3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ints[<span class="number">100</span>];</span><br><span class="line">ints = <span class="literal">NULL</span>; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>这也导致不能将一个数组名赋值给另外一个数组名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">5</span>] = a; <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">5</span>];</span><br><span class="line">b = a; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面两种写法都会更改数组 b 的地址，导致报错。</p><h3 id="3-3-变长数组"><a href="#3-3-变长数组" class="headerlink" title="3.3 变长数组"></a>3.3 变长数组</h3><p>数组声明的时候，数组长度除了使用常量，也可以使用变量或表达式来指定数组的大小。这叫做<code>变长数组</code>（variable-length array，简称 VLA）。</p><p><strong>方式1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[n];</span><br></pre></td></tr></table></figure><p>变长数组的根本特征是数组长度只有<code>运行时才能确定</code>。它的好处是程序员不必在开发时，随意为数组指定一个估计的长度，程序可以在运行时为数组分配精确的长度。</p><p>任何长度需要运行时才能确定的数组，都是变长数组。比如，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a1[i];</span><br><span class="line"><span class="type">int</span> a2[i + <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> a3[i + k];</span><br></pre></td></tr></table></figure><blockquote><p>注意：变长数组在C99标准中被引入，在C11标准中被标记为可选特性。某些编译器可能不支持变长数组，或者可能有特定的限制和行为。</p></blockquote><p><strong>方式2：</strong></p><p>如果你的编译器版本不支持变长数组，还可以考虑使用动态内存分配（使用<code>malloc()函数</code> ）来创建动态大小的数组。</p><p>分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> length = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(length * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(arr);</span><br></pre></td></tr></table></figure><h2 id="4、一维数组的应用"><a href="#4、一维数组的应用" class="headerlink" title="4、一维数组的应用"></a>4、一维数组的应用</h2><h3 id="4-1-数值型数组特征值统计"><a href="#4-1-数值型数组特征值统计" class="headerlink" title="4.1 数值型数组特征值统计"></a>4.1 数值型数组特征值统计</h3><p>这里的特征值涉及到：平均值、最大值、最小值、总和等</p><p>举例1：定义一个int型的一维数组，包含10个元素，然后求出数组中的最大值，最小值，总和，平均值，并输出出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">34</span>, <span class="number">54</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">54</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">87</span>, <span class="number">43</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];<span class="comment">//用于记录数组的最大值</span></span><br><span class="line">    <span class="type">int</span> arrLen = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">int</span>);<span class="comment">//获取数组中元素的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; arr[i]) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大值为：%d\n&quot;</span>, max);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取数组的最小值</span></span><br><span class="line">    <span class="type">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; arr[i]) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最小值为：%d\n&quot;</span>, min);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取数组的总和</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;总和为：%d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取数组的平均值</span></span><br><span class="line">    <span class="type">int</span> avg = sum / arrLen;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;平均值为：%d\n&quot;</span>, avg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：评委打分</p><p>分析以下需求，并用代码实现：</p><p>（1）在编程竞赛中，有10位评委为参赛的选手打分，分数分别为：5，4，6，8，9，0，1，2，7，3</p><p>（2）求选手的最后得分（去掉一个最高分和一个最低分后其余8位评委打分的平均值）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> scores[<span class="number">10</span>] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = scores[<span class="number">0</span>]; <span class="comment">//记录最高分</span></span><br><span class="line">    <span class="type">int</span> min = scores[<span class="number">0</span>]; <span class="comment">//记录最低分</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//记录总分</span></span><br><span class="line">    <span class="type">int</span> arrLen = <span class="keyword">sizeof</span>(scores) / <span class="keyword">sizeof</span>(<span class="type">int</span>); <span class="comment">//记录数组长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; arrLen;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max &lt; scores[i])&#123;</span><br><span class="line">            max = scores[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(min &gt; scores[i])&#123;</span><br><span class="line">            min = scores[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum += scores[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算平均分</span></span><br><span class="line">    <span class="type">double</span> avg = (<span class="type">double</span>)(sum - max - min) / (arrLen - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;选手去掉最高分和最低分之后的平均分为：%.2lf\n&quot;</span> , avg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-数组的复制"><a href="#4-2-数组的复制" class="headerlink" title="4.2 数组的复制"></a>4.2 数组的复制</h3><p>由于数组名是指针，所以复制数组不能简单地复制数组名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"><span class="type">int</span>* b;</span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure><p>上面的写法，结果不是将数组 a 复制给数组 b ，而是让 a 和 b 指向同一个数组。</p><p><strong>正确方式1：使用循环</strong></p><p>这是复制数组最简单的方法，将数组元素逐个进行复制。比如，将数组 a 的成员逐个复制给数组 b。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[LENGTH] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[LENGTH];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制数组 a 到数组 b</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LENGTH; i++) &#123;</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数组 b 的内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;复制后的数组 b：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LENGTH; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确方式2：使用 memcpy() 函数</strong></p><p> memcpy() 函数定义在头文件 string.h 中，直接把数组所在的那一段内存，再复制一份。3个参数依次为：<code>目标数组</code>、<code>源数组</code>以及<code>要复制的字节数</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[LENGTH] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[LENGTH];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 memcpy 函数复制数组 a 到数组 b</span></span><br><span class="line">    <span class="built_in">memcpy</span>(b, a, LENGTH * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数组 b 的内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;复制后的数组 b：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LENGTH; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两种方式对比：</strong></p><p>下面是对两种方式进行比较的一些要点：</p><ol><li>循环复制：<ul><li>优点：<code>简单直观</code>，容易理解和实现。不需要引入额外的头文件。</li><li>缺点：需要编写循环代码来遍历数组并逐个赋值，相对而言可能<code>稍显繁琐</code>。不适用于复制大型数组或复杂数据结构。</li></ul></li><li>memcpy函数复制：<ul><li>优点：使用标准库提供的函数，可以实现<code>快速且高效</code>的内存复制。适用于<code>大型数组或复杂数据</code>结构的复制。可以直接复制字节数，不需要遍历数组。</li><li>缺点：需要包含 <code>&lt;string.h&gt;</code> 头文件。对于简单的数组复制，可能有些<code>过于繁重</code>。</li></ul></li></ol><h3 id="4-3-数组元素的反转"><a href="#4-3-数组元素的反转" class="headerlink" title="4.3 数组元素的反转"></a>4.3 数组元素的反转</h3><p>**实现思想：**数组对称位置的元素互换。</p><p>方式1：</p><img src="/img/images/image-20221117195931777.png" alt="image-20221117195931777" style="zoom:67%;" /><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">//数组的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始数组：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size / <span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[size - <span class="number">1</span> - i];</span><br><span class="line">        arr[size - <span class="number">1</span> - i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;反转后的数组：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2：</p><p><img src="/img/images/1688562327054.png" alt="1688562327054"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">//数组的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始数组：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>; <span class="comment">// 起始指针</span></span><br><span class="line">    <span class="type">int</span> right = size - <span class="number">1</span>; <span class="comment">// 结尾指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 交换起始指针和结尾指针指向的元素</span></span><br><span class="line">        <span class="type">int</span> temp = arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新指针位置</span></span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;反转后的数组：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-char型数组与字符串"><a href="#4-4-char型数组与字符串" class="headerlink" title="4.4 char型数组与字符串"></a>4.4 char型数组与字符串</h3><h4 id="4-4-1-char型数组"><a href="#4-4-1-char型数组" class="headerlink" title="4.4.1 char型数组"></a>4.4.1 char型数组</h4><p>字符型数组，顾名思义，数组元素的数据类型为字符型的数组。</p><p>一方面，可以看做普通的数组，初始化、常用操作如前所述。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>另一方面，字符型数组可以用于存储字符串。</p><h4 id="4-4-2-字符串的使用"><a href="#4-4-2-字符串的使用" class="headerlink" title="4.4.2 字符串的使用"></a>4.4.2 字符串的使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;helloworld&quot;</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="string">&quot;123&quot;</span></span><br></pre></td></tr></table></figure><p>这种由双引号引起来的一串字符称为字符串字面值(String Literal)，简称字符串(String)。</p><p>通常把<code>&quot;&quot;</code>称为<code>空串</code>，即一个不包含任意字符的字符串；而<code>&quot; &quot;</code>则称为<code>空格串</code>，是包含一个空格字符的字符串。二者不能等同。</p><p>C语言没有专门用于存储字符串的变量类型，字符串都被存储在char类型的数组中。在字符串结尾，C 语言会自动添加一个<code>&#39;\0&#39; </code>的转义字符作为字符串结束的标志，所以字符数组也必须以 ‘\0’字符结束。</p><p><strong>声明方式1：标准写法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显式以&#x27;\0&#x27;为最后一个字符元素结束</span></span><br><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果一个字符数组声明如下，由于必须留一个位置给 <code>\0</code> ，所以最多只能容纳9个字符的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p><strong>声明方式2：简化写法</strong></p><p>字符串写成数组的形式，是非常麻烦的，C 语言提供了一种简化写法。双引号之中的字符，会被自动视为字符数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动在末尾添加&#x27;\0&#x27;字符</span></span><br><span class="line"><span class="type">char</span> str1[<span class="number">12</span>] = &#123;<span class="string">&quot;hello world&quot;</span>&#125;;  <span class="comment">//注意使用双引号，非单引号</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="type">char</span> str2[<span class="number">12</span>] = <span class="string">&quot;hello world&quot;</span>;   <span class="comment">//可以省略一对&#123;&#125;来初始化数组元素</span></span><br></pre></td></tr></table></figure><p>由于字符数组的长度可以让编译器自动计算，所以声明时可以省略字符数组的长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = &#123;<span class="string">&quot;hello world&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;hello world&quot;</span>; </span><br></pre></td></tr></table></figure><p>双引号里面的字符串，不用自己添加结尾字符 \0 ，C 语言会自动添加。所以，代码中数组 str1或str2的元素依次为 ‘h’, ‘e’, ‘l’, ‘l’, ‘o’, ‘ ‘, ‘w’, ‘o’, ‘r’, ‘l’, ‘d’, ‘\0’。</p><p><strong>字符串对应数组的长度</strong></p><p>对应的存储为：</p><p><img src="/img/images/1689220044896.png" alt="1689220044896"></p><p>其中，数组由连续的存储单元组成，字符串中的字符被存储在相邻的存储单元中，每个单元存储一个字符。所以，上述两个数组的长度不是11，而是12。</p><p><strong>字符串的长度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> nation[<span class="number">10</span>]=&#123;<span class="string">&quot;China&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>数组nation的前5个元素为: ′C′,′h′,′i′,′n′,′a′，第6个元素为′\0′，后4个元素也自动设定为空字符。</p><p> <img src="/img/images/image-20230527130601936.png" alt="image-20230527130601936"></p><blockquote><p>注意：在计算字符串长度的时候，’\0’ 是结束标志，不算作字符串内容。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    <span class="comment">//需要加载此头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> nation[<span class="number">10</span>] = <span class="string">&quot;China&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(nation));     <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>区分：’\0’、0、’0’</strong></p><p>字符 ‘\0’ 不同于字符 ‘0’ ，前者的ASCII 码是0（二进制形式 00000000 ），后者的 ASCII 码是48（二进制形式 00110000 ）。</p><p><strong>练习1：字符数组、字符串的长度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">50</span>] = <span class="string">&quot;hello&quot;</span>;  <span class="comment">//声明1</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;hello&quot;</span>;    <span class="comment">//声明2</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s3[<span class="number">5</span>] = <span class="string">&quot;hello&quot;</span>;   <span class="comment">//声明3</span></span><br></pre></td></tr></table></figure><p>对于声明1：赋给的元素的个数小于该数组的长度，则会自动在后面加 ‘\0’, 表示字符串结束。所以，字符数组 s1 的长度是 50 ，但是字符串“hello”的实际长度只有5（不包含结尾符号 ‘\0’ ），所以后面空出来的45个位置，都会被初始化为 ‘\0’。</p><p>对于声明2：字符数组 s2 的长度是 6（包含结尾符号 ‘\0’ ），但是字符串“hello”的实际长度只有5。</p><p>对于声明3：赋给的元素的个数等于该数组的长度，则不会自动添加 ‘\0’。但字符串要求以’\0’结束，所以这种写法是错误的，要避免。</p><p><strong>练习2：比较”x”和’x’的不同</strong></p><ul><li><p>书写形式不同：字符串常量用双引号，字符常量用单引号。</p></li><li><p>存储空间不同：在内存中，字符常量只占用一个字节的存储空间，而字符串存储时自动加一个结束标记’\0’，所以’x’占用1个字节，而”x”占用2个字节。</p><p><img src="/img/images/1689220271310.png" alt="1689220271310"></p></li><li><p>二者的操作也不相同。例如，可对字符常量进行加减运算，字符串常量则不能。</p></li></ul><p><strong>练习3：输出字符数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str1[]=&#123;<span class="string">&quot;China\nBeijing&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(str1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(str2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 【中央财经大学2018研】若有定义和语句：char s[10]; s&#x3D;”abcd”; printf(“%s\n”,s);，则结果是（　）。<br> A．输出abcd@#$<br> B．输出a<br> C．输出abcd<br> D．编译不通过</p><p> 【答案】D</p><p> 【解析】在定义一维字符数组时，s为数组名，指向数组首元素的地址，为地址常量，不可更改，因此语句s＝”abcd”是非法的，编译不会通过。</p></blockquote><h2 id="5、多维数组"><a href="#5、多维数组" class="headerlink" title="5、多维数组"></a>5、多维数组</h2><h3 id="5-1-理解"><a href="#5-1-理解" class="headerlink" title="5.1 理解"></a>5.1 理解</h3><p>二维数组、三维数组、…都称为多维数组。本节主要讲解二维数组，三维及以上的数组，以此类推即可。</p><p>举例：公司有3个攻坚小分队，每队有6名同事，要把这些同事的工资用数组保存起来以备查看。</p><p><img src="/img/images/1688563352491.png" alt="1688563352491"></p><p>此时建立数组salary用于存储工资，它应当是二维的。第一维用来表示第几分队，第二维用来表示第几个同事。例如用<code>salary2,3</code>表示角标2对应分队的角标3对应队员的工资。</p><blockquote><p>对于二维数组的理解，可以看作是由一维数组嵌套而成的。即一维数组array1又作为另一个一维数组array2的元素而存在。</p></blockquote><h3 id="5-2-二维数组的定义方式1"><a href="#5-2-二维数组的定义方式1" class="headerlink" title="5.2 二维数组的定义方式1"></a>5.2 二维数组的定义方式1</h3><p><strong>定义方式1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">//二维数组</span></span><br></pre></td></tr></table></figure><p>二维数组a可看成由三个一维数组构成，它们的数组名分别为 a[0]、a[1]、a[2]。这三个一维数组各有 4 个元素，如，一维数组 a[0] 的元素为 <code>a[0][0]</code>、<code>a[0][1]</code>、<code>a[0][2]</code>、<code>a[0][3]</code>。二维数组a共有12个成员（3 x 4 &#x3D; 12）。</p><p><img src="/img/images/image-20230808154409706.png" alt="image-20230808154409706"></p><p>也可以简化理解为：</p><img src="/img/images/image-20230818150550203.png" alt="image-20230818150550203" style="zoom: 80%;" /><p>二维数组，常称为<code>矩阵(matrix)</code>。把二维数组写成<code>行(row)</code>和<code>列(column)</code>的排列形式，可以形象化地理解二维数组的逻辑结构。</p><p>三维数组如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>]; <span class="comment">//三维数组</span></span><br></pre></td></tr></table></figure><blockquote><p>技巧：C 语言允许声明多维数组，有多少个维度，就用多少个方括号，比如二维数组就使用两个方括号。</p></blockquote><p><strong>错误方式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a[<span class="number">3</span>,<span class="number">4</span>];  <span class="comment">//在一对方括号内不能写两个下标</span></span><br></pre></td></tr></table></figure><h3 id="5-3-二维数组的内存分析"><a href="#5-3-二维数组的内存分析" class="headerlink" title="5.3 二维数组的内存分析"></a>5.3 二维数组的内存分析</h3><p>用<code>矩阵形式</code>（如3行4列形式）表示二维数组，是<code>逻辑</code>上的概念，能形象地表示出行列关系。而在<code>内存</code>中，各元素是连续存放的，不是二维的，是<code>线性</code>的。</p><p>C语言中，二维数组中元素排列的顺序是<code>按行存放</code>的。即：先顺序存放第一行的元素，再存放第二行的元素。（最右边的下标变化最快，第一维的下标变化最慢）。</p><p><img src="/img/images/image-20230808154933145.png" alt="image-20230808154933145"></p><p>举例，整型数组<code>b[3][3]</code>在内存中的存放：</p><img src="/img/images/image-20230818151137312.png" alt="image-20230818151137312" style="zoom:80%;" /><p>举例：关于长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(b)); <span class="comment">//36</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(b)/<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//9</span></span><br></pre></td></tr></table></figure><h3 id="5-4-成员的调用"><a href="#5-4-成员的调用" class="headerlink" title="5.4 成员的调用"></a>5.4 成员的调用</h3><p>格式：<strong>数组名[下标] [下标]</strong></p><p>跟一维数组一样，多维数组每个维度的第一个成员也是从 0 开始编号。</p><p>举例1：给指定索引位置的元素赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line"><span class="comment">//给指定索引位置的元素赋值</span></span><br><span class="line">arr1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">arr1[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>举例2：查看数组元素的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr2[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr2[%d][%d] = %p\n&quot;</span>, i, j, &amp;arr2[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><img src="/img/images/image-20230829233626295.png" alt="image-20230829233626295" style="zoom:67%;" /><h3 id="5-5-二维数组其它定义方式"><a href="#5-5-二维数组其它定义方式" class="headerlink" title="5.5 二维数组其它定义方式"></a>5.5 二维数组其它定义方式</h3><p><strong>定义方式2：声明与初始化同时进行</strong></p><p>多维数组也可以使用大括号，在声明的同时，一次性对所有成员赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">               &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">               &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>上例中， a 是一个二维数组，这种赋值写法相当于将第一维的每个成员写成一个数组。</p><p><img src="/img/images/1689217852598.png" alt="1689217852598"></p><blockquote><p>说明：这里的地址以十进制数值进行的说明。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a[<span class="number">0</span>]);     <span class="comment">//0000006ac71ffd30</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a[<span class="number">0</span>] + <span class="number">1</span>); <span class="comment">//0000006ac71ffd34</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a[<span class="number">0</span>] + <span class="number">2</span>); <span class="comment">//0000006ac71ffd38</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a[<span class="number">0</span>] + <span class="number">3</span>); <span class="comment">//0000006ac71ffd3c</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a[<span class="number">0</span>] + <span class="number">4</span>); <span class="comment">//0000006ac71ffd40</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a + <span class="number">1</span>);    <span class="comment">//0000006ac71ffd40</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a[<span class="number">1</span>]);     <span class="comment">//0000006ac71ffd40</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a[<span class="number">1</span>] + <span class="number">1</span>); <span class="comment">//0000006ac71ffd44</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义方式3：部分元素赋值</strong></p><p>多维数组也可以仅为指定的位置进行初始化赋值，未赋值的成员会自动设置为“零”值 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定了 [0][0] 和 [1][1] 位置的值，其他位置就自动设为 0 。</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, [<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>&#125;;  </span><br></pre></td></tr></table></figure><p><strong>定义方式4：使用单层大括号赋值</strong></p><p>多维数组也可以使用单层大括号赋值。不管数组有多少维度，在内存里面都是线性存储。对于<code>a[2][2]</code>来说， <code>a[0][0]</code> 的后面是 <code>a[0][1]</code> ，再后面是<code>a[1][0]</code> ，以此类推。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;  <span class="comment">//会自动匹配到各行各列</span></span><br></pre></td></tr></table></figure><p><strong>定义方式5：方式4的简化</strong></p><p>在方式4的基础上，如果对全部元素赋值，那么第一维的长度可以不给出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int a[2][3] = &#123;1, 2, 3, 4, 5, 6&#125;; </span></span><br><span class="line"><span class="comment">//可以写为：</span></span><br><span class="line"><span class="type">int</span> a[][<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;; </span><br><span class="line"><span class="comment">//也可以写为：</span></span><br><span class="line"><span class="type">int</span> a[][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;; <span class="comment">//行数自然判定为2</span></span><br></pre></td></tr></table></figure><p>练习：下面哪些赋值操作是正确的？（都对）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">3</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;  <span class="comment">//对应定义方式2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">3</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;  <span class="comment">//对应定义方式4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr3[][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;  <span class="comment">//对应定义方式5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr4[][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;; <span class="comment">//对应定义方式5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr5[][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  <span class="comment">//对应定义方式5。未显式赋值的位置默认赋值为0</span></span><br></pre></td></tr></table></figure><p>**错误方式：**在定义二维数组时，必须指定列数（即一行中包含几个元素）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[][];  <span class="comment">//错误，必须指定列数</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>][]; <span class="comment">//错误，必须指定列数</span></span><br></pre></td></tr></table></figure><h3 id="5-6-举例"><a href="#5-6-举例" class="headerlink" title="5.6 举例"></a>5.6 举例</h3><p>举例1：获取arr数组中所有元素的和</p><p>提示：使用for的嵌套循环即可。</p><p><img src="/img/images/image-20220317005436209.png" alt="image-20220317005436209"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROWS 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLS 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[ROWS][COLS] = &#123;&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">12</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">7</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//记录总和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROWS; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COLS; j++) &#123;</span><br><span class="line">            sum += arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;总和为%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：求二维数组最大值以及对应的行列角标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROWS 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLS 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[ROWS][COLS] = &#123;&#123;<span class="number">1</span>,   <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>&#125;,</span><br><span class="line">                         &#123;<span class="number">9</span>,   <span class="number">8</span>,  <span class="number">7</span>,  <span class="number">6</span>&#125;,</span><br><span class="line">                         &#123;<span class="number">-10</span>, <span class="number">10</span>, <span class="number">-5</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxValue = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> maxRow = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxCol = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROWS; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COLS; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; a[i][j]) &#123;</span><br><span class="line">                maxValue = a[i][j];</span><br><span class="line">                maxRow = i;</span><br><span class="line">                maxCol = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大值: %d\n&quot;</span>, maxValue);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;对应的行索引: %d\n&quot;</span>, maxRow);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;对应的列索引: %d\n&quot;</span>, maxCol);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例3：将一个二维数组行和列的元素互换，存到另一个二维数组中。</p><p><img src="/img/images/image-20230527130139301.png" alt="image-20230527130139301"></p><blockquote><p><code>a[i][j] ---&gt; b[j][i]</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROWS 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLS 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[ROWS][COLS] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                         &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> b[COLS][ROWS];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组 a:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROWS; i++) &#123; <span class="comment">//处理a数组中的一行中各元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COLS; j++) &#123; <span class="comment">//处理a数组中某一列中各元素</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, a[i][j]); <span class="comment">//输出a数组的一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROWS; i++) &#123; <span class="comment">//处理a数组中的一行中各元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COLS; j++) &#123; <span class="comment">//处理a数组中某一列中各元素</span></span><br><span class="line">            b[j][i] = a[i][j]; <span class="comment">//将a数组元素的值赋给b数组相应元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组 b:\n&quot;</span>); <span class="comment">//输出b数组各元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; COLS; i++) &#123; <span class="comment">//处理b数组中一行中各元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ROWS; j++) <span class="comment">//处理b数组中一列中各元素</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, b[i][j]); <span class="comment">//输出b数组的一个元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p> <img src="/img/images/image-20230829235059731.png" alt="image-20230829235059731" style="zoom: 80%;" /><p>举例4：二维char型数组</p><p>将”Apple”、”Orange”、”Grape”、”Pear”、”Peach”存储在数组中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> fruit[][<span class="number">7</span>]=&#123;<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Orange&quot;</span>,<span class="string">&quot;Grape&quot;</span>,<span class="string">&quot;Pear&quot;</span>,<span class="string">&quot;Peach&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>对应图示：</p><p><img src="/img/images/image-20230818154347419.png" alt="image-20230818154347419"></p><p>举例5：使用二维数组打印一个 10 行杨辉三角。</p><p>提示：</p><ol><li><p>第一行有 1 个元素, 第 n 行有 n 个元素</p></li><li><p>每一行的第一个元素和最后一个元素都是 1</p></li><li><p>从第三行开始, 对于非第一个元素和最后一个元素的元素。即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j];</span><br></pre></td></tr></table></figure></li></ol><p><img src="/img/images/image-20220317005549522.png" alt="image-20220317005549522"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROWS 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> yangHui[ROWS][ROWS];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROWS; i++) &#123;</span><br><span class="line">        <span class="comment">//初始化第一列和对角线上的元素为1</span></span><br><span class="line">        yangHui[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        yangHui[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//给其他位置元素赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            yangHui[i][j] = yangHui[i - <span class="number">1</span>][j - <span class="number">1</span>] + yangHui[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印杨辉三角</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROWS; i++) &#123;</span><br><span class="line">        <span class="comment">// 打印每行的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d &quot;</span>, yangHui[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第05章-指针"><a href="#第05章-指针" class="headerlink" title="第05章_指针"></a>第05章_指针</h1><p>指针是 C 语言<code>最重要</code>的概念之一，也是最<code>难理解</code>的概念之一。</p><p>指针是C语言的<code>精髓</code>，要想掌握C语言就需要深入地了解指针。</p><p>指针类型在考研中用得最多的地方，就是和结构体结合起来<code>构造结点</code>(如链表的结点、二叉树的结点等)。</p><h2 id="本章专题脉络-4"><a href="#本章专题脉络-4" class="headerlink" title="本章专题脉络"></a>本章专题脉络</h2><p><img src="/img/images/%E7%AC%AC5%E7%AB%A0_%E6%8C%87%E9%92%88.png" alt="第5章_指针"></p><h2 id="1、指针的理解与定义"><a href="#1、指针的理解与定义" class="headerlink" title="1、指针的理解与定义"></a>1、指针的理解与定义</h2><h3 id="1-1-变量的访问方式"><a href="#1-1-变量的访问方式" class="headerlink" title="1.1 变量的访问方式"></a>1.1 变量的访问方式</h3><p>计算机中程序的运行都是在内存中进行的，变量也是在内存中分配的空间，且不同类型的变量占用不同大小的空间。那如何访问内存中变量存储的数据呢？有两种方式：<code>直接访问</code>和<code>间接访问</code>。直接访问，直接使用变量名进行的访问，以前的程序中都是采用这种方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> num3 = num1 + num2;</span><br></pre></td></tr></table></figure><p>间接访问，通过指针来实现。下面看如何理解指针。</p><h3 id="1-2-内存地址与指针"><a href="#1-2-内存地址与指针" class="headerlink" title="1.2 内存地址与指针"></a>1.2 内存地址与指针</h3><p>为了能够有效的访问到内存的每个单元(即一个字节)，就给内存单元进行了编号，这些编号被称为该<strong>内存单元的地址</strong>。因为每个内存单元都有地址，所以变量存储的数据也是有地址的。</p><p><img src="/img/images/image-20230809113257075.png" alt="image-20230809113257075"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20230808160923041.png" alt="image-20230808160923041"></p><p>通过地址能找到所需的变量单元，可以说，<strong>地址指向该变量单元</strong>，将<strong>地址形象化地称为“指针”</strong>。即：</p><ul><li><p><code>变量</code>：命名的内存空间，用于存放各种类型的数据。</p></li><li><p><code>变量名</code>：变量名是给内存空间取的一个容易记忆的名字。</p></li><li><p><code>变量值</code>：在变量单元中存放的数据值。</p></li><li><p><code>变量的地址</code>：变量所使用的内存空间的地址，即<code>指针</code>。</p></li></ul><p><img src="/img/images/image-20230808155204785.png" alt="image-20230808155204785"></p><ul><li><code>指针变量</code>：一个变量专门用来存放另一变量在内存中数据的地址 (即指针)，则它称为“指针变量”。我们可以通过访问指针变量达到访问内存中另一个变量数据的目的。(有时为了阐述方便，将指针变量直接说成指针。)</li></ul><p><img src="/img/images/image-20230808160942652.png" alt="image-20230808160942652"></p><p>上图中，地址0x00000001是变量 i 的指针，i_pointer就是一个指针变量。</p><blockquote><p>体会：指针就是内存地址，使用指针访问变量，就是直接对内存地址中的数据进行操作。</p></blockquote><h3 id="1-3-指针变量的定义"><a href="#1-3-指针变量的定义" class="headerlink" title="1.3 指针变量的定义"></a>1.3 指针变量的定义</h3><p><strong>一般格式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 *指针变量名 [=初始地址值];</span><br></pre></td></tr></table></figure><ul><li><p>数据类型是指针变量所指向变量数据类型。可以是 int、char、float 等基本类型，也可以是数组等构造类型。</p></li><li><p>字符 <code>*</code> 用于告知系统这里定义的是一个指针变量，通常跟在类型关键字的后面。比如， char * 表示一个指向字符的指针， float * 表示一个指向 float 类型的值的指针。此外，还有指向数组的指针、指向结构体的指针。</p></li></ul><p><strong>举例1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;  <span class="comment">//读作：指向int的指针”或简称“int指针”</span></span><br></pre></td></tr></table></figure><p>这是一个指针变量，用于存储int型的整数在内存空间中数据的地址。</p><p>变形写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line"><span class="type">int</span> * p;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>1、指针变量的名字是 p，不是*p。</p><p>2、指针变量中只能存放地址，不要将一个整数（或任何其它非地址类型的数据）赋给一个指针变量。</p></blockquote><p>举例2：同一行声明两个指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="type">int</span> * a, * b;</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="type">int</span>* a, b;   <span class="comment">//此时a是整数指针变量，而b是整数变量</span></span><br></pre></td></tr></table></figure><p>举例3：一个指针指向的可能还是指针，这时就要用两个星号 ** 表示。(后面讲)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **foo;</span><br></pre></td></tr></table></figure><h3 id="1-4-指针的应用场景"><a href="#1-4-指针的应用场景" class="headerlink" title="1.4 指针的应用场景"></a>1.4 指针的应用场景</h3><p>场景1：使用指针访问变量或数组的元素。</p><p>场景2：应用在数据结构中。比如：</p><p><img src="/img/images/image-20230809115315139.png" alt="image-20230809115315139"></p><h2 id="2、指针的运算"><a href="#2、指针的运算" class="headerlink" title="2、指针的运算"></a>2、指针的运算</h2><p>指针作为一种特殊的数据类型可以参与运算，但与其他数据类型不同的是，指针的运算都是针对内存中的地址来实现的。</p><h3 id="2-1-取址运算符："><a href="#2-1-取址运算符：" class="headerlink" title="2.1 取址运算符：&amp;"></a>2.1 取址运算符：&amp;</h3><p>取址运算符，使用“<code>&amp;</code>”符号来表示。作用：<code>取出指定变量在内存中的地址</code>，其语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;变量</span><br></pre></td></tr></table></figure><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num); <span class="comment">// 输出变量的值。 num = 10</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;num = %p\n&quot;</span>, &amp;num); <span class="comment">// 输出变量的内存地址。&amp;num = 00000050593ffbbc</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：</p><p>1、在输出取址运算获得的地址时，需要使用“%p”作为格式输出符。</p><p>2、这里num的4个字节，每个字节都有地址，取出的是第一个字节的地址（较小的地址）。</p></blockquote><p>举例2：将变量的地址赋值给指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p; <span class="comment">//p为一个整型指针变量</span></span><br><span class="line">p = &amp;num; </span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20230808161218566.png" alt="image-20230808161218566"></p><p>举例3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *e, *f;</span><br><span class="line">e = &amp;d;</span><br><span class="line">f = e;</span><br></pre></td></tr></table></figure><p><strong>指针变量的赋值</strong></p><p>1、指针变量中只能存放地址（指针），不要将一个整数（或任何其它非地址类型的数据）赋给一个指针变量。</p><p>2、C语言中的地址包括位置信息(内存编号，或称纯地址)和它所指向的数据的类型信息，即它是“<code>带类型的地址</code>”。所以，一个指针变量只能指向同一个类型的变量，不能抛开类型随意赋值。</p><ul><li>char* 类型的指针是为了存放 char 类型变量的地址。</li><li>short* 类型的指针是为了存放 short 类型变量的地址。</li><li>int* 类型的指针是为了存放 int 类型变量的地址。</li></ul><p>3、在没有对指针变量赋值时，指针变量的值是不确定的，可能系统会分配一个未知的地址，此时使用此指针变量可能会导致不可预料的后果甚至是系统崩溃。为了避免这个问题，通常给指针变量赋初始值为0(或NULL)，并把值为0的指针变量称为<code>空指针变量</code>。</p><p>举例4：通过指针变量修改指向的内存中的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>, *ptr;</span><br><span class="line">    ptr = &amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, ptr); <span class="comment">//等价于scanf(&quot;%d&quot;, &amp;num);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img/images/image-20230809114210755.png" alt="image-20230809114210755" style="zoom: 67%;" /><h3 id="2-2-取值运算符："><a href="#2-2-取值运算符：" class="headerlink" title="2.2 取值运算符：*"></a>2.2 取值运算符：*</h3><p>在C语言中针对指针运算还提供了一个取值运算符，使用“<code>*</code>”符号表示。其<code>作用与&amp;相反</code>，根据一个给定的内存地址取出该地址对应变量的值。也称为<code>解引用符号</code>。其格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*指针表达式</span><br></pre></td></tr></table></figure><p>其中，“<code>*</code>”不同于定义指针变量的符号，这里是运算符。“指针表达式”用于得到一个内存地址，与“*”结合以获得该内存地址对应变量的值。</p><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">2024</span>;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = &amp;a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a); <span class="comment">//0000005cc43ff6d4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p);  <span class="comment">//0000005cc43ff6d4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p); <span class="comment">//2024</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>; <span class="comment">//这里定义一个整型变量num</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num); <span class="comment">//输出变量num的值。输出：num = 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;num = %p\n&quot;</span>, &amp;num); <span class="comment">//输出变量num的地址。输出：&amp;num = 000000e6a11ffa1c</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> *p = &amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p); <span class="comment">//000000e6a11ffa1c</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);<span class="comment">//10</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*&amp;num = %d\n&quot;</span>, *&amp;num);<span class="comment">//通过num地址读取num中的数据。输出：*&amp;num = 10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>&amp;</code> 运算符与 <code>*</code> 运算符互为逆运算，下面的表达式总是成立：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (i == *(&amp;i)) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></blockquote><p>举例3：通过指针变量修改指向内存地址位置上的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;num;</span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>,num);  <span class="comment">//num = 20</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    <span class="type">char</span>* pc = &amp;ch;</span><br><span class="line">    *pc = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>, ch); <span class="comment">//ch = &#x27;s&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20230808181707841.png" alt="image-20230808181707841"></p><p>举例4：</p><p>定义指针变量 p1、p2，默认各自指向整数a、b，a、b从键盘输入。设计程序，使得 p1 指向其中的较大值，p2 指向其中的较小值 。</p><p><img src="/img/images/image-20230831093326127.png" alt="image-20230831093326127"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p1, *p2, *p, a, b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入两个整数: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    p1 = &amp;a;</span><br><span class="line">    p2 = &amp;b;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        p = p1;</span><br><span class="line">        p1 = p2;</span><br><span class="line">        p2 = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输出p1、p2: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, *p1, *p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例5：已有代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure><p>请看问题：</p><p>问题1：<code>&amp;*p</code>的含义是什么?</p><ul><li><code>“&amp;”</code>和<code>“*”</code>两个运算符的优先级别相同，但按自右而左方向运算。因此，<code>&amp;*p</code>与<code>&amp;a</code>相同，即变量a的地址。</li><li>如果有<code>p1 = &amp;*p; </code>它的作用是将<code>&amp;a</code> (a的地址)赋给<code>p1</code> ，如果<code>p1</code>原来指向 b，经过重新赋值后它已不再指向b了，而指向了a。</li></ul><p>问题2：<code>*&amp;a</code>的含义是什么?</p><ul><li>先进行<code>&amp;a</code>运算，得a的地址，再进行<code>*</code>运算。<code>*&amp;a</code>和<code>*p</code>的作用是一样的，它们都等价于变量a。即<code>*&amp;a</code>与 a 等价。</li></ul><h3 id="2-3-指针的常用运算"><a href="#2-3-指针的常用运算" class="headerlink" title="2.3 指针的常用运算"></a>2.3 指针的常用运算</h3><p>指针本质上就是一个无符号整数，代表了内存地址。除了上面提到的取址运算外，指针还可以与整数加减、自增自减、同类指针相减运算等。但是规则并不是整数运算的规则。</p><h4 id="2-3-1-指针与整数值的加减运算"><a href="#2-3-1-指针与整数值的加减运算" class="headerlink" title="2.3.1 指针与整数值的加减运算"></a>2.3.1 指针与整数值的加减运算</h4><p>格式：<code>指针±整数</code></p><p>指针与整数值的加减运算，表示指针所指向的内存地址的移动（加，向后移动；减，向前移动）。指针移动的单位，与指针指向的数据类型有关。<strong>数据类型占据多少个字节，每单位就移动多少个字节。</strong></p><p>通过此操作，可以快速定位你要的地址。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> *s;</span><br><span class="line">s = (<span class="type">short</span> *) <span class="number">0x1234</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%hx\n&quot;</span>, s + <span class="number">1</span>); <span class="comment">//0x1236   复习：%hx ：十六进制 short int 类型</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%hx\n&quot;</span>, s - <span class="number">1</span>); <span class="comment">//0x1232</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *i;</span><br><span class="line">i = (<span class="type">int</span> *) <span class="number">0x1234</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, i + <span class="number">1</span>); <span class="comment">//0x1238    复习：%x ：十六进制整数</span></span><br></pre></td></tr></table></figure><p>说明：s + 1 表示指针向内存地址的高位移动一个单位，而一个单位的 short 类型占据两个字节的宽度，所以相当于向高位移动两个字节。</p><p>再比如：变量a、b、c、d和e都是整型数据int类型，它们在内存中占据一块连续的存储区域。指针变量p指向变量a，也就是p的值是0xFF12，则：</p><p><img src="/img/images/image-20230808164019404.png" alt="image-20230808164019404"></p><p>说明：指针p+1并不是地址+1，而是指针p指向数组中的下一个数据。比如，int *p，p+1表示当前地址+4，指向下一个整型数据。</p><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = &amp;arr[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p的地址为：%p,对应的值为%d\n&quot;</span>, p, *p); <span class="comment">//p1的地址为：000000df21bff6e4,对应的值为2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p+1=的地址为：%p,对应的值为%d\n&quot;</span>, p + <span class="number">1</span>, *(p + <span class="number">1</span>)); <span class="comment">//p1+1=的地址为：000000df21bff6e8,对应的值为3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p-1=的地址为：%p,对应的值为%d\n&quot;</span>, p - <span class="number">1</span>, *(p - <span class="number">1</span>)); <span class="comment">//p1-1=的地址为：000000df21bff6e0,对应的值为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：只有指向连续的同类型数据区域，指针加、减整数才有实际意义。</p></blockquote><p>举例2：</p><p>对于长度是 N 的一维数组 a，当使用指针 p 指向其首元素后，即可通过指针 p 访问数组的各个元素。</p><img src="/img/images/image-20230808180239442.png" alt="image-20230808180239442" style="zoom:80%;" /><p>其中：</p><ul><li><p><code>a[0]</code>用 <code>*p</code> 表示</p></li><li><p><code>a[1]</code>用<code>*(p+1)</code>表示</p></li><li><p><code>a[i]</code>用<code>*(p+i)</code>表示</p></li></ul><p>遍历数组操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[LENGTH] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式1：传统直接访问的方式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; LENGTH;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式2：使用指针访问</span></span><br><span class="line">    <span class="type">int</span> *p = &amp;arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; LENGTH;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(p+i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-指针的自增、自减运算"><a href="#2-3-2-指针的自增、自减运算" class="headerlink" title="2.3.2 指针的自增、自减运算"></a>2.3.2 指针的自增、自减运算</h4><p>指针类型变量也可以进行自增或自减运算，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p++ 、 p-- 、 ++p 、--p</span><br></pre></td></tr></table></figure><p>++和–在运算符章节已经讲过，这里针对指针的增加或减少指的是内存地址的向前或向后移动。</p><p>针对于数组来说，由于数组在内存中是连续分布的。</p><ul><li>当对指针进行++时，指针会按照它指向的数据类型字节数大小增加，比如 int * 指针，每 ++ 一次， 就增加4个字节。</li><li>当对指针进行–时，指针会按照它指向的数据类型字节数大小减少，比如 int * 指针，每 – 一次， 就减少4个字节。</li></ul><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> *p2 = &amp;arr[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1的值为：%d\n&quot;</span>, *p1);        <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;++p1的值为：%d\n&quot;</span>, *(++p1));  <span class="comment">//2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1的值为：%d\n&quot;</span>, *p1);        <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1的地址为：%p\n&quot;</span>, p1);      <span class="comment">//00000055c0bff704</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1++的地址为：%p\n&quot;</span>, ++p1);  <span class="comment">//00000055c0bff708</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2的值为：%d\n&quot;</span>, *p2);       <span class="comment">//4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--p2的值为：%d\n&quot;</span>, *(--p2)); <span class="comment">//3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2的值为：%d\n&quot;</span>, *p2);       <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：请分析下面几种情况。</p><p>初始情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br></pre></td></tr></table></figure><p>情况1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = a;  <span class="comment">//p开始时指向数组a的首元素    等同于 int *p = &amp;a[0];</span></span><br><span class="line"></span><br><span class="line">p++; <span class="comment">//使p指向下一元素a[1]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p); <span class="comment">//得到下一个元素a[1]的值，即20</span></span><br></pre></td></tr></table></figure><p>情况2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = a;  <span class="comment">//p开始时指向数组a的首元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p++); <span class="comment">//10   分析：由于++和*同优先级，结合方向自右而左，因此它等价于*(p++)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);   <span class="comment">//20</span></span><br></pre></td></tr></table></figure><p>拓展：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(p++); <span class="comment">//先取*p值，然后使p自增1</span></span><br><span class="line">*(++p); <span class="comment">//先使p自增1，再取*p</span></span><br></pre></td></tr></table></figure><p>拓展：如果 p 当前指向 a 数组中第 i 个元素a[i]，则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*(p--) <span class="comment">//相当于a[i--]，先对p进行“*”运算，再使p自减</span></span><br><span class="line">*(++p) <span class="comment">//相当于a[++i]，先使p自加，再进行“*”运算</span></span><br><span class="line">*(--p) <span class="comment">//相当于a[--i]，先使p自减，再进行“*”运算</span></span><br></pre></td></tr></table></figure><p>情况3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;a[<span class="number">2</span>];  <span class="comment">//p开始时指向数组a的第3个元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(p--)); <span class="comment">//30</span></span><br><span class="line">    </span><br><span class="line">p = &amp;a[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(++p)); <span class="comment">//40</span></span><br><span class="line"></span><br><span class="line">p = &amp;a[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(--p)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure><p>情况3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = a;            <span class="comment">//p开始时指向数组a的首元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,++(*p)); <span class="comment">//11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：表示p所指向的元素值加1，如果p=a, 则相当于++a[0]，若a[0]的值为10，则a[0]的值为11。</span></span><br><span class="line"><span class="comment">注意: 是元素a[0]的值加1，而不是指针p的值加1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="2-3-3-同类指针相减运算"><a href="#2-3-3-同类指针相减运算" class="headerlink" title="2.3.3 同类指针相减运算"></a>2.3.3 同类指针相减运算</h4><p>格式：<code>指针 - 指针</code></p><p>相同类型的指针允许进行减法运算，返回它们之间的距离，即<code>相隔多少个数据单位（注意：非字节数）</code>。高位地址减去低位地址，返回的是正值；低位地址减去高位地址，返回的是负值。</p><p>返回的值属于 <code>ptrdiff_t</code> 类型，这是一个带符号的整数类型别名，具体类型根据系统不同而不同。这个类型的原型定义在头文件 stddef.h 里面。</p><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> *ps1;</span><br><span class="line">    <span class="type">short</span> *ps2;</span><br><span class="line">    ps1 = (<span class="type">short</span> *) <span class="number">0x1234</span>;</span><br><span class="line">    ps2 = (<span class="type">short</span> *) <span class="number">0x1236</span>;</span><br><span class="line">    <span class="type">ptrdiff_t</span> dist = ps2 - ps1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist); <span class="comment">// 1   相差2个字节正好存放1个 short 类型的值。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *pi1;</span><br><span class="line">    <span class="type">int</span> *pi2;</span><br><span class="line"></span><br><span class="line">    pi1 = (<span class="type">int</span> *) <span class="number">0x1234</span>;</span><br><span class="line">    pi2 = (<span class="type">int</span> *) <span class="number">0x1244</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ptrdiff_t</span> dist1 = pi2 - pi1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist1);  <span class="comment">//4   相差16个字节正好存放4个 int 类型的值。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> *p2 = &amp;arr[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1的地址为：%d\n&quot;</span>, p1); <span class="comment">//497022544</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2的地址为：%d\n&quot;</span>, p2); <span class="comment">//497022556</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2-p1=%d\n&quot;</span>, p2 - p1); <span class="comment">//3 等同于 (497022556 - 497022544)/4 ==&gt; 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img/images/image-20230808200939114.png" alt="image-20230808200939114" style="zoom:80%;" /><blockquote><p>体会：两个指针相减，通常两个指针都是指向同一数组中的元素才有意义。结果是两个地址之差除以数组元素的长度。不相干的两个变量的地址，通常没有做减法的必要。</p></blockquote><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;i;</span><br><span class="line">    <span class="type">int</span> *p2 = &amp;j;</span><br><span class="line"></span><br><span class="line">    <span class="type">ptrdiff_t</span> dist = p1 - p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist);   <span class="comment">//通常没有计算减法的必要</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非法：同类指针相加运算</strong></p><p>两个指针进行加法是<code>非法的</code>，所得结果是没有意义的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>,j = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *p1 = &amp;i;</span><br><span class="line"><span class="type">int</span> *p2 = &amp;j;</span><br><span class="line"><span class="type">int</span> *p3 = p1 + p2; <span class="comment">//非法</span></span><br></pre></td></tr></table></figure><h4 id="2-3-4-指针间的比较运算"><a href="#2-3-4-指针间的比较运算" class="headerlink" title="2.3.4 指针间的比较运算"></a>2.3.4 指针间的比较运算</h4><p>指针之间的比较运算，比如 &#x3D;&#x3D;、!&#x3D; 、&lt;、 &lt;&#x3D; 、 &gt;、 &gt;&#x3D;。比较的是各自的内存地址的大小，返回值是整数 1 （true）或 0 （false）。</p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p1 = &amp;arr[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> *p2 = &amp;arr[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p1 &gt; p2);  <span class="comment">//0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p1 &lt; p2);  <span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p1 == p2); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p1 != p2); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>练习：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    ptr = arr;  <span class="comment">//ptr指向arr首地址(第一个元素)</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == arr[<span class="number">0</span>]) &#123; <span class="comment">//错误,类型不一样</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ok1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr == &amp;arr[<span class="number">0</span>]) &#123; <span class="comment">// 可以</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ok2\n&quot;</span>); <span class="comment">//输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr == arr) &#123; <span class="comment">//可以</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ok3\n&quot;</span>); <span class="comment">//输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr &gt;= &amp;arr[<span class="number">1</span>]) &#123; <span class="comment">//可以比较,但是返回false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ok4\n&quot;</span>);<span class="comment">//不会输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr &lt; &amp;arr[<span class="number">1</span>]) &#123; <span class="comment">//可以比较,返回true</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ok5\n&quot;</span>);<span class="comment">//输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【华南理工大学2018研】若有说明：int *p，m＝5，n；，以下正确的程序段是（　　）。<br>A．</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p=&amp;n;  </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,n); </span><br></pre></td></tr></table></figure><p>B．</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p=&amp;n;  </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,*p); </span><br></pre></td></tr></table></figure><p>C．</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);  </span><br><span class="line">p=n </span><br></pre></td></tr></table></figure><p>D．</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p=&amp;n;  </span><br><span class="line">*p=n; </span><br></pre></td></tr></table></figure><p>【答案】D</p><p>【解析】scanf语句中第二个参数应该是变量的地址，AB错误；C中p为指针变量，不可以直接把一个int型变量赋值给指针型，C错误；答案选D。</p></blockquote><blockquote><p> 【华南理工大学2018研】若有定义：int *p，*s，c；，且各变量已正确赋值，则非法的赋值表达式是（　）。<br> A．p＝s<br> B．c＝*s<br> C．*s＝&amp;p<br> D．p＝&amp;c</p><p> 【答案】C</p><p> 【解析】C中p为指针变量，则&amp;p表示的是指针的地址，若要赋值，则左边变量应该是一个二级指针，而*s代表的是s所指向地址的变量值，这个变量是一个int型，显然不正确。</p></blockquote><blockquote><p>【中央财经大学2018研】有如下说明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;, *p=a;</span><br></pre></td></tr></table></figure><p>则数值为9的表达式是（　　）。<br>A．*p＋9<br>B．*(p＋8)<br>C．*p +&#x3D; 9<br>D．p＋8</p><p>【答案】B</p><p>【解析】A中*p＝1，*p＋9＝10，A错误。C中*p得到的是1，加9后结果是10，C错误。D中p是地址，p＋8仍然表示一个地址。因此B项正确，p＋8指向元素9，进行取值得9。</p></blockquote><h2 id="3、野指针"><a href="#3、野指针" class="headerlink" title="3、野指针"></a>3、野指针</h2><h3 id="3-1-什么是野指针"><a href="#3-1-什么是野指针" class="headerlink" title="3.1 什么是野指针"></a>3.1 什么是野指针</h3><p>野指针：就是指针指向的位置是不可知（<code>随机性</code>，<code>不正确</code>，<code>没有明确限制的</code>）。</p><h3 id="3-2-野指针的成因"><a href="#3-2-野指针的成因" class="headerlink" title="3.2 野指针的成因"></a>3.2 野指针的成因</h3><h4 id="①-指针使用前未初始化"><a href="#①-指针使用前未初始化" class="headerlink" title="① 指针使用前未初始化"></a>① 指针使用前未初始化</h4><p>指针变量在定义时如果未初始化，<code>其值是随机的</code>，此时操作指针就是去访问一个不确定的地址，所以结果是不可知的。此时p就为野指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有给指针变量显式初始化的情况下，一系列的操作(包括修改指向内存的数据的值)也是错误的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span>* p;                       </span><br><span class="line">*p = <span class="number">10</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展：注意如下的赋值操作也是错误的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-指针越界访问"><a href="#②-指针越界访问" class="headerlink" title="② 指针越界访问"></a>② 指针越界访问</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++,p++) &#123;</span><br><span class="line">        *p = i;                   <span class="comment">//i=10时越界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20230808182041120.png" alt="image-20230808182041120"></p><p>当i&#x3D;10时，此时<code>*p</code>访问的内存空间不在数组有效范围内，此时<code>*p</code>就属于非法访问内存空间，p为野指针。</p><h4 id="③-指针指向已释放的空间"><a href="#③-指针指向已释放的空间" class="headerlink" title="③ 指针指向已释放的空间"></a>③ 指针指向已释放的空间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;          <span class="comment">//&amp;a=0x0012ff40</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *p = test();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用test函数将返回值赋给p，test函数的返回值是局部变量a的地址。由于a只在test函数内有效，出了test函数其内存空间就被释放，也就意味着<code>a的地址编号不存在</code>，若将其赋值给p，导致p获取到的地址是<code>无效</code>的。</p><p>如果短时间内再次利用这块地址，它的值还未被改变也就是0x0012ff40还存在，p的值为0x0012ff40，*p时还是10，可以打印出。</p><p>但如果在打印之前有其他函数调用了这块地址，这块地址的名称就会发生变化，不再是0x0012ff40，打印*p时不再为10。</p><p>总之，此时p为野指针。</p><h3 id="3-3-野指针的避免"><a href="#3-3-野指针的避免" class="headerlink" title="3.3 野指针的避免"></a>3.3 野指针的避免</h3><p><strong>1、指针初始化</strong></p><p>定义指针的时候，如果没有确切的地址赋值，为指针变量赋一个 NULL 值是好的编程习惯。即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><blockquote><p>赋为 NULL 值的指针被称为<code>空指针</code>，NULL 指针是一个定义在标准库 &lt;stdio.h&gt;中的值为零的常量 <strong>#define NULL 0</strong></p></blockquote><p>后面如果用到指针的话再让指针指向具有实际意义的地址，然后通过指针的取值符号(*)改变其指向的内容。</p><p>练习：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//空指针不要与未初始化的指针混淆</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line">    p = &amp;b;   <span class="comment">//显式赋值</span></span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);  <span class="comment">//100</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\b&quot;</span>, b);   <span class="comment">//100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、小心指针越界</strong></p><p><strong>3、避免返回局部变量的地址</strong></p><p><strong>4、指针指向空间释放，及时置NULL</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* pa = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *pa);</span><br><span class="line"> </span><br><span class="line">pa = <span class="literal">NULL</span>;<span class="comment">//把pa指针置成NULL</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,pa);</span><br></pre></td></tr></table></figure><p><strong>5、指针使用之前检查有效性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pa != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="comment">//进行使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pa == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="comment">//不进行使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、二级指针-多重指针"><a href="#4、二级指针-多重指针" class="headerlink" title="4、二级指针(多重指针)"></a>4、二级指针(多重指针)</h2><p>一个指针p1记录一个变量的地址。由于指针p1也是变量，自然也有地址，那么p1变量的地址可以用另一个指针p2来记录。则p2就称为<code>二级指针</code>。</p><p>简单来说，二级指针即一个指针变量的值是另外一个指针变量的地址。通俗来说，二级指针就是指向指针的指针。</p><p><strong>格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 **指针名;</span><br></pre></td></tr></table></figure><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *pa = &amp;a;  <span class="comment">//pa是一级指针</span></span><br><span class="line"><span class="type">int</span> **ppa = &amp;pa; <span class="comment">//ppa是二级指针，类型为int **</span></span><br></pre></td></tr></table></figure><img src="/img/images/image-20230808183554248.png" alt="image-20230808183554248" style="zoom:80%;" /><blockquote><p>进而推理，会有int ***pppa &#x3D; &ppa; 等情况，但这些情况一般不会遇到。</p></blockquote><p>在上述代码基础上，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">ppa = &amp;b; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>将 ppa（类型为 <code>int **</code>，即二级指针）赋值为 &amp;b，但 &amp;b是一个 <code>int *</code> 类型的指针，而不是 <code>int **</code> 类型。这会导致类型不匹配的错误。</p><p>如果您想要将 ppa 指向 b，可以找一个额外的一级指针作为中介。如下操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *pb = &amp;b;     <span class="comment">// 使用一级指针来指向b</span></span><br><span class="line">ppa = &amp;pb;        <span class="comment">// 将ppa指向pb的地址，ppa是二级指针</span></span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">3000</span>;</span><br><span class="line">    <span class="type">int</span> *ptr = &amp;var;        <span class="comment">// 一级指针指向 var</span></span><br><span class="line">    <span class="type">int</span> **pptr = &amp;ptr;      <span class="comment">// 二级指针指向 ptr</span></span><br><span class="line">    <span class="type">int</span> ***ppptr = &amp;pptr;   <span class="comment">// 三级指针指向 pptr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value of var: %d\n&quot;</span>, var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value of ptr: %d\n&quot;</span>, *ptr);         <span class="comment">// 解引用一次</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value of pptr: %d\n&quot;</span>, **pptr);      <span class="comment">// 解引用两次</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value of ppptr: %d\n&quot;</span>, ***ppptr);   <span class="comment">// 解引用三次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img/images/image-20230831185356677.png" alt="image-20230831185356677" style="zoom: 50%;" /><p>举例3：使用malloc()函数创建二维数组</p><p>malloc()函数用于动态分配堆内存，free()函数用于释放堆内存。这两个函数通常都是配合一起使用的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> rows, cols;<span class="comment">// 定义二维数组的行和列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一维为：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;rows);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第二维为：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cols);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> **<span class="built_in">array</span> = (<span class="type">int</span> **) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *) * rows);<span class="comment">//先创建第一维</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="comment">//在内层循环中动态创建第二维</span></span><br><span class="line">        <span class="built_in">array</span>[i] = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * cols);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="built_in">array</span>[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d　&quot;</span>, <span class="built_in">array</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、专题：指针与数组"><a href="#5、专题：指针与数组" class="headerlink" title="5、专题：指针与数组"></a>5、专题：指针与数组</h2><p>复习：</p><img src="/img/images/image-20230809114210755.png" alt="image-20230809114210755" style="zoom: 67%;" /><img src="/img/images/image-20230901173513831.png" alt="image-20230901173513831" style="zoom:67%;" /><ul><li>“<code>*</code>“，也称为解引用符号，其<code>作用与&amp;相反</code>。</li><li>“<code>*</code>“，后面只能跟指针(即地址)或指针变量，”<code>&amp;</code>“后面跟的是普通变量(包括指针变量)。</li></ul><h3 id="5-1-一维数组与指针"><a href="#5-1-一维数组与指针" class="headerlink" title="5.1 一维数组与指针"></a>5.1 一维数组与指针</h3><h4 id="5-1-1-指向一维数组的指针变量"><a href="#5-1-1-指向一维数组的指针变量" class="headerlink" title="5.1.1 指向一维数组的指针变量"></a>5.1.1 指向一维数组的指针变量</h4><p>所谓<code>数组元素的指针就是数组元素的地址</code>。可以用一个指针变量指向一个数组元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>&#125;; </span><br><span class="line"><span class="type">int</span> *p; <span class="comment">//定义p为指向整型变量的指针变量</span></span><br><span class="line">p = &amp;a[<span class="number">0</span>]; <span class="comment">//把a[0]元素的地址赋给指针变量p</span></span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20230808164241559.png" alt="image-20230808164241559"></p><p>如下几个写法是等价的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a[<span class="number">0</span>];  <span class="comment">//千万不要写成*p = &amp;a[0];，那就错了</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = a; <span class="comment">//a不代表整个数组，所以这里不是将数组a赋给p。而代表数组元素a[0]的首地址。</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>因为数组名a保存的是<code>数组首元素a[0]的地址</code>，所以在scanf函数中的输入项如果是数组名，<code>不要再加地址符&amp;</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, arr);  <span class="comment">//arr前不应加 &amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-2-使用指针访问数组的元素"><a href="#5-1-2-使用指针访问数组的元素" class="headerlink" title="5.1.2 使用指针访问数组的元素"></a>5.1.2 使用指针访问数组的元素</h4><p>如果指针变量p的初值为<code>&amp;a[0]</code>，则：</p><ul><li><p><code>p+i</code>和<code>a+i</code>就是数组元素<code>a[i]</code>的地址。或者说，它们指向a数组序号为i的元素。</p></li><li><p><code>*(p+i)</code>或<code>*(a+i)</code>是<code>p+i</code>或<code>a+i</code>所指向的数组元素的值，即a[i]的值。</p></li></ul><img src="/img/images/image-20230808165619039.png" alt="image-20230808165619039" style="zoom:80%;" /><p>举例1：数组元素赋值、遍历</p><p>方式1：下标法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个整数：\n&quot;</span>,N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]); <span class="comment">//数组元素用数组名和下标表示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个整数：\n&quot;</span>,N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]); <span class="comment">//数组元素用数组名和下标表示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a + i));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式3：使用指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[N];</span><br><span class="line">    <span class="type">int</span> *p = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个整数：\n&quot;</span>, N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p + i));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[N];</span><br><span class="line">    <span class="type">int</span> *p = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个整数：\n&quot;</span>, N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = a; p &lt; (a + N); p++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第(1)和第(2)种方法执行效率是相同的。C编译系统是将a[i]转换为*(a+i)处理的，即先计算元素地址。因此用第(1)和第(2)种方法找数组元素<code>费时较多</code>。</p><p>第(3)种方法比第(1)、第(2)种方法快，用指针变量直接指向元素，不必每次都重新计算地址，像p++这样的自加操作是比较快的。这种有规律地改变地址值(p++)能大大<code>提高执行效率</code>。但第(1)方法比较直观，适合初学者。</p></blockquote><p><strong>思 考：</strong></p><p>可以通过改变指针变量p的值指向不同的元素。如果不用p变化的方法而用数组名a变化的方法（例如，用a++）行不行呢？ （不行）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(p = a;a &lt; (p + N);a++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*a);</span><br></pre></td></tr></table></figure><p>因为数组名a代表数组的首地址（或数组首元素的地址），它是一个指针型<code>常量</code>，它的值在程序运行期间是固定不变的。所以a++是无法实现的。必须将 a 的地址赋值给指针变量 p ，然后对 p 进行自增。</p><p>举例2：获取数组的最大值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[N];</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个数据：\n&quot;</span>, N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p + i);</span><br><span class="line">    <span class="comment">//获取最大值</span></span><br><span class="line">    <span class="type">int</span> max = *p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">if</span> (max &lt; *(p + i))</span><br><span class="line">            max = *(p + i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max: %d\n&quot;</span>, max);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-3-指针带下标的使用"><a href="#5-1-3-指针带下标的使用" class="headerlink" title="5.1.3 指针带下标的使用"></a>5.1.3 指针带下标的使用</h4><p>指向数组元素的指针变量也可以带下标，如<code>p[i]</code>。p[i]被处理成<code>*(p+i)</code>，如果p是指向一个整型数组元素a[0]，则p[i]代表a[i]。但是必须弄清楚p的当前值是什么？<strong>如果当前p指向a[3]，则p[2]并不代表a[2]，而是a[3+2]，即a[5]。</strong></p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历数组元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    p++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p[<span class="number">0</span>]); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-4-数组名"><a href="#5-1-4-数组名" class="headerlink" title="5.1.4 &amp;数组名"></a>5.1.4 &amp;数组名</h4><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复习</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = arr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p);  <span class="comment">//000000000034fa50</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;p); <span class="comment">//000000000037fbd8</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20230831171558898.png" alt="image-20230831171558898"></p><p>进一步思考：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr);  <span class="comment">//000000000034fa50</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr); <span class="comment">//000000000034fa50</span></span><br></pre></td></tr></table></figure><p>发现，<code>数组名</code> 和 <code>&amp;数组名</code> 打印的地址是一样的。</p><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr = %p\n&quot;</span>, arr);        <span class="comment">//000000cade5ff750</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr= %p\n&quot;</span>, &amp;arr);       <span class="comment">//000000cade5ff750</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr+1 = %p\n&quot;</span>, arr + <span class="number">1</span>);    <span class="comment">//000000cade5ff754</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr+1= %p\n&quot;</span>, &amp;arr + <span class="number">1</span>);   <span class="comment">//000000cade5ff764</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp;arr 理解为<code>数组的地址</code>，而不要理解为数组首元素a[0]的地址。</p><p>本例中 &amp;arr 的类型是： int(*)[5] ，是一种数组指针类型。数组的地址+1，跳过整个数组的大小，所以 &amp;arr+1 相对于 &amp;arr 的差值是20。</p><blockquote><p>【北京航空航天大学2018研】若有以下变量的声明语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>,a[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>&#125;, *b;</span><br><span class="line">b = &amp;i;</span><br></pre></td></tr></table></figure><p>则下列选项中，其结果与表达式“*(a＋1)”相等的是（　）。<br>A．a[0]<br>B．*a＋i<br>C．*(a＋b)<br>D．*(a＋*b)</p><p>【答案】D</p><p>【解析】a指向数组的首元素，因此*(a＋1) 表示取数组第二个元素的值，为2。A项，a[0]＝0，不相等；B项，*a为数组第一个元素的值为0，再加上i＝1，因此结果为1，不相等；C项，a和b都是指针，相加没有意义，错误；D项，*b的值i的值，即1，*(a＋1) 表示取数组第二个元素的值为2，相等，因此答案选D。</p></blockquote><h3 id="5-2-二维数组与指针"><a href="#5-2-二维数组与指针" class="headerlink" title="5.2 二维数组与指针"></a>5.2 二维数组与指针</h3><h4 id="5-2-1-使用数组名访问"><a href="#5-2-1-使用数组名访问" class="headerlink" title="5.2.1 使用数组名访问"></a>5.2.1 使用数组名访问</h4><p>设有一个二维数组 a 定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>&#125;,</span><br><span class="line">               &#123;<span class="number">5</span>, <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>&#125;,</span><br><span class="line">               &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>二维数组 a，可视为三个一维数组：a[0]、a[1]、a[2]；而每个一维数组又是一维数组，分别由 4 个元素组成。首先，理解如下的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[<span class="number">0</span>][<span class="number">0</span>]);  <span class="comment">//二维数组中元素a[0][0]的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">//二维数组中元素a[0][0]的值对应的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a[<span class="number">0</span>]);     <span class="comment">//二维数组中a[0][0]的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a);        <span class="comment">//二维数组中a[0]的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a);       <span class="comment">//二维数组a的地址</span></span><br></pre></td></tr></table></figure><p>对应图示</p><p><img src="/img/images/1689128732557.png" alt="1689128732557"></p><p>举例：</p><table><thead><tr><th>表示形式</th><th>含义</th><th>地址</th></tr></thead><tbody><tr><td><code>a</code></td><td>二维数组名，指向一维数组a[0]，<br>即0行起始地址</td><td>2000</td></tr><tr><td><code>&amp;a[0][0],a[0],*a </code></td><td>0行0列元素地址</td><td>2000</td></tr><tr><td><code>a[0][0],*(a[0]),**a</code></td><td>0行0列元素<code>a[0][0]</code>的值</td><td>1</td></tr><tr><td><code>&amp;a[1],a+1</code></td><td>指向索引为1行的起始地址</td><td>2016</td></tr><tr><td><code>&amp;a[1][0],a[1],*(a+1)</code></td><td>1行0列元素<code>a[1][0]</code>的地址</td><td>2016</td></tr><tr><td><code>a[1][0],*(a[1]),*(*(a+1))</code></td><td>1行0列元素<code>a[1][0]</code>的值</td><td>5</td></tr><tr><td><code>&amp;a[1][2],a[1]+2,*(a+1)+2</code></td><td>1行2列元素<code>a[1][2]</code>的地址</td><td>2024</td></tr><tr><td><code>a[1][2],*(a[1]+2),*(*(a+1)+2) </code></td><td>1行2列元素<code>a[1][2]</code>的值</td><td>是元素值，7</td></tr></tbody></table><p>总结：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&amp;a:二维数组a的地址</span><br><span class="line">a: 二维数组中a[0]的地址</span><br><span class="line">a[0]:二维数组中a[0][0]的地址</span><br><span class="line"></span><br><span class="line">讨论：a[0][0]相关的</span><br><span class="line">a[0][0]的地址：&amp;a[0][0],a[0],*a,</span><br><span class="line">a[0][0]的值： a[0][0],*(a[0]),**a,</span><br><span class="line"></span><br><span class="line">讨论：a[1]相关的</span><br><span class="line">a[1]的地址：&amp;a[1],a + 1</span><br><span class="line"></span><br><span class="line">讨论：a[1][0]相关的</span><br><span class="line">a[1][0]的地址：&amp;a[1][0],a[1],*(a+1)</span><br><span class="line">a[1][0]的值：a[1][0],*a[1],*(*(a+1))</span><br><span class="line"></span><br><span class="line">讨论：a[1][2]相关的</span><br><span class="line">a[1][2]的地址：&amp;a[1][2],a[1]+2,*(a+1)+2</span><br><span class="line">a[1][2]的值：a[1][2],*(a[1]+2),*(*(a+1)+2)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>注意：</p><p>如果 a 是二维数组，则 a[i]代表一个数组名， a[i]并不占内存单元，也不能存放a 数组元素值。它只是一个地址。所以：a、a+i、a[i]、*(a+i)、*(a+i)+j、a[i]+j 都是地址。</p></blockquote><p>获取数组元素值的三种表示形式：</p><p>1） <code>a[i][j]</code> 下标法</p><p>2） <code>*(a[i]+j)</code> 用一维数组名</p><p>3） <code>*(*(a+i)+j)</code> 用二维数组名</p><h4 id="5-2-2-使用指针变量访问"><a href="#5-2-2-使用指针变量访问" class="headerlink" title="5.2.2 使用指针变量访问"></a>5.2.2 使用指针变量访问</h4><p>设 p 是指针变量，若p 指向数组首元素，即<code>p = a[0];</code>，那<code>a[i][j]</code>的指针如何表示？</p><p>先看一个代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">10</span>, <span class="number">20</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">30</span>, <span class="number">40</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">50</span>, <span class="number">60</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = &amp;a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p);     <span class="comment">//000000f2f49ff7b0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p + <span class="number">1</span>); <span class="comment">//000000f2f49ff7b4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p + <span class="number">2</span>); <span class="comment">//000000f2f49ff7b8</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *q;</span><br><span class="line">    q = a[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, q);      <span class="comment">//000000f2f49ff7b0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, q + <span class="number">1</span>);  <span class="comment">//000000f2f49ff7b4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, q + <span class="number">2</span>);  <span class="comment">//000000f2f49ff7b8</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *r;</span><br><span class="line">    r = a;  <span class="comment">//代码片段1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, r);      <span class="comment">//000000f2f49ff7b0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, r + <span class="number">1</span>);  <span class="comment">//000000f2f49ff7b4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, r + <span class="number">2</span>);  <span class="comment">//000000f2f49ff7b8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进而：</p><ul><li><p>p+j 将指向 a[0] 数组中的元素 <code>a[0][j]</code>。</p></li><li><p>对于二维数组<code>a[M][N]</code>来讲，由于 a[0]、a[1]、… 、a[M-1]等各行数组在内存中是依次连续存储，则对于 a 数组中的任一元素 <code>a[i][j]</code>：</p><ul><li>地址表示：<code>p+i*N+j</code></li><li>值表示：<code>*(p+i*N+j)</code>、<code>p[i*N+j]</code></li></ul></li></ul><blockquote><p>注意：上述代码中，代码片段1中的赋值操作会存在类型不匹配的情况，我们在5.6节中展开说明。</p></blockquote><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">4</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;,</span><br><span class="line">               &#123;<span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125;,</span><br><span class="line">               &#123;<span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>&#125;,</span><br><span class="line">               &#123;<span class="number">100</span>, <span class="number">110</span>, <span class="number">120</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = b[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>则：元素 <code>b[1][2]</code>对应的地址&#x2F;指针、元素值为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b[1][2]对应的地址/指针为：%p\n&quot;</span>,p+<span class="number">1</span>*<span class="number">3</span>+<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b[1][2]对应的值为：%d\n&quot;</span>,*(p+<span class="number">1</span>*<span class="number">3</span>+<span class="number">2</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b[1][2]对应的值为：%d\n&quot;</span>,p[<span class="number">1</span>*<span class="number">3</span>+<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>举例2：用指针访问二维数组，求二维数组元素的最大值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROWS 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLS 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[ROWS][COLS] = &#123;&#123;<span class="number">10</span>,  <span class="number">20</span>,  <span class="number">30</span>,  <span class="number">40</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">50</span>,  <span class="number">60</span>,  <span class="number">70</span>,  <span class="number">80</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">120</span>, <span class="number">110</span>, <span class="number">100</span>, <span class="number">90</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式1：</span></span><br><span class="line"><span class="comment">//    int max = a[0][0];</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; ROWS; i++) &#123;</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; COLS; j++) &#123;</span></span><br><span class="line"><span class="comment">//            if (max &lt; a[i][j]) &#123;</span></span><br><span class="line"><span class="comment">//                max = a[i][j];</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式2：</span></span><br><span class="line">    <span class="type">int</span> *p = a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROWS; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COLS; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; *(p + i * COLS + j)) &#123;</span><br><span class="line">                max = *(p + i * COLS + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max=%d\n&quot;</span>, max);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式3：</span></span><br><span class="line">    <span class="type">int</span> *q, max1;</span><br><span class="line">    <span class="keyword">for</span> (q = a[<span class="number">0</span>], max1 = *q; q &lt; a[<span class="number">0</span>] + ROWS * COLS; q++)</span><br><span class="line">        <span class="keyword">if</span> (max1 &lt; *q)</span><br><span class="line">            max1 = *q;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max=%d\n&quot;</span>, max1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-指针数组"><a href="#5-3-指针数组" class="headerlink" title="5.3 指针数组"></a>5.3 指针数组</h3><h4 id="5-3-1-数组指针-vs-指针数组"><a href="#5-3-1-数组指针-vs-指针数组" class="headerlink" title="5.3.1 数组指针 vs 指针数组"></a>5.3.1 数组指针 vs 指针数组</h4><p><strong>数组指针：</strong></p><p>当指针变量里存放一个数组的首地址时，此指针变量称为指向数组的指针变量，简称<code>数组指针</code>。</p><p>数组指针是指针？还是数组？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答案是：指针。</span><br></pre></td></tr></table></figure><p>整型指针： int * pint; 能够指向整型数据的指针。</p><p>浮点型指针： float * pf; 能够指向浮点型数据的指针。</p><p>数组指针：能够指向数组的指针。</p><p><strong>指针数组：</strong></p><p>数组是用来存放一系列相同类型的数据，当然数组也可以用来存放指针，这种用来<code>存放指针的数组</code>被称为指针数组，它要求存放在数组中指针的<code>数据类型必须一致</code>。</p><p>问题：指针数组是指针还是数组？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答案：是数组。是存放指针的数组。</span><br></pre></td></tr></table></figure><h4 id="5-3-2-指针数组的使用"><a href="#5-3-2-指针数组的使用" class="headerlink" title="5.3.2 指针数组的使用"></a>5.3.2 指针数组的使用</h4><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 *指针数组名[大小];</span><br></pre></td></tr></table></figure><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>arr是一个数组，有5个元素，每个元素是一个整型指针，需要使用下标来区分。</p><img src="/img/images/UWYO$CLL]RR@E0K@GJYYE0.png" alt="img" style="zoom:80%;" /><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, d, e;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    c = <span class="number">3</span>;</span><br><span class="line">    d = <span class="number">4</span>;</span><br><span class="line">    e = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> *arr[] = &#123;&amp;a, &amp;b, &amp;c, &amp;d, &amp;e&#125;;<span class="comment">//定义一个int类型的指针数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> line1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;         <span class="comment">//声明数组，矩阵的第一行</span></span><br><span class="line">    <span class="type">int</span> line2[] = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;         <span class="comment">//声明数组，矩阵的第二行</span></span><br><span class="line">    <span class="type">int</span> line3[] = &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;         <span class="comment">//声明数组，矩阵的第三行</span></span><br><span class="line">    <span class="type">int</span> *p_line[<span class="number">3</span>];              <span class="comment">//声明整型指针数组</span></span><br><span class="line">    p_line[<span class="number">0</span>] = line1;           <span class="comment">//初始化指针数组元素</span></span><br><span class="line">    p_line[<span class="number">1</span>] = line2;</span><br><span class="line">    p_line[<span class="number">2</span>] = line3;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;矩阵:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;      <span class="comment">//对指针数组元素循环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;    <span class="comment">//对矩阵每一列循环</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, p_line[i][j]); <span class="comment">//或改为printf(&quot;%d\t&quot;, *(p_line[i] + j));</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p> <img src="/img/images/image-20230704214810197.png" alt="image-20230704214810197" style="zoom:80%;" /><h3 id="5-4-字符数组-vs-字符指针变量"><a href="#5-4-字符数组-vs-字符指针变量" class="headerlink" title="5.4 字符数组 vs 字符指针变量"></a>5.4 字符数组 vs 字符指针变量</h3><p>一个字符串，可以使用<code>一维字符数组</code>表示，也可以使用<code>字符指针</code>来表示。</p><ul><li>字符数组由若干个元素组成，每个元素放一个字符</li><li>字符指针变量中存放的是地址（字符串&#x2F;字符数组的首地址），绝不是将字符串放到字符指针变量中。</li></ul><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello tom&quot;</span>;  <span class="comment">//使用字符数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * pStr = <span class="string">&quot;hello tom&quot;</span>;  <span class="comment">//使用字符指针</span></span><br></pre></td></tr></table></figure><p>图示：</p><p><img src="/img/images/image-20230822114353417.png" alt="image-20230822114353417"></p><p><strong>两种方式的对比：</strong></p><p>对已声明好的字符数组，只能一一对各个元素赋值，不能用以下错误方法对字符数组赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;i&#x27;</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">&quot;hello Tom&quot;</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>对字符指针变量，采用如下方式赋值是可以的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * pStr = <span class="string">&quot;hel&quot;</span>;</span><br><span class="line"></span><br><span class="line">pStr = <span class="string">&quot;hello tom&quot;</span>; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p>图示：</p><img src="/img/images/image-20230902112911828.png" alt="image-20230902112911828" style="zoom: 67%;" /><img src="/img/images/image-20230902112925356.png" alt="image-20230902112925356" style="zoom:67%;" /><blockquote><p>一个字符数组，因为它有确定的内存地址，所以字符数组名是一个<code>常量</code>。而定义一个字符指针变量时，它在指向某个确定的字符串数据的情况下，也可以多次<code>重新赋值</code>。</p></blockquote><p>举例2：体会字符串字面量的不可变性</p><p>情况1：针对于整型数组、整型指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = arr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[<span class="number">1</span>]); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[<span class="number">1</span>]); <span class="comment">//50</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[<span class="number">1</span>]);  <span class="comment">//50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">30</span>;</span><br><span class="line">    p = &amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);    <span class="comment">//30</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p[<span class="number">0</span>]);  <span class="comment">//30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况2：针对于字符数组、字符指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> arr[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    arr[<span class="number">1</span>] = <span class="string">&quot;m&quot;</span>;    <span class="comment">//运行时错误 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为字符串字面量存储在只读内存区域，是不可变的，不能修改其值。</p><p>拓展：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *pStr = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    pStr = <span class="string">&quot;hello tom&quot;</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    pStr[<span class="number">1</span>] = <span class="string">&#x27;m&#x27;</span>;      <span class="comment">//运行时错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,pStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-字符串数组的表示"><a href="#5-5-字符串数组的表示" class="headerlink" title="5.5 字符串数组的表示"></a>5.5 字符串数组的表示</h3><p>字符串可以使用一维字符数组或字符指针变量等两种方式表示，那么字符串数组如何表示呢？</p><p>如果一个数组的每个成员都是一个字符串，则构成了字符串数组。字符串数组有两种表示方式：<code>① 二维字符数组</code> ；<code>②字符指针数组</code>。</p><p>举例1：</p><p>方式1：使用二维字符数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> fruit[][<span class="number">7</span>]=&#123;<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Orange&quot;</span>,<span class="string">&quot;Grape&quot;</span>,<span class="string">&quot;Pear&quot;</span>,<span class="string">&quot;Peach&quot;</span>&#125;;  <span class="comment">//上一章5.6节举例4</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> weekdays[<span class="number">7</span>][<span class="number">10</span>] = &#123;   <span class="comment">//行数7也可以省略</span></span><br><span class="line"><span class="string">&quot;Monday&quot;</span>,</span><br><span class="line"><span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line"><span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line"><span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line"><span class="string">&quot;Friday&quot;</span>,</span><br><span class="line"><span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line"><span class="string">&quot;Sunday&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>字符串数组，一共包含7个字符串，所以第一维的长度是7。其中，最长的字符串的长度是10（含结尾的终止符 \0 ），所以第二维的长度统一设为10。</p><p>**思考：**数组的第二维，长度统一定为10，有点浪费空间，因为大多数成员的长度都小于10。解决方法就是把数组的第二维，从字符数组改成字符指针。</p><p>方式2：使用字符指针数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* weekdays[<span class="number">7</span>] = &#123;  <span class="comment">//7也可以省略</span></span><br><span class="line">  <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的字符串数组，其实是一个一维数组，成员就是7个字符指针，每个指针指向一个字符串（字符数组）。</p><p>类似的：定义表示颜色的指针数组 colors，存储“red”、“yellow”、“blue”、“white”、“black” 5 种颜色。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *colors[<span class="number">5</span>] = &#123;<span class="string">&quot;red&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;white&quot;</span>, <span class="string">&quot;black&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>遍历字符指针数组：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, weekdays[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：</p><p>请编写程序，定义一个字符指针数组，用来存储四大名著的书名， 并通过遍历该指针数组，显示字符串信息 ， (即：定义一个指针数组，该数组的每个元素，指向的是一个字符串)</p><p>方式1：二维字符数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> books[<span class="number">4</span>][<span class="number">13</span>] = &#123;<span class="string">&quot;三国演义&quot;</span>, <span class="string">&quot;西游记&quot;</span>, <span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;水浒传&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;books[%d] : %s\n&quot;</span>,i,books[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2：字符指针数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个指针数组，该数组的每个元素，指向的是一个字符串</span></span><br><span class="line">    <span class="type">char</span> *books[] = &#123;</span><br><span class="line">            <span class="string">&quot;三国演义&quot;</span>,</span><br><span class="line">            <span class="string">&quot;西游记&quot;</span>,</span><br><span class="line">            <span class="string">&quot;红楼梦&quot;</span>,</span><br><span class="line">            <span class="string">&quot;水浒传&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;books[%d] : %s\n&quot;</span>, i, books[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-拓展：指向固定长度数组的指针变量"><a href="#5-6-拓展：指向固定长度数组的指针变量" class="headerlink" title="5.6 拓展：指向固定长度数组的指针变量"></a>5.6 拓展：指向固定长度数组的指针变量</h3><p>定义一个整型指针变量指向一维数组，一维数组的每个元素包含 m 个元素。</p><p>定义格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*标识符)[一维数组元素个数];</span><br></pre></td></tr></table></figure><p>例如：定义一个指针变量 p，它指向包含有 4 个元素的一维数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*p)[4];</span><br></pre></td></tr></table></figure><blockquote><p>说明：p先和*结合，说明p是一个指针变量，指向一个大小为4的整型数组。</p><p>注意：此时定义的是一个指针变量，并非是一个指针数组。(*p 必须放在括弧内，否则就变成了定义指针数组。)</p></blockquote><p>由于 p 是指向有 4 个整型元素的一维数组的指针变量，因此，p+1 是将地址值加上 4*4，即指向下一个一维数组。</p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>&#125;,</span><br><span class="line">               &#123;<span class="number">5</span>, <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>&#125;,</span><br><span class="line">               &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> (*q)[<span class="number">4</span>];</span><br><span class="line">q = a;</span><br></pre></td></tr></table></figure><p>则：</p><p><code>q</code> 为二维数组第 0 行首地址，与 <code>a</code> 相同；</p><p><code>q+1</code> 为二维数组第 1 行首地址，与 <code>a+1</code>相同；</p><p><code>q+2</code> 为二维数组第 2 行首地址，与 <code>a+2</code>相同；</p><p><code>*(q+i)</code>为二维数组第 i 行第 0 列元素的地址，与<code>*(a+i)</code>相同；</p><p><code>*(q+i)+j </code>为二维数组第 i 行第 j 列元素的地址，与<code>*(a+i)+j</code> 相同；</p><p><code>*(*(q+i)+j) </code>为二维数组第 i 行第 j 列元素值，与<code>*(*(a+i)+j)</code>相同，即 <code>a[i][j]</code>。</p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>&#125;,</span><br><span class="line">                     &#123;<span class="number">5</span>, <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>&#125;,</span><br><span class="line">                     &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> (*q)[<span class="number">4</span>];</span><br><span class="line">    q = arr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[0]的地址为：%p\n&quot;</span>, arr);            <span class="comment">//0000006460dffb40</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[0]的地址为：%p\n&quot;</span>, q);              <span class="comment">//0000006460dffb40</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[0][1]的地址为：%p\n&quot;</span>, *arr + <span class="number">1</span>);    <span class="comment">//0000006460dffb44</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[0][1]的地址为：%p\n&quot;</span>, *q + <span class="number">1</span>);      <span class="comment">//0000006460dffb44</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[0][1]的地址为：%p\n&quot;</span>, arr[<span class="number">0</span>] + <span class="number">1</span>);  <span class="comment">//0000006460dffb44</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[0][1]的地址为：%p\n&quot;</span>, q[<span class="number">0</span>] + <span class="number">1</span>);    <span class="comment">//0000006460dffb44</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[1]的地址为：%p\n&quot;</span>, arr + <span class="number">1</span>);       <span class="comment">//0000006460dffb50</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[1]的地址为：%p\n&quot;</span>, q + <span class="number">1</span>);         <span class="comment">//0000006460dffb50</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[1][0]的值为：%d\n&quot;</span>, *(*(arr + <span class="number">1</span>))); <span class="comment">//5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[1][0]的值为：%d\n&quot;</span>, *(*(q + <span class="number">1</span>)));   <span class="comment">//5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[1][1]的值为：%d &quot;</span>, *(*(q + <span class="number">1</span>) + <span class="number">1</span>));<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历arr[0]中的几个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*q + i)); <span class="comment">//输出1 2 3 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【华南理工大学2018研】若有以下说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">int</span> w[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">&gt;<span class="type">int</span> (*p)[<span class="number">4</span>]=w;</span><br></pre></td></tr></table></figure><p>则数值为4的表达式是（　）。<br>A．*w[1]＋1<br>B．p++，*(p＋1)<br>C．w[2][2]<br>D．p[1][1]</p><p>【答案】D</p><p>【解析】A中*w[1]表示的是数值2，则表达式的值为3，错误；B中p++表示指向二维数组第二行w[1]的地址，而*(p＋1)代表的是第三行w[2][0]元素的地址，B错误；C中表示的是数值0，答案选D。</p></blockquote><h1 id="第06章-函数"><a href="#第06章-函数" class="headerlink" title="第06章_函数"></a>第06章_函数</h1><h2 id="本章专题脉络-5"><a href="#本章专题脉络-5" class="headerlink" title="本章专题脉络"></a>本章专题脉络</h2><p><img src="/img/images/%E7%AC%AC6%E7%AB%A0_%E5%87%BD%E6%95%B0.png" alt="第6章_函数"></p><h2 id="1、函数的基本使用"><a href="#1、函数的基本使用" class="headerlink" title="1、函数的基本使用"></a>1、函数的基本使用</h2><h3 id="1-1-为什么需要函数"><a href="#1-1-为什么需要函数" class="headerlink" title="1.1 为什么需要函数"></a>1.1 为什么需要函数</h3><p><img src="/img/images/%E8%A1%97%E5%A4%B4%E9%9C%B8%E7%8E%8B&%E8%B6%85%E7%BA%A7%E7%8E%9B%E4%B8%BD.jpg" alt="第6章_函数"></p><p>《街霸》游戏中，每次人物出拳、出脚或跳跃等动作都需要编写50-80行的代码，在每次出拳、出脚或跳跃的地方都需要<code>重复地编写</code>这50-80行代码，这样程序会变得<code>很臃肿</code>，可读性也非常差。为了解决代码重复编写的问题，可以将出拳、出脚或跳跃的<code>代码提取</code>出来放在一个{}中，并为这段代码起个名字，这样在每次的出拳、出脚或跳跃的地方通过这个名字来调用这个{}的代码就可以了。</p><blockquote><p>提取出来的代码可以看作是程序中定义的一个<code>函数</code>，程序在需要出拳、出脚或跳跃时调用该函数即可。</p></blockquote><p><img src="/img/images/1688975487489.png" alt="1688975487489"></p><ul><li><p>将特定功能的代码封装为函数的好处：<code>实现代码重用，减少冗余，简化代码</code>。</p></li><li><p>一个C源程序可以由一个或多个源文件构成（C文件扩展名是“.c”），一个源文件是一个编译单位。一个源文件可以由若干个函数构成，函数之间可以相互调用。也就是说，<code>函数是C程序基本的组成单位</code>。</p><p><img src="/img/images/image-20230808193420746.png" alt="image-20230808193420746"></p></li></ul><blockquote><p>练习：</p><p>C语言主要是借助以下（　　）功能来实现程序模块化的。<br>A．定义函数<br>B．定义常量和外部变量<br>C．三种基本结构语句<br>D．丰富的数据类型</p><p>【答案】A</p><p>【解析】C程序的模块化主要通过函数来实现。C语言允许对函数单独进行编译，从而可以实现模块化。</p></blockquote><h3 id="1-2-函数的分类"><a href="#1-2-函数的分类" class="headerlink" title="1.2 函数的分类"></a>1.2 函数的分类</h3><p><strong>角度1：从程序执行的角度看</strong></p><ul><li>主函数：main()函数</li><li>子函数：非main()函数</li></ul><p>每个C应用程序只有一个，且必须有一个main()主函数。无论主函数写在什么位置，C程序总是从main()函数开始执行。main()函数可以调用其它的子函数，子函数之间可以相互调用任意多次。</p><p><strong>角度2：是否允许源文件外调用角度看</strong></p><ul><li>内部函数</li><li>外部函数</li></ul><p><strong>角度3：从用户使用的角度看</strong></p><p><code>① 库函数(或标准函数)</code></p><p>它是由C系统提供的，用户不必自己定义，可直接使用它们。注意，不同的C语言编译系统提供的库函数的数量和功能会有一些不同，但是一些基本的函数是共同的。比如：</p><ul><li>字符串操作函数</li><li>字符操作函数</li><li>时间&#x2F;日期函数</li><li>数学函数</li><li>IO函数</li><li>内存操作函数</li><li>其它库函数</li></ul><blockquote><p>使用库函数，必须包含 <code>#include</code> 对应的头文件。</p></blockquote><p><code>② 用户自己定义的函数</code></p><p>它是用以解决用户特定业务需求的函数。</p><h3 id="1-3-函数的声明格式"><a href="#1-3-函数的声明格式" class="headerlink" title="1.3 函数的声明格式"></a>1.3 函数的声明格式</h3><p><strong>函数定义的格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名(数据类型1 形参1,数据类型2 形参2,…,数据类型n 形参n)&#123;</span><br><span class="line">函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算两个整数的和，并返回</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> m + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算两个整数的较大值，并返回</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;  <span class="comment">//定义函数max()</span></span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    c = a &gt; b ? a : b;     <span class="comment">//求a,b两个数的最大值，赋给c</span></span><br><span class="line">    <span class="keyword">return</span> c;     <span class="comment">//将最大值返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printMax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line"><span class="type">int</span> z;</span><br><span class="line">    z = x &gt; y ? x : y;     <span class="comment">//求x,y两个数的最大值，赋给z</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体说明：</strong></p><p><code>1) 返回值类型</code></p><p>函数调用后，是否需要在主调函数(比如main()函数)中得到一个确定的、返回的值，针对这个返回值的描述，就是返回值类型。返回值常常是一个计算的结果，或是用来作为判断函数执行状态(完成还是出错)的标记。</p><p>函数按是否有返回值来分类的话，分为：</p><ul><li><code>无返回值的类型</code>：针对函数无返回值或明确不需返回值的情况，使用 <code>void</code> (即空类型)表示。<ul><li>举例：输出函数 void printf(const char *format, …)。</li></ul></li><li><code>有返回值的类型</code>：指明具体的类型。比如， int、float、char 等。如果省略，默认为int类型。<ul><li>有返回值类型，则需要在函数体内与“<code>return 返回值</code>”搭配使用。返回值需要与返回值类型一致。</li><li>举例：int rand()，调用后返回一个随机整数</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printHello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRandomNumber</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rand() % <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在main()中调用printHello()、getRandomNumber()，相对于这两个方法，main()称为主调函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="comment">//调用printHello()</span></span><br><span class="line">    printHello();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用getRandomNumber()</span></span><br><span class="line">    <span class="type">int</span> randomNumber = getRandomNumber();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Random number: %d\n&quot;</span>, randomNumber);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>特殊的：如果返回值类型非 void，但被调函数中没有 return 语句，函数会返回一个不确定的值。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">//return 12;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = test();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/img/images/image-20230903233042036.png" alt="image-20230903233042036" style="zoom: 80%;" /><p><code>2) 函数名</code></p><p>函数名，属于标识符。要遵循标识符的命名规则，同时要<code>见名知意</code>，以增强程序的可读性。</p><p><code>3) 参数列表</code></p><p>函数名后面的圆括号里面，可以声明参数的类型和参数名。表示完成函数体功能时需要外部提供的数据列表。</p><p>根据是否有参数，函数可以分为：</p><ul><li><code>无参函数</code>，在调用无参函数时，主调函数不向被调用函数传递数据。但函数名后的()不能省略。<ul><li>举例：abort()：立即终止程序的执行，不接受任何形参。</li></ul></li><li><code>有参函数</code>，在调用函数时，主调函数在调用被调用函数时，通过参数向被调用函数传递数据。<ul><li>函数参数为多个参数时，其间用逗号隔开。</li><li>举例：add(int m,int n)，strcmp(const char *str1, const char *str2)</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印5行6列的*型矩形</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">6</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印m行n列的*型矩形</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraph</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//    print();</span></span><br><span class="line"></span><br><span class="line">    printGraph(<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>4) 函数体</code></p><p>函数体要写在大括号{}里面，是函数被调用后要执行的代码。</p><p>对于调用者来说，不了解函数体如何实现的，并不影响函数的使用。</p><p><code>5) 关于return 语句</code></p><ul><li>return语句的作用：① 结束函数的执行 ②将函数运算的结果返回。</li><li>return语句后面就不能再写其它代码了，否则会报错。(与break、continue情况类似)</li><li>下面分两种情况讨论：<ul><li>情况1：返回值类型不是void时，函数体中必须保证一定有 <code>return 返回值; </code>语句，并且要求该返回值结果的类型与声明的返回值类型一致或兼容。</li><li>情况2：返回值类型是void时，函数体中可以没有return语句。如果要用return语句提前结束函数的执行，那么return后面不能跟返回值，直接写<code>return;</code> 就可以。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">addInt</span><span class="params">(<span class="type">int</span> m ,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = m + n;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">addDouble</span><span class="params">(<span class="type">double</span> d1,<span class="type">double</span> d2)</span>&#123;</span><br><span class="line">    <span class="type">double</span> sum = d1 + d2;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printNum</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> limit)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start;i &lt;= limit;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//printf(&quot;今天买彩票，一定能中奖&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;over!\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = addInt(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>,result);</span><br><span class="line"></span><br><span class="line">    printNum(<span class="number">1</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类比举例：</strong></p><img src="/img/images/image-20220503102323689.png" alt="image-20220503102323689" style="zoom:67%;" /><h3 id="1-4-声明注意事项"><a href="#1-4-声明注意事项" class="headerlink" title="1.4 声明注意事项"></a>1.4 声明注意事项</h3><p>1、C程序中的所有函数都是互相独立的。一个函数并不从属于另一个函数，即函数不能嵌套定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误演示</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;   <span class="comment">//第1个函数的定义</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> d)</span>&#123;    <span class="comment">//第2个函数的定义</span></span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、同一个程序中函数不能重名，<code>函数名用来唯一标识一个函数</code>。即在标准的 C 语言中，并不支持函数的重载。</p><p><img src="/img/images/image-20230904205425583.png" alt="image-20230904205425583"></p><p><code>什么是函数的重载？</code></p><p>函数的重载是一种编程语言特性，像C++、Java等语言都支持。它允许在同一个作用域内(比如同一个”类”中)定义多个<code>函数名相同</code>但<code>参数列表不同</code>(即参数个数不同或参数类型不同)的函数。此时的多个函数彼此构成重载。</p><p>调用时，编译器会根据传递的参数类型和数量来确定调用哪个函数。</p><p>如果想在 C 中模拟函数的重载有两种方式。不过，都不如 C++ 中的函数重载那样灵活和方便。</p><ul><li>方式1：使用不同的函数名来区分不同的函数</li><li>方式2：为函数添加后缀来表示不同的版本。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> m)</span>&#123;</span><br><span class="line">    <span class="type">int</span> result = m * m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结果为：%d\n&quot;</span>,result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multiply1</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> result = m * n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结果为：%d\n&quot;</span>,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 【华南理工大学2018研】在C语言中，当函数的返回值缺省时，表示该函数返回值的类型是（　　）。<br> A．char<br> B．float<br> C．long<br> D．int</p><p> 【答案】D</p><p> 【解析】在C语言中，当函数的返回值缺省时，函数返回值的类型默认为int型。</p></blockquote><blockquote><p>【华南理工大学2018研】以下叙述中不正确的是（　）。<br>A．在不同的函数中可以使用相同名字的变量<br>B．函数中的形式参数是局部变量<br>C．在一个函数内定义的变量只能在本函数范围内有效<br>D．在一个函数的复合语句中定义的变量在本函数范围内有效</p><p>【答案】D</p><p>【解析】在一个函数的复合语句中定义的变量只在该复合语句中有效。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不能调用j</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【四川大学2017研】已定义如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun(<span class="type">int</span> *p)&#123;</span><br><span class="line"><span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的返回值是（　　）。</p><p>A．不确定的值<br>B．形参p中存放的值<br>C．形参p所指存储单元中的值<br>D．形参p的地址值</p><p>【答案】C</p><p>【解析】p是一个指向int型的指针变量，*p表示的是p所指向内存存放的变量，是一个int型，所以return *p表示返回p所指存储单元中的值，答案选C。</p></blockquote><blockquote><p>【华南理工大学2018研】下列函数的功能是（　）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun1</span><span class="params">(<span class="type">char</span> *x)</span> &#123;</span><br><span class="line"><span class="type">char</span> *y = x;</span><br><span class="line"><span class="keyword">while</span> (*y++);</span><br><span class="line"><span class="keyword">return</span> (y - x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A．求字符串的长度<br>B．比较两个字符串的大小<br>C．将字符串X复制到字符串Y<br>D．将字符串X连接到字符串Y后</p><p>【答案】A</p><p>【解析】while后面的表达式是指针依次遍历直到碰到\0，此时y指向字符串最后一个元素的后一个位置，但是由于y++，因此y会继续后移一位，而x指向字符串的头部，后面的y－x－1显然是用于计算字符串的长度。</p></blockquote><h3 id="1-5-函数的调用"><a href="#1-5-函数的调用" class="headerlink" title="1.5 函数的调用"></a>1.5 函数的调用</h3><p>调用函数时，需要传入实际的参数值。如果没有参数，只要在函数名后面加上圆括号就可以了。</p><p>举例1：</p><p>函数的声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是我的第一个函数！\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//func(10);     // 报错</span></span><br><span class="line"><span class="comment">//func(10,20);  // 报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//程序正常结束，默认返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20230808193457541.png" alt="image-20230808193457541"></p><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = x + y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x+y=%d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20230808193552194.png" alt="image-20230808193552194"></p><p>举例3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = func(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x+y=%d\n&quot;</span>, sum);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img/images/image-20230809104417557.png" alt="image-20230809104417557" style="zoom:80%;" /><blockquote><p>说明：</p><p>1、调用时，参数个数必须与函数声明里的参数个数一致，参数过多或过少都会报错。</p><p>2、函数间可以相互调用，但不能调用main函数，因为main函数是被操作系统调用的，作为程序的启动入口。反之，main() 函数可以调用其它函数。</p><p>3、函数的参数和返回值类型，会根据需要进行自动类型转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">65</span>;</span><br><span class="line"> <span class="keyword">return</span> a;  <span class="comment">//变量a的类型由int自动转换为char了。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line"><span class="type">short</span> b = <span class="number">10</span>;</span><br><span class="line">func(b);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c = func1();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="1-6-练习"><a href="#1-6-练习" class="headerlink" title="1.6 练习"></a>1.6 练习</h3><p>练习1：</p><p>① 编写程序，声明一个print1()函数，在函数中打印一个<code>10*8的*型矩形</code>。</p><p>② 编写程序，声明一个print2()函数，除打印一个<code>10*8的*型矩形</code>外，再计算该矩形的面积，并将其作为函数返回值。</p><p>③ 编写程序，声明一个print3()函数，函数提供m和n两个参数，函数中打印一个<code>m*n的*型矩形</code>，并计算该矩形的面积， 将其作为返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">8</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">print2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">8</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> * <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">print3</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习2：定义函数max()，求两个double型变量的最大值，求三个double型变量的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">dualMax</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">triMax</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> z)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dualMax(dualMax(x, y), z);  <span class="comment">//嵌套调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> a, b, c;</span><br><span class="line">    printf(<span class="string">&quot;a,b,c: &quot;</span>);</span><br><span class="line">    scanf(<span class="string">&quot;%lf,%lf,%lf&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    printf(<span class="string">&quot;%.2lf和%.2lf的最大值是：%.2lf\n&quot;</span>,a,b,dualMax(a, b));</span><br><span class="line">    printf(<span class="string">&quot;%.2lf、%.2lf、%.2lf的最大值是：%.2lf\n&quot;</span>,a,b,c,triMax(a,b,c));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习3：定义求和函数getSum，求 1+2+…+n，并返回结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> result = getSum(n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1+2+...+%d = %d\n&quot;</span>, n, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习4：哥德巴赫猜想</p><p>任一大于 2 的偶数都可写成两个素数之和。利用判断素数的函数 prime()验证哥德巴赫猜想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">prime</span><span class="params">(<span class="type">int</span> n)</span> &#123;  <span class="comment">//判断素数函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= sqrt(n); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    printf(<span class="string">&quot;请输入一个大于2的偶数：&quot;</span>);</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= num / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime(i) &amp;&amp; prime(num - i)) &#123;</span><br><span class="line">            printf(<span class="string">&quot;%d = %d + %d\n&quot;</span>, num, i, num - i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习5：</p><p>编写一组函数，用于处理日期和时间相关的操作。使用这些函数，可以进行日期和时间相关的计算。</p><p>① 编写一个函数 <code>char *getWeekName(int week)</code>，该函数接收一个代表星期的整数（1表示星期一，7表示星期日），并返回相应的星期名称。如果输入无效，则返回空字符串。</p><p>② 编写一个函数 <code>char *getMonthName(int month)</code>，该函数接收一个代表月份的整数（1表示一月，12表示十二月），并返回相应的月份名称。如果输入无效，则返回空字符串。</p><p>③ 编写一个函数 <code>int isLeapYear(int year)</code>，该函数接收一个年份，并检查它是否为闰年。如果是闰年，则返回1，否则返回0。如果输入年份为负数，则返回-1作为错误标志。</p><p>提示：能被4整除但不能被100整除，或者能被400整除的年份，即为闰年。</p><p>④ 编写一个函数 <code>int getTotalDaysOfMonth(int year, int month)</code>，该函数接收一个年份和月份，并返回指定月份的总天数。如果输入无效，则返回-1作为错误标志。</p><p>⑤ 编写一个函数 <code>int getTotalDaysOfYear(int year)</code>，该函数接收一个年份，并返回指定年份的总天数。如果输入无效，则返回-1作为错误标志。</p><p>模板：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数：getWeekName</span></span><br><span class="line"><span class="comment">// 描述：根据输入的星期数，返回相应的星期名称</span></span><br><span class="line"><span class="comment">// 参数：week - 代表星期的整数（1表示星期一，7表示星期日）</span></span><br><span class="line"><span class="comment">// 返回值：返回表示星期名称的字符串，如果输入无效则返回空字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getWeekName</span><span class="params">(<span class="type">int</span> week)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：getMonthName</span></span><br><span class="line"><span class="comment">// 描述：根据输入的月份数，返回相应的月份名称</span></span><br><span class="line"><span class="comment">// 参数：month - 代表月份的整数（1表示一月，12表示十二月）</span></span><br><span class="line"><span class="comment">// 返回值：返回表示月份名称的字符串，如果输入无效则返回空字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getMonthName</span><span class="params">(<span class="type">int</span> month)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：isLeapYear</span></span><br><span class="line"><span class="comment">// 描述：检查输入的年份是否为闰年</span></span><br><span class="line"><span class="comment">// 参数：year - 待检查的年份</span></span><br><span class="line"><span class="comment">// 返回值：如果是闰年则返回1，否则返回0，如果输入为负数则返回-1作为错误标志</span></span><br><span class="line"><span class="comment">//提示：能被4整除但不能被100整除，或者能被400整除的年份，即为闰年。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLeapYear</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：getTotalDaysOfMonth</span></span><br><span class="line"><span class="comment">// 描述：获取指定年份和月份的总天数</span></span><br><span class="line"><span class="comment">// 参数：year - 年份，month - 月份</span></span><br><span class="line"><span class="comment">// 返回值：返回该月份的总天数，如果输入无效则返回-1作为错误标志</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getTotalDaysOfMonth</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：getTotalDaysOfYear</span></span><br><span class="line"><span class="comment">// 描述：获取指定年份的总天数</span></span><br><span class="line"><span class="comment">// 参数：year - 年份</span></span><br><span class="line"><span class="comment">// 返回值：返回该年份的总天数，如果输入无效则返回-1作为错误标志</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getTotalDaysOfYear</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：getWeekName</span></span><br><span class="line"><span class="comment">// 描述：根据输入的星期数，返回相应的星期名称</span></span><br><span class="line"><span class="comment">// 参数：week - 代表星期的整数（1表示星期一，7表示星期日）</span></span><br><span class="line"><span class="comment">// 返回值：返回表示星期名称的字符串，如果输入无效则返回空字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getWeekName</span><span class="params">(<span class="type">int</span> week)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (week) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Wednesday&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Thursday&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Friday&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Saturday&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：getMonthName</span></span><br><span class="line"><span class="comment">// 描述：根据输入的月份数，返回相应的月份名称</span></span><br><span class="line"><span class="comment">// 参数：month - 代表月份的整数（1表示一月，12表示十二月）</span></span><br><span class="line"><span class="comment">// 返回值：返回表示月份名称的字符串，如果输入无效则返回空字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getMonthName</span><span class="params">(<span class="type">int</span> month)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *months[] = &#123;<span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>, <span class="string">&quot;October&quot;</span>, <span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (month &gt;= <span class="number">1</span> &amp;&amp; month &lt;= <span class="number">12</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> months[month - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：isLeapYear</span></span><br><span class="line"><span class="comment">// 描述：检查输入的年份是否为闰年</span></span><br><span class="line"><span class="comment">// 参数：year - 待检查的年份</span></span><br><span class="line"><span class="comment">// 返回值：如果是闰年则返回1，否则返回0，如果输入为负数则返回-1作为错误标志</span></span><br><span class="line"><span class="comment">// 提示：能被4整除但不能被100整除，或者能被400整除的年份，即为闰年。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLeapYear</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (year &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span> || year % <span class="number">400</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 输入年份为负数，返回错误标志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：getTotalDaysOfMonth</span></span><br><span class="line"><span class="comment">// 描述：获取指定年份和月份的总天数</span></span><br><span class="line"><span class="comment">// 参数：year - 年份，month - 月份</span></span><br><span class="line"><span class="comment">// 返回值：返回该月份的总天数，如果输入无效则返回-1作为错误标志</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getTotalDaysOfMonth</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month)</span> &#123;</span><br><span class="line">    <span class="type">int</span> days[] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (isLeapYear(year)) &#123;</span><br><span class="line">        days[<span class="number">1</span>]++; <span class="comment">// 闰年2月有29天</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (month &gt;= <span class="number">1</span> &amp;&amp; month &lt;= <span class="number">12</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> days[month - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 输入月份无效，返回错误标志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：getTotalDaysOfYear</span></span><br><span class="line"><span class="comment">// 描述：获取指定年份的总天数</span></span><br><span class="line"><span class="comment">// 参数：year - 年份</span></span><br><span class="line"><span class="comment">// 返回值：返回该年份的总天数，如果输入无效则返回-1作为错误标志</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getTotalDaysOfYear</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = isLeapYear(year);</span><br><span class="line">    <span class="keyword">switch</span>(result)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">366</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">365</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在主函数中使用这些函数的示例代码</span></span><br><span class="line">    <span class="type">int</span> result = getTotalDaysOfMonth(<span class="number">2023</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Total days in February 2023: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *monthName = getMonthName(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Month 4: %s\n&quot;</span>, monthName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 【武汉科技大学2019研】函数fun和实参数组的声明形式为：void fun（char ch，float x[]）； float a[5]；<br> 以下对函数的调用语句中，正确的是（　）。<br> A．fun（”a”，a[]）；<br> B．fun（’D’，a）；<br> C．fun（’65’，2.8）；<br> D．fun（32，a[5]）；</p><p> 【答案】B</p><p> 【解析】调用函数fun需要传入两个实参，第一个实参的类型是char字符型，第二个实参的类型是float数组型，只有选项B满足条件。其中C项’65’本身有语法错误，D项在传递数组时只需要数组名即可。</p></blockquote><blockquote><p> 【武汉科技大学2019研】设有定义int a[3][3]；和函数调用语句sort(a,3)；则正确的函数声明是（　　）。<br> A．void sort（int a，n）；<br> B．void sort（int a[][]，int n）；<br> C．void sort（int a[][3]，int n）；<br> D．void sort（int a[][3]，n）；</p><p> 【答案】C</p><p> 【解析】根据函数调用语句可以知道sort函数有两个参数，第一个参数的类型是一个二维int型数组，第二个参数是一个int型数据，所以A错误；B中因为二维数组一定要指定列数，B错误；D中形参n没有指定数据类型，错误；答案选C。</p></blockquote><h2 id="2、进一步认识函数"><a href="#2、进一步认识函数" class="headerlink" title="2、进一步认识函数"></a>2、进一步认识函数</h2><h3 id="2-1-关于main"><a href="#2-1-关于main" class="headerlink" title="2.1 关于main()"></a>2.1 关于main()</h3><p><strong>main()的作用</strong></p><p>C 语言规定， main() 是程序的入口函数，即所有的程序一定要包含一个 main() 函数。程序总是从这个函数开始执行，如果没有该函数，程序就无法启动。</p><p>main()函数可以调用其它函数，但其它函数不能反过来调用main()函数。main()函数也不能调用自己。</p><p><strong>main() 的一般格式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//函数体（略）</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C 语言约定：返回值 0 表示函数运行成功；返回其它非零整数值，表示运行失败，代码出了问题。系统根据 main() 的返回值，作为整个程序的返回值，确定程序是否运行成功。</p><p>正常情况下，如果 main() 里面省略 return 0 这一行，编译器会自动加上，即 main() 的默认返回值为0。所以，也可以声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//函数体（略）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，C 语言只会对 main() 函数默认添加返回值，对其它函数不会这样做，所以建议书写时保留 return 语句，以便形成统一的代码风格。</p></blockquote><p><strong>main()函数的其它写法</strong></p><p>main()的声明中可以带有两个参数，格式如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">   <span class="comment">//函数体</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>其中，形参argc，全称是argument count，表示传给程序的参数个数，其值至少是1；而argv，全称是argument value，argv[]则是指向字符串的指针数组。</p><p>这种方式可以通过命令行的方式，接收指定的字符串传给参数argv。举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>,argc);</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; argc;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令行执行参考：</p><p><img src="/img/images/image-20230927201006205.png" alt="image-20230927201006205"></p><p>或者</p><img src="/img/images/image-20230927200617380.png" alt="image-20230927200617380" style="zoom:86%;" /><blockquote><p>练习：</p><p>以下叙述中错误的是（　　）。<br>A．一个C程序可以包含多个不同名的函数<br>B．一个C程序只能有一个主函数<br>C．C程序在书写时，有严格的缩进要求，否则不能编译通过<br>D．C程序的主函数必须用main作为函数名</p><p>【答案】C</p><p>【解析】一个C程序有且只有一个主函数main。一个C程序可以包含多个不同名字的子函数。C程序在书写时没有严格的缩进要求。答案选择C选项。</p></blockquote><blockquote><p>【北京航空航天大学2018研】已知有以下sample.c程序的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*sample.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*++argv[<span class="number">2</span>]);  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>将该程序编译成可执行文件sample后，若在命令行下输入如下命令：<br>sample  January  February  March<br>则该命令正确的输出是（　　）。<br>A．J<br>B．a<br>C．F<br>D．e</p><p>【答案】D</p><p>【解析】根据命令行的输入可知，四个字符串赋给相应的指针数组，所以argv[2]表示第三个字符串February，再进行++操作，指针指向字符串的第二个字符e，最后进行取值操作，结果为e，答案为D。</p></blockquote><h3 id="2-2-关于exit"><a href="#2-2-关于exit" class="headerlink" title="2.2 关于exit()"></a>2.2 关于exit()</h3><p>exit() 函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件 <code>stdlib.h</code> 里面。</p><p>exit() 可以向程序外部返回一个值，它的参数就是程序的返回值。一般来说，使用两个常量作为它的参数，这两个常量也是定义在 stdlib.h 里面： </p><ul><li><p>EXIT_SUCCESS （相当于 0）表示程序运行成功，正常结束；</p></li><li><p>EXIT_FAILURE （相当于 1）表示程序异常中止。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序运行成功</span></span><br><span class="line"><span class="comment">// 等同于 exit(0);</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序异常中止</span></span><br><span class="line"><span class="comment">// 等同于 exit(1);</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br></pre></td></tr></table></figure><p>在main()函数结束时也会隐式地调用exit()函数，exit() 等价于使用 return 语句。其它函数使用 exit() ，就是终止整个程序的运行，没有其它作用。</p><p>C 语言还提供了一个 atexit() 函数，用来登记 exit() 执行时额外执行的函数，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件 stdlib.h 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure><p>atexit() 的参数是一个函数指针。注意，它的参数函数（下例的 print ）不能接受参数，也不能有返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;something wrong!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">atexit(print);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br></pre></td></tr></table></figure><p>上例中， exit() 执行时会先自动调用 atexit() 注册的 print() 函数，然后再终止程序。</p><h3 id="2-3-函数原型"><a href="#2-3-函数原型" class="headerlink" title="2.3 函数原型"></a>2.3 函数原型</h3><p>函数必须先声明，后使用。由于程序总是先运行 main() 函数，所以其它函数都必须在main()之前声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  func1();</span><br><span class="line">  func2();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中， main() 函数必须在最后声明，否则编译时会产生警告，找不到 func1() 或 func2() 的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func1();  <span class="comment">//报错</span></span><br><span class="line">    func2();  <span class="comment">//报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于函数较多的程序，保证每个函数的顺序正确，会变得很麻烦。C 语言提供的解决方法是，只要在程序开头处给出函数原型，函数就可以先使用、后声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;   <span class="comment">//函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">10</span>, n = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> sum = add(m, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓<code>函数原型(function prototype)</code>，就是函数在调用前提前告诉编译器每个函数的基本信息(它包括了返回值类型、函数名、参数个数、参数类型和参数顺序)，其它信息都不需要（不用包括函数体、参数名），函数具体的实现放在哪里，就不重要了。在函数调用时，检查函数原型和函数声明是否一致，只要一致就可以正确编译、调用。</p><p>函数原型中包括参数名也可以，虽然这样对于编译器是多余的，但是阅读代码时，有助于理解函数的意图。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span>;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> result = add(num1, num2); <span class="comment">// 调用函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum: %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时，也会看到如下的写法。虽然理论上可以在 main() 函数的首行放置函数原型，但这不是推荐的做法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;  <span class="comment">// 函数原型</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> result = add(num1, num2); <span class="comment">// 调用函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum: %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在C语言中，通常在main()函数之前或是程序源码文件的开头，给出当前脚本使用的所有函数的原型。以确保在main()函数内部调用其他函数时编译器已经了解这些函数的信息。</p></blockquote><h2 id="3、参数传递机制"><a href="#3、参数传递机制" class="headerlink" title="3、参数传递机制"></a>3、参数传递机制</h2><h3 id="3-1-复习：函数内变量的传递"><a href="#3-1-复习：函数内变量的传递" class="headerlink" title="3.1 复习：函数内变量的传递"></a>3.1 复习：函数内变量的传递</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//情况1：针对于基本数据类型的变量，将变量的值传递过去</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>,a);</span><br><span class="line"></span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情况2：针对于数组，将数组的地址传递过去</span></span><br><span class="line">    <span class="type">int</span> arr1[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *arr2;</span><br><span class="line">    arr2 = arr1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历数组arr1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    arr2[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历数组arr1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情况3：针对于指针，将指针保存的地址传递过去</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *q = p;</span><br><span class="line"></span><br><span class="line">    *q = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*q);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-形参、实参"><a href="#3-2-形参、实参" class="headerlink" title="3.2 形参、实参"></a>3.2 形参、实参</h3><ul><li><code>形参（formal parameter）</code>：在定义函数时，函数名后面括号()中声明的变量称为<code>形式参数</code>，简称<code>形参</code>。</li><li><code>实参（actual parameter）</code>：在调用函数时，函数名后面括号()中使用的值&#x2F;变量&#x2F;表达式称为<code>实际参数</code>，简称<code>实参</code>。</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;  <span class="comment">//x,y是add()中的形参</span></span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    z = x + y;</span><br><span class="line">    <span class="keyword">return</span> (z); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>,b = <span class="number">20</span>;</span><br><span class="line">    c = add(a, b); <span class="comment">//此时将实参a,b赋值给add()的形参</span></span><br><span class="line">    printf(<span class="string">&quot;sum is %d\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：</p><p>1、实参与形参的类型应相同或赋值兼容，个数相等、一一对应。</p><p>2、形参只是一个形式，在调用之前并不分配内存。函数调用时，系统为形参分配内存单元，然后将主调函数中的实参传递给被调函数的形参。被调函数执行完毕，通过return语句返回结果，系统将形参的内存单元释放。</p></blockquote><p>形参和实参的功能主要是数据传递，按照传递的是“数据”还是“地址”，分为“<code>值传递</code>”和“<code>地址传递</code>”两种方式。</p><h3 id="3-3-参数传递机制1：值传递"><a href="#3-3-参数传递机制1：值传递" class="headerlink" title="3.3 参数传递机制1：值传递"></a>3.3 参数传递机制1：值传递</h3><p>值传递，又称传值方式、数据复制方式，就是把主调函数的实参值<code>复制</code>给被调用函数的<code>形参</code>，使形参获得初始值。接着在函数内对形参值的修改，不影响实参值。</p><p>值传递，是<code>单向传递</code>，只能把实参的值传递给形参，而不能把形参的值再传回给实参。</p><p><strong>默认传递值的类型：基本数据类型 (整型类型、浮点类型，字符类型)、结构体、共用体、枚举类型。</strong></p><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>,a); <span class="comment">// a = 11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i); <span class="comment">// i = 10</span></span><br><span class="line">    increment(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i); <span class="comment">// i = 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 increment(i)，因为传入函数的是 i 的数据值，将数据值赋给遍历a，而不是 i 本身。修改a数据值，影响不到原始变量 i。</p><p>如果希望获取变化的参数值，可以把它作为返回值传回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);<span class="comment">// a = 11</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i); <span class="comment">// i = 10</span></span><br><span class="line">    i = increment(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i); <span class="comment">// i = 11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>体会：<code>形参、实参各占独立的存储空间</code>。函数在被调用时，给形参动态分配临时存储空间，函数返回释放。</p><p>举例2：交换两个变量的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    <span class="comment">//printf(&quot;a = %d,b = %d\n&quot;, a, b);  //输出交换后的结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">6</span>, y = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用函数之前：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d,y = %d\n&quot;</span>, x, y); <span class="comment">//输出调用swap()函数之前x,y的值</span></span><br><span class="line"></span><br><span class="line">    swap(x, y);               <span class="comment">//调用swap()函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用函数之后:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d,y = %d\n&quot;</span>, x, y); <span class="comment">//输出调用swap()函数之后x,y的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：为什么在swap()函数内变量a和b的值互换了，而主调函数main()中实参x和y却没有交换呢？这是参数按值传递的缘故。</p><p><img src="/img/images/1689041039746.png" alt="1689041039746"></p><p>如果想要实现值的交换，那就需要传入变量本身，这就需要传入变量的地址，即<code>地址传递</code>。</p><h3 id="3-4-参数传递机制2：地址传递"><a href="#3-4-参数传递机制2：地址传递" class="headerlink" title="3.4 参数传递机制2：地址传递"></a>3.4 参数传递机制2：地址传递</h3><p>地址传递，又称传地址方式、地址复制方式、指针传递，就是把实参地址常量进行复制，传送给形参。</p><p><strong>默认传递地址的类型：指针、数组</strong>。实参将地址传递给形参，二者地址值相同。</p><ul><li><p>比如1：当指针作为函数的形参时，实参传递给形参的是地址，在函数中通过形参保存的地址访问实参，进而在函数中通过地址对实参的修改影响到实参的值。这也称为<code>双向传递</code>。</p></li><li><p>比如2：当传递数组首元素地址时，即把实参数组的起始地址传递给形参。这样形参和实参数组就占用了共同的存储空间。在被调函数中，如果通过形参修改了数组元素值，调用函数后实参数组元素值也发生相应变化。</p></li></ul><h4 id="3-4-1-简单变量指针作为形参"><a href="#3-4-1-简单变量指针作为形参" class="headerlink" title="3.4.1 简单变量指针作为形参"></a>3.4.1 简单变量指针作为形参</h4><p>当函数的形参类型是指针类型时，使用该函数时，需要传递指针，或者地址，或者数组给该形参。函数内以指针的方式操作变量(*指针)。</p><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> *p1 = &amp;num;</span><br><span class="line"><span class="type">int</span> *p2 = p1;</span><br><span class="line">*p2 = <span class="number">50</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/images/image-20230810202628093.png" alt="image-20230810202628093"></p><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> *a)</span> &#123;</span><br><span class="line">    (*a)++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, *a); <span class="comment">// a = 11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i); <span class="comment">// i = 10</span></span><br><span class="line">    increment(&amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i); <span class="comment">// i = 11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为传入的是地址，函数体内部对该地址包含的值的操作，会影响到函数外部变量的值。</p><p>举例3：针对上节举例2，交换两个变量的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123; <span class="comment">//函数参数为指针类型</span></span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*a = %d,*b = %d\n&quot;</span>, *a, *b);  <span class="comment">//输出交换后的结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">6</span>, y = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用函数之前：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d,y = %d\n&quot;</span>, x, y); <span class="comment">//输出调用swap()函数之前x,y的值</span></span><br><span class="line"></span><br><span class="line">    swap(&amp;x, &amp;y);               <span class="comment">//调用swap()函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用函数之后:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d,y = %d\n&quot;</span>, x, y); <span class="comment">//输出调用swap()函数之后x,y的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过传入变量 x 和 y 的地址，函数内部就可以直接操作该地址，从而实现交换两个变量的值。</p><img src="/img/images/image-20230809164238776.png" alt="image-20230809164238776" style="zoom:80%;" /><p><strong>错误：</strong></p><p>错误方式1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *p1, <span class="type">int</span> *p2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *temp;</span><br><span class="line">    *temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = *temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中存在错误。问题出在临时指针 temp 没有分配内存空间，因此不能正确保存变量的值。因此对*temp的赋值就没有意义。</p><p>错误方式2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *p1, <span class="type">int</span> *p2)</span> &#123; <span class="comment">//形参是指针变量</span></span><br><span class="line">    <span class="type">int</span> *temp;</span><br><span class="line">    temp = p1;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    p2 = temp;</span><br><span class="line">    <span class="comment">//printf(&quot;*p1 = %d,*p2 = %d\n&quot;, *p1, *p2); //*p1 = 8,*p2 = 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数内部，只是交换了指针变量本身的值，而没有影响到原始调用函数时传递给 swap 函数的指针变量。</p><p>**复习：**虽然跟传参无关，这里特别提醒，函数不要返回内部变量的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> &amp;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数返回内部变量 i 的指针，这种写法是错的。因为当函数结束运行时，内部变量就失效了，这时指向内部变量 i 的内存地址就是无效的，再使用这个地址是错误的。</p><h4 id="3-4-2-数组作为形参"><a href="#3-4-2-数组作为形参" class="headerlink" title="3.4.2 数组作为形参"></a>3.4.2 数组作为形参</h4><p>数组名本身就代表该数组首地址，传数组的本质就是传地址。</p><p>因此，把数组名传入一个函数，就等同于传入一个指针变量。在函数内部，就可以通过这个指针变量获得整个数组。</p><p>举例1：对比传值与传址的方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">    b += <span class="number">1</span>;</span><br><span class="line">    c += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//测试test1()</span></span><br><span class="line">    <span class="type">int</span> arr1[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用函数前数组各元素值为： &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>, arr1[<span class="number">0</span>], arr1[<span class="number">1</span>], arr1[<span class="number">2</span>]); <span class="comment">//1,2,3</span></span><br><span class="line">    test1(arr1[<span class="number">0</span>], arr1[<span class="number">1</span>], arr1[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用函数后数组各元素值为： &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>, arr1[<span class="number">0</span>], arr1[<span class="number">1</span>], arr1[<span class="number">2</span>]); <span class="comment">//1,2,3 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试test2()</span></span><br><span class="line">    <span class="type">int</span> arr2[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用函数前数组各元素值为：&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>, arr2[<span class="number">0</span>], arr2[<span class="number">1</span>], arr2[<span class="number">2</span>]); <span class="comment">//1,2,3</span></span><br><span class="line">    test2(arr2, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用函数后数组各元素值为： &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>, arr2[<span class="number">0</span>], arr2[<span class="number">1</span>], arr2[<span class="number">2</span>]); <span class="comment">//2,3,4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：定义一个数组，通过函数给数组元素赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> vals[], <span class="type">int</span> len)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        vals[i] = i * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> nums[MAXLEN] = &#123;<span class="number">0</span>&#125;;           <span class="comment">//数组初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用函数前输出结果：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXLEN; i++)  <span class="comment">//遍历数组元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nums[%d] = %d\n&quot;</span>, i, nums[i]);</span><br><span class="line"></span><br><span class="line">    setValue(nums, MAXLEN);           <span class="comment">//调用函数，传递数组名和简单变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用函数后输出结果：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXLEN; i++)  <span class="comment">//遍历数组元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nums[%d] = %d\n&quot;</span>, i, nums[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，传入一个整数数组，与传入一个整数指针是同一回事，数组符号 [] 与指针符号 * 是可以互换的。比如，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setValue1</span><span class="params">(<span class="type">int</span> *vals, <span class="type">int</span> len)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        vals[i] = i * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例3：数组的元素的反转操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转数组元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = len - <span class="number">1</span>;i &lt; j;i++,j--)&#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[N] = &#123;<span class="number">23</span>,<span class="number">54</span>,<span class="number">96</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">    print(data,N);</span><br><span class="line"></span><br><span class="line">    reverse(data,N);</span><br><span class="line"></span><br><span class="line">    print(data,N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：</p><p>void f(int x[], int n){<br>…………;<br>}</p><p>参数1：数组的定义，只需写出中括号即可，不需要限定数组长度。</p><p>参数2：数组作为参数的习惯操作。将函数中要操作的数组元素的长度传入（并不是指数组的总长度）。</p><p>由于数组名就是一个指针，如果只传数组名，那么函数只知道数组开始的地址，不知道结束的地址，所以才需要把数组长度也一起传入。</p></blockquote><p>小结：实参与形参的对应关系有以下4种情况：</p><p>（1）形参和实参都用数组名</p><p>（2）实参形参都用指针变量</p><p>（3）实参用数组名，形参用指针变量</p><p>（4）实参为指针变量，形参为数组名</p><p><img src="/img/images/image-20230808203228409.png" alt="image-20230808203228409"></p><h4 id="3-4-3-字符串-字符指针-作为形参"><a href="#3-4-3-字符串-字符指针-作为形参" class="headerlink" title="3.4.3 字符串(字符指针)作为形参"></a>3.4.3 字符串(字符指针)作为形参</h4><p>字符串(或字符指针)作为函数的参数，与数组指针作为函数参数没有本质的区别，传递的都是地址值，所不同的仅是指针指向对象的类型不同而已。</p><p>举例1：定义函数，要求字符串作函数参数，统计数字字符出现的个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">digitalCount</span><span class="params">(<span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; *p != <span class="string">&#x27;\0&#x27;</span>; p++)</span><br><span class="line">        <span class="keyword">if</span> (*p &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *p &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> strs[N] = <span class="string">&quot;a12bc43hec22b68o&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数字字符的个数为 % d个\n&quot;</span>, digitalCount(strs)); <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-4-指针数组作为形参"><a href="#3-4-4-指针数组作为形参" class="headerlink" title="3.4.4 指针数组作为形参"></a>3.4.4 指针数组作为形参</h4><p>指针数组的元素是指针变量，用指针数组能够实现一组字符串的处理。</p><p>举例：编写能对多个字符串排序的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stringSort</span><span class="params">(<span class="type">char</span> *[], <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stringPrint</span><span class="params">(<span class="type">char</span> *[], <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *days[<span class="number">7</span>] = &#123;<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    stringSort(days, <span class="number">7</span>);</span><br><span class="line">    stringPrint(days, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stringSort</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="built_in">string</span>[j], <span class="built_in">string</span>[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                temp = <span class="built_in">string</span>[j];</span><br><span class="line">                <span class="built_in">string</span>[j] = <span class="built_in">string</span>[j + <span class="number">1</span>];</span><br><span class="line">                <span class="built_in">string</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stringPrint</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, <span class="built_in">string</span>[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-举例"><a href="#3-5-举例" class="headerlink" title="3.5 举例"></a>3.5 举例</h3><p><strong>举例1：定义函数，求一维数组元素的最大值</strong></p><p>原型：int pMax(int *p,int n)</p><p>功能：在长度为 n、由 p 指向的一维数组中求元素最大值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pMax</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max = *p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; *(p + i))&#123;</span><br><span class="line">            max = *(p + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max = %d\n&quot;</span>, pMax(a, N));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例2：多维数组名作为形参</strong></p><p>有一个3×4的矩阵，求所有元素中的最大值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[][<span class="number">4</span>], <span class="type">int</span> n)</span> &#123; <span class="comment">//n:第一维的长度</span></span><br><span class="line">    <span class="type">int</span> max = <span class="built_in">array</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (max &lt; <span class="built_in">array</span>[i][j])</span><br><span class="line">                max = <span class="built_in">array</span>[i][j]; <span class="comment">//把较大值重新赋值给max</span></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[N][<span class="number">4</span>] = &#123;&#123;<span class="number">11</span>,  <span class="number">33</span>, <span class="number">3</span>,  <span class="number">17</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">32</span>, <span class="number">54</span>, <span class="number">6</span>,  <span class="number">68</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">24</span>, <span class="number">17</span>, <span class="number">34</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max value is %d\n&quot;</span>, maxValue(a, N));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：</p><p>如果函数的参数是二维数组，那么除了第一维的长度可以当作参数传入函数，其他维的长度需要写入函数的定义。也就是说，在定义二维数组时，必须指定列数(即一行中包含几个元素) ，由于形参数组与实参数组类型相同，所以它们是由具有相同长度的一维数组所组成的。所以必须指定第2维(列数)。</p><p>在第2维大小相同的前提下，形参数组的第1维可以与实参数组不同。因为C语言编译系统不检查第一维的大小。例如，实参数组定义为<code>int score[5][10]</code>;而形参数组定义为<code>int array[][10]</code>;或<code>int array[8][10]</code>;均可以。这时形参数组和实参数组都是由相同类型和大小的一维数组组成的。</p></blockquote><p>练习：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x[][<span class="number">5</span>])</span>&#123;</span><br><span class="line">…………;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、int a[10][5]; 可以传给f函数吗？  可以！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、int b[10][3];可以传给f函数吗？   不可以！</span></span><br></pre></td></tr></table></figure><p><strong>举例3：变长数组作为参数</strong></p><p>变长数组作为函数参数时，写法略有不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int sum_array(int a[n],int n) &#123; //报错</span></span><br><span class="line"><span class="comment">//    // ...</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sumArray</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a[n])</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sum = sumArray(<span class="number">4</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组 a[n] 是一个变长数组，它的长度取决于变量 n 的值，只有运行时才能知道。所以，变量 n 作为参数时，顺序一定要在变长数组前面，这样运行时才能确定数组 a[n] 的长度，否则就会报错。</p><p>因为函数原型可以省略参数名，所以变长数组的原型中，可以使用 * 代替变量名，也可以省略变量名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumArray</span><span class="params">(<span class="type">int</span>, <span class="type">int</span> [*])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sumArray</span><span class="params">(<span class="type">int</span>, <span class="type">int</span> [])</span>;</span><br></pre></td></tr></table></figure><p>变长数组作为函数参数有一个好处，就是多维数组的参数声明，可以把后面的维度省掉了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的写法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sumArray</span><span class="params">(<span class="type">int</span> a[][<span class="number">4</span>], <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="comment">// 变长数组的写法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sumArray</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> a[n][m])</span>;</span><br></pre></td></tr></table></figure><p>说明：函数 sum_array() 的参数是一个多维数组，按照原来的写法，一定要声明第二维的长度。但是使用变长数组的写法，就不用声明第二维长度了，因为它可以作为参数传入函数。</p><h3 id="3-6-C-中的引用传递"><a href="#3-6-C-中的引用传递" class="headerlink" title="3.6 C++中的引用传递"></a>3.6 C++中的引用传递</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    f(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d&quot;</span>,a); <span class="comment">// a = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想让a实现+1，使用C语言的话，可以如下操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> *x)</span>&#123;</span><br><span class="line">    <span class="comment">//(*x)++;</span></span><br><span class="line">    *x = *x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    f1(&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d&quot;</span>,a); <span class="comment">// a = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言是靠传入变量地址的方式实现的，相对麻烦且容易出错。这里还可以使用C++的语法来操作。</p><p><strong>情况1：传入数值类型变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> &amp;x)</span> &#123;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    f2(a);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// a = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码在c语言环境中执行会报错，必须在c++环境中执行。</p><p>在这个C++版本中，我们使用了C++的<code>#include &lt;iostream&gt;</code> 来代替C的 <code>&lt;stdio.h&gt;</code>，并使用 <code>std::cout</code> 来替代 <code>printf</code> 函数。此外，f1函数的参数类型也从指针 <code>int *x</code> 改为引用 <code>int &amp;x</code>，这是C++的引用特性，允许更直观地操作变量，而不需要使用指针。其他部分保持不变，代码仍然具有相同的功能，将整数<code>a</code>的值增加1并打印结果。</p></blockquote><p><strong>情况2：传入结构体变量</strong></p><p>如果传入的是结构体变量，如果内部需要改变结构体的成员，则需要如下声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(SqList &amp;L,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="comment">//修改L内部data[]数组的内容，则认为修改了L,因此需要传入引用型L</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>情况3：传入指针型变量</strong></p><p>上述是普通变量的传入方式，如果传入的变量是指针型变量，且在函数内部需要对传入的指针进行改变，则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> *&amp;x)</span>&#123;  <span class="comment">//指针型变量在函数体中需要改变的写法</span></span><br><span class="line">x++; <span class="comment">//将指针 x 向后移动一个整数的大小。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>int *&amp;x</code>：这里 <code>int *</code> 表示指向整数的指针，<code>&amp;</code> 表示引用，因此 <code>int *&amp;x</code> 表示引用指向整数的指针。这个参数允许传递一个指向整数的指针，并且在函数内部可以改变指针的值。</p></blockquote><p>举例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> *&amp;x)</span> </span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *ptr = arr; <span class="comment">// 将指针指向数组的第一个元素</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">f</span>(ptr); <span class="comment">// 传递指针给函数，函数将指针移动到下一个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;New value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：将A、B两个链表合并成一个C，此时C发生了改变，需要引用型。A、B没发生改变，不需要引用型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(LNode *A,LNode *B,LNode *&amp;C)</span>&#123;</span><br><span class="line">LNode *p = A-&gt;next;</span><br><span class="line">LNode *q = B-&gt;next;</span><br><span class="line">    LNode *r;</span><br><span class="line">    C = A;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述写法在树、图的算法中应用广泛。</p></blockquote><h2 id="4、函数的高级应用"><a href="#4、函数的高级应用" class="headerlink" title="4、函数的高级应用"></a>4、函数的高级应用</h2><h3 id="4-1-递归-recursion-函数"><a href="#4-1-递归-recursion-函数" class="headerlink" title="4.1 递归(recursion)函数"></a>4.1 递归(recursion)函数</h3><p>举例1：</p><img src="/img/images/image-20230921183904470.png" alt="image-20230921183904470" style="zoom:80%;" /><p>举例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从前有座山,山上有座庙,庙里有个老和尚,老和尚在给小和尚讲故事,讲的啥?</span><br><span class="line">      从前有座山,山上有座庙,庙里有个老和尚,老和尚在给小和尚讲故事,讲的啥?</span><br><span class="line">          从前有座山,山上有座庙,庙里有个老和尚,老和尚在给小和尚讲故事,讲的啥?</span><br><span class="line">              从前有座山,山上有座庙,庙里有个老和尚,老和尚在给小和尚讲故事,讲的啥?...</span><br><span class="line">    ...</span><br><span class="line">老和尚没了,庙塌了,小和尚还俗结婚了。</span><br></pre></td></tr></table></figure><p><strong>递归函数调用</strong>：函数自己调用自己的现象就称为递归。</p><p><strong>递归的分类</strong>：直接递归、间接递归。</p><ul><li><p>直接递归：函数自身调用自己。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">   <span class="type">int</span> b,c;</span><br><span class="line">   …</span><br><span class="line">   c=func(b);</span><br><span class="line">   …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>间接递归：可以理解为A()函数调用B()函数，B()函数调用C()函数，C()函数调用A()函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">B();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">C();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">C</span><span class="params">()</span>&#123;</span><br><span class="line">A();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>说明</strong>：</p><ul><li>递归函数包含了一种<code>隐式的循环</code>。</li><li>递归函数会<code>重复执行</code>某段代码，但这种重复执行无须循环控制。</li><li>递归一定要向<code>已知方向</code>递归，否则这种递归就变成了无穷递归，停不下来，类似于<code>死循环</code>。最终发生<code>栈内存溢出</code>。</li><li>C语言支持函数的递归调用。</li></ul><p>举例1：计算1 ~ n的和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归函数，计算1到n的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 基本情况：当n为1时，返回1</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 递归情况：将n与1到n-1的和相加</span></span><br><span class="line">        <span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入一个正整数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用递归函数计算1到n的和</span></span><br><span class="line">    <span class="type">int</span> result = getSum(n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1到%d的和为%d\n&quot;</span>, n, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图示：</p><p><img src="/img/images/image-20230925154041038.png" alt="image-20230925154041038"></p><p>举例2：递归函数计算n!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归函数，计算n的阶乘</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 基本情况：当n为0或1时，阶乘为1</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 递归情况：n! = n * (n-1)!</span></span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用递归函数计算n的阶乘</span></span><br><span class="line">    <span class="type">int</span> result = factorial(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d! = %d\n&quot;</span>, n, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图示：</p><p><img src="/img/images/image-20220520150018655.png" alt="image-20220520150018655"></p><p>举例3：计算斐波那契数列（Fibonacci）的第n个值，斐波那契数列满足如下规律，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">55</span>,....</span><br></pre></td></tr></table></figure><p>即前两个数都是1，从第三个数开始，每个数等于前两个数之和。假设f(n)代表斐波那契数列的第n个值，那么f(n)满足：<br>f(n) &#x3D; f(n-2) + f(n-1);  其中，n &gt;&#x3D; 3。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归函数，计算第n个斐波那契数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacciRecursion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FibonacciRecursion(n - <span class="number">1</span>) + FibonacciRecursion(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用递归函数，而是使用迭代的方式计算第n个斐波那契数列，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FibonacciIteration</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        temp = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：</p><p>1、使用递归函数大大简化了算法的编写。</p><p>2、递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环<code>慢的多</code>，所以在使用递归时要慎重。</p><p>3、在要求高性能的情况下尽量避免使用递归，递归调用既<code>花时间</code>又<code>耗内存</code>。考虑使用循环迭代</p></blockquote><p>练习1：</p><p>有5个学生坐在一起，问第5个学生多少岁，他说比第4个学生大2岁。问第4个学生岁数，他说比第3个学生大2岁。问第3个学生，又说比第2个学生大2岁。问第2个学生，说比第1个学生大2岁。最后问第1个学生，他说是10岁。请问第5个学生多大。即：</p><p><img src="/img/images/image-20230527143843122.png" alt="image-20230527143843122"></p><img src="/img/images/image-20230527144005946.png" alt="image-20230527144005946" style="zoom:120%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">age</span><span class="params">(<span class="type">int</span> n)</span>; <span class="comment">//对age函数的声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NO.5:age is %d\n&quot;</span>, age(<span class="number">5</span>)); <span class="comment">//输出第5个学生的年龄</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">age</span><span class="params">(<span class="type">int</span> n)</span>&#123; <span class="comment">//定义递归函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c; <span class="comment">//c用作存放函数的返回值的变量</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        c = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        c = age(n - <span class="number">1</span>) + <span class="number">2</span>; <span class="comment">//年龄是前一个学生的年龄加2(如第4个学生年龄是第3个学生年龄加2)</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习2：走台阶问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假如有10阶楼梯，小朋友每次只能向上走1阶或者2阶，请问对于n阶台阶一共有多少种不同的走法呢？</span><br><span class="line">阶数：1    2    3     4</span><br><span class="line">走法：1    2    3     5</span><br><span class="line"></span><br><span class="line">fun(n) = fun(n - 1) + fun(n - 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【奇妙的属性】随着数列的增加，斐波那契数列前一个数与后一个数的比值越来越逼近黄金分割的数值0.618。</span><br></pre></td></tr></table></figure><h3 id="4-2-可变参数"><a href="#4-2-可变参数" class="headerlink" title="4.2 可变参数"></a>4.2 可变参数</h3><p>有些函数的参数数量是不确定的，此时可以使用C语言提供的<code>可变参数函数</code>（Variadic Functions）。</p><p>声明可变参数函数的时候，使用省略号 … 表示可变数量的参数。最常见的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br></pre></td></tr></table></figure><p>这里的 … 表示可以传递任意数量的参数，但是它们都需要与<code>format</code>字符串中的格式化标志相匹配。</p><blockquote><p>注意， … 符号必须放在<code>参数序列的结尾</code>，否则会报错。</p></blockquote><p><strong>可变参数函数的使用：</strong></p><ol><li>为了使用可变参数，你需要引入<code>&lt;stdarg.h&gt;</code>头文件。</li><li>在函数中，需要声明一个<code>va_list</code>类型的变量来存储可变参数。它必须在操作可变参数时，首先使用。</li><li>使用<code>va_start</code>函数来初始化<code>va_list</code>类型的变量。它接受两个参数，参数1是可变参数对象，参数2是原始函数里面，可变参数之前的那个参数，用来为可变参数定位。</li><li>使用<code>va_arg</code>函数来逐个获取可变参数的值。每次调用后，内部指针就会指向下一个可变参数。它接受两个参数，参数1是可变参数对象，参数2是当前可变参数的类型。</li><li>使用<code>va_end</code>函数来结束可变参数的处理。</li></ol><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数函数，计算多个整数的平均值</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">int</span> count, ...)</span> &#123;</span><br><span class="line">    va_list args; <span class="comment">// 声明一个va_list变量，存储可变参数</span></span><br><span class="line">    va_start(args, count); <span class="comment">// 初始化va_list，指向可变参数的位置</span></span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = va_arg(args, <span class="type">int</span>); <span class="comment">// 逐个获取整数参数</span></span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_end(args); <span class="comment">// 结束可变参数的处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum / count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> avg = average(<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>); <span class="comment">// 调用可变参数函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Average: %lf\n&quot;</span>, avg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小结：</p><p>可变参数函数，在编写各种工具函数和格式化输出函数时非常有用。但要小心确保传递的参数数量和类型与函数的预期相匹配，以避免运行时错误。</p></blockquote><h3 id="4-3-指针函数-返回值是指针"><a href="#4-3-指针函数-返回值是指针" class="headerlink" title="4.3 指针函数(返回值是指针)"></a>4.3 指针函数(返回值是指针)</h3><p>C语言允许函数的返回值是一个指针（地址），这样的函数称为<code>指针函数</code>。</p><p>指针函数的定义的一般格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 *函数名(形参列表) &#123;</span><br><span class="line">函数体</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>函数体中的 return 命令须返回一个地址。</p><p>举例1：获取两个字符串中较长的那个字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">maxLengthStr</span><span class="params">(<span class="type">char</span> *str1, <span class="type">char</span> *str2)</span> &#123; <span class="comment">//函数返回char * (指针)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nstr1的长度%d,str2的长度%d&quot;</span>, <span class="built_in">strlen</span>(str1), <span class="built_in">strlen</span>(str2));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(str1) &gt;= <span class="built_in">strlen</span>(str2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> str1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">30</span>], str2[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入第1个字符串:&quot;</span>);</span><br><span class="line">    gets(str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入第2个字符串:&quot;</span>);</span><br><span class="line">    gets(str2);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line">    str = maxLengthStr(str1, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nLonger string: %s \n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展：编写函数char *maxLlen (char *string[],int n)，用于查找多个字符串中的最长字符串，并返回该字符串的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">maxLen</span><span class="params">(<span class="type">char</span> *[], <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *pString[<span class="number">5</span>] = &#123;<span class="string">&quot;Atlanta1996&quot;</span>, <span class="string">&quot;Sydney2000&quot;</span>, <span class="string">&quot;Beijing2008&quot;</span>, <span class="string">&quot;London2012&quot;</span>, <span class="string">&quot;RIO2016&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(maxLen(pString, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">maxLen</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> posion, maxLen;</span><br><span class="line"></span><br><span class="line">    maxLen = <span class="built_in">strlen</span>(<span class="built_in">string</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxLen &lt; <span class="built_in">strlen</span>(<span class="built_in">string</span>[i]))&#123;</span><br><span class="line">            maxLen = <span class="built_in">strlen</span>(<span class="built_in">string</span>[i]);</span><br><span class="line">            posion = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>[posion];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *n = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">//分配动态内存</span></span><br><span class="line">    <span class="keyword">if</span> (n != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *n = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *p = func();</span><br><span class="line">    <span class="type">int</span> n = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value = %d\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// 释放动态分配的内存，以免出现内存泄漏</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上述操作很容易错写成如下方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *p = func();</span><br><span class="line">    <span class="type">int</span> n = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value = %d\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 func() 函数中，声明了一个整数变量 n，然后返回其地址 <code>&amp;n</code>。但是，一旦 func() 函数执行完毕，局部变量 n将被销毁，它的地址也将变得无效。这意味着在 main() 函数中，尝试访问 p 指向的地址时，它实际上已经不再是一个有效的内存位置，这会导致未定义的行为。</p><p>如果确实希望返回局部变量的地址，除了使用malloc()函数的方式之外，还可以定义局部变量为 <code>static</code> 的，此时数据空间在<code>静态数据区</code>分配，静态变量在程序的生命周期内都存在，不会像局部变量那样在函数执行完毕后被销毁。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *p = func();</span><br><span class="line">    <span class="type">int</span> n = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value = %d\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-函数指针-指向函数的指针"><a href="#4-4-函数指针-指向函数的指针" class="headerlink" title="4.4 函数指针(指向函数的指针)"></a>4.4 函数指针(指向函数的指针)</h3><p>一个函数本身就是一段内存里面的代码，总是占用一段连续的内存区域。这段内存区域也有首地址，把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是<strong>函数指针</strong>。</p><p>简单来说，函数指针，就是指向函数的指针。</p><p><strong>格式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (*指针变量名)(参数列表);</span><br></pre></td></tr></table></figure><p>其中，参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称。</p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> (*print_ptr)(<span class="type">int</span>); <span class="comment">//1</span></span><br><span class="line">    print_ptr = &amp;print;     <span class="comment">//2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处，变量 print_ptr 是一个函数指针，它可以指向函数返回值类型为void且有1个整型参数的函数。</p><p>注释2处，print_ptr 指向函数 print() 的地址。函数 print() 的地址可以用 &amp;print 获得。</p><blockquote><p>注意，<code>(*print_ptr)</code>的小括号一定不能省略，否则因为函数参数 (int) 的优先级高于 * ，整个结构就变成了函数原型： <code>void *print_ptr(int) </code>，<code>void *</code> 成了返回值类型了。</p></blockquote><p>有了函数指针，通过它也可以调用函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(*print_ptr)(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">print(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>举例：用函数指针来实现对函数的调用，返回两个整数中的最大值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> (*pmax)(<span class="type">int</span>, <span class="type">int</span>) = &amp;max; <span class="comment">// 使用函数指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入两个整数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxVal = (*pmax)(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;较大值为: %d\n&quot;</span>, maxVal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>拓 展</strong></p><p>C 语言规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址。也就是说， print 和 &amp;print 是一回事。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (print == &amp;print) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因此，上面代码的 print_ptr 等同于 print 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*print_ptr)(<span class="type">int</span>) = &amp;print;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="type">void</span> (*print_ptr)(<span class="type">int</span>) = print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (print_ptr == print) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>1、对指向函数的指针变量不能进行算术运算，如p+n，p++，p–等运算是无意义的。</p><p>2、用函数名调用函数，只能调用所指定的一个函数，而通过指针变量调用函数比较灵活，可以根据不同情况先后调用不同的函数。</p><blockquote><p> 【武汉科技大学2019研】有函数定义：int func(int *p)，x和y是int型变量，则正确的调用是（　）。<br> A．y＝func(x)；<br> B．func(x)；<br> C．func()＝x；<br> D．y＝func(&amp;x)；</p><p> 【答案】D</p><p> 【解析】根据func函数的定义可以知道调用func函数需要传入一个指针，且该指针的指向类型是int型，只有D传入的是指向int型数据的指针，答案选D。</p></blockquote><h3 id="4-5-回调函数"><a href="#4-5-回调函数" class="headerlink" title="4.5 回调函数"></a>4.5 回调函数</h3><p>指向函数a的指针变量的一个重要用途是把函数a的入口地址作为参数传递到其它函数b中，此时的函数b就称为<code>回调函数</code>。在此基础上，我们就可以在回调函数b中使用实参函数a。</p><p>它的原理可以简述如下: 有一个函数（假设函数名为fun），它有两个形参（x1和x2），定义x1和x2为指向函数的指针变量。在调用函数fun时，实参为两个函数名f1和f2，给形参传递的是函数f1和f2的入口地址。这样在函数fun中就可以调用f1和f2函数了。</p><p><img src="/img/images/image-20230527184508919.png" alt="image-20230527184508919"></p><p>举例1：使用回调函数的方式，给一个整型数组int arr[10] 赋10个随机数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initArray</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">int</span> arrayLen, <span class="type">int</span> (*f)())</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrayLen; i++)</span><br><span class="line">        <span class="built_in">array</span>[i] = (*f)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取随机值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRandomValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rand();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arrLen = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> myArray[arrLen];</span><br><span class="line">    initArray(myArray, arrLen, &amp;getRandomValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, myArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：有两个整数a和b，由用户输入1,2或3。如输入1，程序就给出a和b中的大者，输入2，就给出a和b中的小者，输入3，则求a与b之和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>))</span>; <span class="comment">//fun函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>; <span class="comment">//max函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>; <span class="comment">//min函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>; <span class="comment">//add函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please choose 1,2 or 3:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="comment">//输入1,2或3之一</span></span><br><span class="line">    <span class="keyword">switch</span>(n)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            fun(a, b, max); <span class="comment">//输入1时调用max函数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            fun(a, b, min); <span class="comment">//输入2时调用min函数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            fun(a, b, add); <span class="comment">//输入3时调用add函数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>))</span>&#123; <span class="comment">//定义fun函数</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    result = (*p)(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result); <span class="comment">//输出结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123; <span class="comment">//定义max函数</span></span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">        z = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        z = y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max=&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> z; <span class="comment">//返回值是两数中的大者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123; <span class="comment">//定义min函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; y)</span><br><span class="line">        z = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        z = y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;min=&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> z; <span class="comment">//返回值是两数中的小者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123; <span class="comment">//定义add函数</span></span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    z = x + y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum=&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> z; <span class="comment">//返回值是两数之和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-函数说明符"><a href="#4-6-函数说明符" class="headerlink" title="4.6 函数说明符"></a>4.6 函数说明符</h3><p>C 语言提供了一些函数说明符，让函数用法更加明确。</p><p>函数一旦定义，就可以被其它函数调用。但是当一个源程序由多个源文件组成时，在一个源文件中定义的函数能否被其他源文件中的函数调用呢？因此，C语言又把函数分为两类——<code>内部函数</code>和<code>外部函数</code>。</p><h4 id="①-内部函数-静态函数"><a href="#①-内部函数-静态函数" class="headerlink" title="① 内部函数(静态函数)"></a>① 内部函数(静态函数)</h4><p>如果在一个源文件中定义的函数只能被本文件中的函数调用，而不能被同一源程序其他文件中的函数调用，这种函数称为内部函数。此时，内部函数需要使用static修饰。</p><p>定义内部函数的一般形式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static 类型说明符 函数名(&lt;形参表&gt;)</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">   …</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>说明：f()函数只能被本文件中的函数调用，在其他文件中不能调用此函数。</p><p>但此处static的含义并不是指存储方式，而是指对函数的调用范围只局限于本文件。因此在不同的源文件中定义同名的内部函数不会引起混淆，互不影响。</p><h4 id="②-外部函数"><a href="#②-外部函数" class="headerlink" title="② 外部函数"></a>② 外部函数</h4><p>外部函数在整个源程序中都有效，只要定义函数时，在前面加上<code>extern</code>关键字即可。</p><p>其定义的一般形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern 类型说明符 函数名(&lt;形参表&gt;) </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为函数与函数之间都是并列的，函数不能嵌套定义，所以函数在本质上都具有外部性质。因此<strong>在定义函数省去extern说明符时，则隐含为外部函数</strong>。所以说，本节之前定义的使用的函数都是外部函数。</p><p>如果定义为外部函数，则它不仅可被定义它的源文件调用，而且可以被其他文件中的函数调用，即其作用范围不只局限于其源文件，而是整个程序的所有文件。在一个源文件的函数中调用其他源文件中定义的外部函数时，通常使用extern说明被调函数为外部函数。</p><p>练习：</p><p>（1）新建名称为“ExternFunction”的项目，在项目中创建下面的3个文件。<br>（2）新建名为“file1.c”的文件，并在代码编辑区域输入以下代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> d)</span> &#123;       <span class="comment">//定义外部函数add()，extern可省略不写</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d+%d=%d\n&quot;</span>, c, d, c + d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）新建名为“file2.c”的文件，并在代码编辑区域输入以下代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> d)</span> &#123;     <span class="comment">//定义外部函数sub()，extern可省略不写</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d-%d=%d\n&quot;</span>, c, d, c - d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）新建名为“file3.c”的文件，并在代码编辑区域输入以下代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于函数原型默认就是 extern ，所以这里不加 extern ，效果是一样的。</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> arg1, <span class="type">int</span> arg2)</span>;  </span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> arg1, <span class="type">int</span> arg2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    add(a, b);</span><br><span class="line">    sub(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个程序是由3个文件组成的，file3.c文件的主函数中使用了4个函数的调用语句。其中，printf()、scanf()是库函数，另外两个是用户自定义的函数，它们都被定义为外部函数。</p><p>在当前file3.c文件里面，main()函数使用前需要给出外部函数的原型，并用 extern 说明该函数的定义来自其它文件。</p><h2 id="5、再谈变量"><a href="#5、再谈变量" class="headerlink" title="5、再谈变量"></a>5、再谈变量</h2><p><img src="/img/images/%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB.png" alt="变量的分类"></p><h3 id="5-1-按声明位置的不同分类"><a href="#5-1-按声明位置的不同分类" class="headerlink" title="5.1 按声明位置的不同分类"></a>5.1 按声明位置的不同分类</h3><h4 id="①-局部变量-Local-Variable"><a href="#①-局部变量-Local-Variable" class="headerlink" title="① 局部变量(Local Variable)"></a>① 局部变量(Local Variable)</h4><p>在函数体内定义的变量或函数的形参，都是内部变量，称为<code>局部变量</code>。局部变量只能在定义它的函数中使用。</p><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStar</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        printStar();</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：</p><img src="/img/images/image-20231009113026410.png" alt="image-20231009113026410" style="zoom:80%;" /><h4 id="②-全局变量-Global-Variable"><a href="#②-全局变量-Global-Variable" class="headerlink" title="② 全局变量(Global Variable)"></a>② 全局变量(Global Variable)</h4><p>在函数之外定义的变量就是外部变量，称为<strong>全局变量</strong>(或全程变量)。</p><p>一个程序中，凡是在全局变量之后定义的函数，都可以使用在函数之前定义的全局变量。也就是说，一个全局变量，可以被多个函数使用，但并不一定能被所在程序中的每一个函数使用。</p><img src="/img/images/image-20231009113908064.png" alt="image-20231009113908064" style="zoom:80%;" /><blockquote><p>注意：</p><p>如果全局变量与函数中定义的局部变量重名，则在函数内部调用此同名的变量，默认是局部变量（就近原则）。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counter = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;counter = %d\n&quot;</span>,counter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    add();</span><br><span class="line">    add();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;counter = %d\n&quot;</span>,counter); <span class="comment">//counter = 12</span></span><br><span class="line">    <span class="type">int</span> counter = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;counter = %d\n&quot;</span>,counter); <span class="comment">//counter = 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p> 利用全局变量传递数据：</p><ul><li><p>利用全局变量进行函数间的数据传递，简单而运行效率高。</p></li><li><p>全局变量使用过多增加了函数间联系的复杂性，降低了函数的独立性。</p></li></ul></blockquote><p><strong>局部变量与全局变量的对比：</strong></p><p><code>1、作用域</code></p><ul><li>局部变量：它的作用域只能在其定义的函数或代码块内部，超出该范围将无法访问。</li><li>全局变量：它的作用域默认是整个程序，也就是所有的代码文件。</li></ul><p><code>2、访问权限</code></p><ul><li>局部变量：由于局部变量的作用域仅限于定义它们的函数或代码块，只有在该范围内才能访问它们。其他函数无法直接访问局部变量。</li><li>全局变量：全局变量可以被程序中的任何函数访问，只要它们在被访问之前已经被声明。</li></ul><p><code>3、生命周期</code></p><ul><li>局部变量：局部变量的生存周期仅限于定义它们的函数或代码块的执行时间。它们在函数或代码块执行结束后会被销毁。</li><li>全局变量：全局变量的生命周期从程序开始运行直到程序结束。它们在程序整个运行期间都存在。</li></ul><p><code>4、初始值</code></p><ul><li><p>局部变量：系统不会对其默认初始化，必须对局部变量初始化后才能使用，否则，程序运行后可能会异常退出。</p></li><li><p>全局变量：如果没有显式初始化，它们会被自动、默认初始化为零或空值，具体取决于数据类型。</p><table><thead><tr><th>数据类型</th><th>默认初始化值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>char</td><td>‘\0’ 或 0</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>指针</td><td>NULL</td></tr></tbody></table></li></ul><p><code>5、内存中的位置</code></p><ul><li>局部变量：保存在<code>栈</code>中，函数被调用时才动态地为变量分配存储单元。</li><li>全局变量：保存在内存的<code>全局存储区</code>中，占用静态的存储单元。</li></ul><p><strong>全局变量使用建议：不在必要时不要使用全局变量。</strong></p><p>原因如下：</p><p>① <code>占用内存时间长</code>：全局变量在程序的全部执行过程中都占用存储单元，而不是仅在需要时才开辟单元。</p><p>② <code>降低了函数、程序的可靠性和通用性</code>：如果在函数中引用了全局变量，那么执行情况会受到有关的外部变量的影响；如果将一个函数移到另一个文件中，还要考虑把有关的外部变量及其值一起移过去。但是若该外部变量与其它文件的变量同名时，就会出现问题。</p><p>一般要求把C程序中的函数做成一个相对的封闭体，除了可以通过“实参—形参”的渠道与外界发生联系外，没有其它渠道。这样的程序移植性好，可读性强。</p><p>③ <code>程序容易出错</code>：使用全局变量过多，人们往往难以清楚地判断出每个瞬时各个外部变量的值。由于在各个函数执行时都可能改变外部变量的值，程序容易出错。因此，要限制使用全局变量。</p><h3 id="5-2-按存储方式的不同分类"><a href="#5-2-按存储方式的不同分类" class="headerlink" title="5.2 按存储方式的不同分类"></a>5.2 按存储方式的不同分类</h3><p>在C语言中，每一个变量都有两个属性: <code>数据类型</code>和<code>数据的存储类别</code>。存储类别指的是数据在内存中存储的方式(如静态存储和动态存储)。在声明变量时，一般应同时指定其数据类型和存储类别，也可以采用默认方式指定（即如果用户不指定，系统会隐含地指定为某一种存储类别）。</p><p>变量的存储有两种不同的方式: <strong>静态存储方式</strong>和<strong>动态存储方式</strong>。</p><p>从变量值<code>存在的时间</code>（即<code>生命周期</code>）来观察，有的变量在程序运行的整个过程都是存在的，而有的变量则是在调用其所在的函数时才临时分配存储单元，而在函数调用结束后该存储单元就马上释放了，变量不存在了。</p><h4 id="①-动态-自动-存储方式"><a href="#①-动态-自动-存储方式" class="headerlink" title="① 动态(自动)存储方式"></a>① 动态(自动)存储方式</h4><p>动态存储方式：在程序运行期间根据需要进行<code>动态的分配存储空间</code>的方式，数据存放在<code>动态存储区</code>。</p><p><strong>在动态存储区中存放以下数据：</strong></p><ul><li>函数形参：在调用函数时给形参分配存储空间。</li><li>函数中定义的局部变量且没有用关键字static声明的变量，即自动变量。</li><li>函数调用时的返回地址等。</li></ul><p>在调用该函数时，系统会给这些变量分配存储空间，<strong>在函数调用结束时就自动释放这些存储空间</strong>。因此这类局部变量称为<strong>自动变量</strong>。自动变量用关键字<code>auto</code>作存储类别的声明。</p><p><img src="/img/images/image-20230808205204324.png" alt="image-20230808205204324"></p><p>实际上，关键字auto可以省略，<strong>不写auto则隐含指定为“自动存储类别”</strong>，它属于动态存储方式。程序中大多数变量属于自动变量。每个函数中的局部变量的生命周期与函数的执行周期相匹配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="type">int</span> b = <span class="number">3</span>; <span class="comment">//等价于int b = 3;</span></span><br></pre></td></tr></table></figure><p>如果在一个程序中两次调用同一函数，而在此函数中定义了局部变量，在两次调用时，函数的内部变量都会重新初始化，不会保留上一次运行的值。分配给这些局部变量的存储空间的地址可能是不相同的。</p><h4 id="②-静态存储方式"><a href="#②-静态存储方式" class="headerlink" title="② 静态存储方式"></a>② 静态存储方式</h4><p>静态存储方式：在程序运行期间数据存放在<code>静态存储区</code>。它们在程序整个运行期间都不释放，故生命周期存在于程序的整个运行过程。</p><p><code>局部变量</code>，使用static修饰以后，则使用静态存储方式。</p><ul><li><p>有时希望函数中的局部变量的值在函数调用结束后不消失而继续保留原值，即其占用的存储单元不释放，在下一次再调用该函数时，该变量已有值（就是上一次函数调用结束时的值）。这时就应该指定该局部变量为“<strong>静态局部变量</strong>”，用关键字<code>static</code>进行声明。</p></li><li><p>静态局部变量在声明时未赋初值，编译器也会把它初始化为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><p><code>全局变量</code>大多存放在静态存储区中（不包括extern修饰和malloc函数分配的方式），在程序开始执行时给全局变量分配存储区，程序执行完毕就释放。在程序执行过程中它们占据固定的存储单元，而不是动态地进行分配和释放。</p><ul><li>普通全局变量对整个工程可见，其他文件可以使用extern外部声明后直接使用。也就是说其他文件不能再定义一个与其相同名字的变量了（否则编译器会认为它们是同一个变量）。</li><li>而全局变量使用static修饰，则称为<strong>静态全局变量</strong>，静态全局变量<code>仅对当前文件可见</code>，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。</li></ul><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">nonStaticFun</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>; <span class="comment">//动态存储方式</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n=%d\n&quot;</span>, n);</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n++=%d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">staticFun</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n = <span class="number">10</span>; <span class="comment">//静态存储方式</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;static n=%d\n&quot;</span>, n);</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n++=%d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    nonStaticFun();</span><br><span class="line">    staticFun();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nonStaticFun();</span><br><span class="line">    staticFun();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n=10</span><br><span class="line">n++=11</span><br><span class="line">static n=10</span><br><span class="line">n++=11</span><br><span class="line"></span><br><span class="line">n=10</span><br><span class="line">n++=11</span><br><span class="line">static n=11</span><br><span class="line">n++=12</span><br></pre></td></tr></table></figure><blockquote><p>说明： </p><p>1、对静态局部变量是在编译时赋初值的，即只赋初值一次，在程序运行时它已有初值。以后每次调用函数时不再重新赋初值而只是保留上次函数调用结束时的值。</p><p>2、对自动变量赋初值，不是在编译时进行的，而是在函数调用时进行的，每调用一次函数就执行一次赋值语句。</p></blockquote><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">//函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>, i; <span class="comment">//(自动)局部变量</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f(a)); <span class="comment">//输出f(a)的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> b = <span class="number">0</span>; <span class="comment">//(自动)局部变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c = <span class="number">3</span>; <span class="comment">//静态局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>,c);</span><br><span class="line">    b++;</span><br><span class="line">    c++;</span><br><span class="line">    <span class="keyword">return</span> (a + b + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图示：</p><p><img src="/img/images/image-20230809143454717.png" alt="image-20230809143454717"></p><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c = 3</span><br><span class="line">7</span><br><span class="line">c = 4</span><br><span class="line">8</span><br><span class="line">c = 5</span><br><span class="line">9</span><br></pre></td></tr></table></figure><blockquote><p>补充说明：</p><p>1、虽然静态局部变量在函数调用结束后仍然存在，但其它函数是不能引用它的。因为它是局部变量，只能被本函数引用，而不能被其它函数引用。</p><p>2、如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符′\0′（对字符变量）。而对自动变量来说，它的值是一个不确定的值。这是由于每次函数调用结束后存储单元已释放，下次调用时又重新另分配存储单元，而所分配的单元中的内容是不可知的。</p></blockquote><p><strong>使用静态存储的弊端及建议：</strong></p><ul><li>静态存储要久占内存（长期占用不释放，而不能像动态存储那样一个存储单元可以先后为多个变量使用，节约内存）</li><li>降低了程序的可读性，当调用次数多时往往弄不清静态局部变量的当前值是什么。</li></ul><p>因此，若非必要，不要频繁使用静态局部变量。</p><blockquote><p> 【华南理工大学2018研】设有下列程序</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ff</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">9</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">4</span>) &#123;</span><br><span class="line">      a += c;</span><br><span class="line">      b++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a += c;</span><br><span class="line">      b--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d\n&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  ff();</span><br><span class="line">  ff();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p> 则该程序执行后，显示的结果为（　）。<br> A．a＝10，b＝5<br> a＝19，b＝5<br> B．a＝10，b＝4<br> a＝19，b＝5<br> C．a＝10，b＝4<br> a＝19，b＝4<br> D．a＝10，b＝5<br> a＝19，b＝4</p><p> 【答案】D</p><p> 【解析】第一次调用ff()时，c＝9，a＝1，b＝4，程序进入if语句块，执行完后a＝10，b＝5；第二次调用ff()，因为a、b是静态变量，所以a、b的值不会重新初始化，所以进入else语句块，执行完后a＝19，b＝4，答案选D。</p></blockquote><h3 id="5-3-其它变量修饰符-了解"><a href="#5-3-其它变量修饰符-了解" class="headerlink" title="5.3 其它变量修饰符(了解)"></a>5.3 其它变量修饰符(了解)</h3><h4 id="5-3-1-寄存器变量-register变量"><a href="#5-3-1-寄存器变量-register变量" class="headerlink" title="5.3.1 寄存器变量(register变量)"></a>5.3.1 寄存器变量(register变量)</h4><p>一般情况下，变量（包括静态存储方式和动态存储方式）的值是存放在内存中的。当程序中用到哪一个变量的值时，由控制器发出指令将内存中该变量的值送到运算器中。 经过运算器进行运算，如果需要存数，再从运算器将数据送到内存存放。</p><p>如果有一些变量使用频繁（例如，在一个函数中执行10 000次循环，每次循环中都要引用某局部变量），则为存取变量的值要花费不少时间。为提高执行效率，允许将局部变量的值放在CPU中的寄存器中，需要用时直接从寄存器取出参加运算，不必再到内存中去存取。由于对寄存器的存取速度远高于对内存的存取速度，因此这样做可以提高执行效率。这种变量叫做寄存器变量，用关键字register作声明。如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> f; <span class="comment">//定义f为寄存器变量</span></span><br></pre></td></tr></table></figure><p>由于现在的计算机的速度愈来愈快，性能愈来愈高， 优化的编译系统能够识别使用频繁的变量，从而自动地将这些变量放在寄存器中，而不需要程序设计者指定。因此，现在实际上用register声明变量的必要性不大。</p><blockquote><p>3种局部变量的存储位置是不同的：</p><ul><li><p>(自动)局部变量存储在动态存储区；</p></li><li><p>静态局部变量存储在静态存储区；</p></li><li><p>寄存器存储在CPU中的寄存器中。</p></li></ul></blockquote><h4 id="5-3-2-extern修饰变量"><a href="#5-3-2-extern修饰变量" class="headerlink" title="5.3.2 extern修饰变量"></a>5.3.2 extern修饰变量</h4><p>一般来说，外部变量是在函数的外部定义的全局变量，它的作用域是从变量的定义处开始，到本程序文件的末尾。在此作用域内，全局变量可以为程序中各个函数所引用。但有时程序员希望能扩展外部变量的作用域。</p><p><strong>在一个文件内扩展全局变量的作用域</strong></p><p>如果外部变量不在文件的开头定义，其有效的作用范围只限于定义处到文件结束。 在定义点之前的函数不能引用该外部变量。如果由于某种考虑，在定义点之前的函数需要引用该外部变量，则应该在引用之前用关键字<strong>extern</strong>对该变量作“<code>外部变量声明</code>”，表示把该外部变量的作用域扩展到此位置。有了此声明，就可以从“声明”处起，合法地使用该外部变量。</p><p>举例：调用函数，求3个整数的最大值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">()</span>; <span class="comment">//函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a, b, c; <span class="comment">//把外部变量a,b,c的作用域扩展到从此处开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入3个整数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c); <span class="comment">//输入3个整数给a,b,c</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max is %d\n&quot;</span>, max());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, c; <span class="comment">//定义外部变量a,b,c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    m = (a &gt; b) ? a : b; <span class="comment">//把a和b中的大者放在m中</span></span><br><span class="line">    m = (m &gt; c) ? m : c; <span class="comment">//将a,b,c三者中的大者放在m中</span></span><br><span class="line">    <span class="keyword">return</span> m; <span class="comment">//返回m的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>1、提倡将外部变量的定义放在引用它的所有函数之前，这样可以避免在函数中多加一个extern声明。</p><p>2、用extern声明外部变量时，类型名可以写也可以省写。例如，“extern int a,b,c;”也可以写成“extern a,b,c;”。因为它不是定义变量，可以不指定类型，只须写出外部变量名即可。</p></blockquote><p><strong>将全局变量的作用域扩展到其它文件</strong></p><p>如果一个程序包含两个文件，在两个文件中都要用到同一个外部变量num，不能分别在两个文件中各自定义一个外部变量num，否则在进行程序的连接时会出现“重复定义”的错误。正确的做法是: 在任一个文件中定义外部变量num，而在另一文件中用extern对num作“外部变量声明”，即“extern num; ”。</p><p>在编译和连接时，系统会由此知道num有“外部链接”，可以从别处找到已定义的外部变量num，并将在另一文件中定义的外部变量num的作用域扩展到本文件，在本文件中可以合法地引用外部变量num。</p><p>举例：给定b的值，输入a和m，求a*b和a^m的值。</p><p>【file1.c】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A; <span class="comment">//定义外部变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">power</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>, c, d, m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enter the number a and its power m:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;A, &amp;m);</span><br><span class="line"></span><br><span class="line">    c = A * b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%d\n&quot;</span>, A, b, c);</span><br><span class="line"></span><br><span class="line">    d = power(m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d**%d=%d\n&quot;</span>, A, m, d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【file2.c】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> A;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把file1中定义的外部变量的作用域扩展到本文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">power</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        y *= A;</span><br><span class="line">    <span class="keyword">return</span> (y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用这种方法扩展全局变量的作用域应十分慎重，因为在执行一个文件中的操作时，可能会改变该全局变量的值，会影响到另一文件中全局变量的值，从而影响该文件中函数的执行结果。</p></blockquote><p>extern既可以用来扩展外部变量在本文件中的作用域，又可以使外部变量的作用域从一个文件扩展到程序中的其它文件，系统在编译过程中遇到extern时，</p><ul><li><p>先在本文件中找外部变量的定义，如果找到，就在本文件中扩展作用域；</p></li><li><p>如果找不到，就在连接时从其它文件中找外部变量的定义。如果从其它文件中找到了，就将作用域扩展到本文件；</p></li><li><p>如果再找不到，就按出错处理。</p></li></ul><p><strong>将外部变量的作用域限制在本文件中</strong></p><p>有时在程序设计中希望某些外部变量<code>只限于被本文件引用</code>，而不能被其它文件引用。这时可以在定义外部变量时加一个static声明。</p><p><img src="/img/images/image-20230809143539166.png" alt="image-20230809143539166"></p><p>这种加上static声明、只能用于本文件的全局变量称为<strong>静态全局变量</strong>。在程序设计中，常由若干人分别完成各个模块，各人可以独立地在其设计的文件中使用相同的外部变量名而互不相干。只须在每个文件中定义外部变量时加上static即可。</p><p>这就为程序的模块化、通用性提供方便。如果已确认其它文件不需要引用本文件的外部变量，就可以对本文件中的外部变量都加上static，成为静态外部变量，以免被其它文件误用。</p><h4 id="5-3-3-const修饰变量"><a href="#5-3-3-const修饰变量" class="headerlink" title="5.3.3 const修饰变量"></a>5.3.3 const修饰变量</h4><p>在C语言中，<code>const</code> 关键字用于创建常量，它指示编译器将标识符（变量、参数、函数等）视为不可修改的值。const关键字可以应用于不同的上下文，以下是它的主要用途和使用方法：</p><p><strong>1、常量变量声明</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> myConstant = <span class="number">42</span>;</span><br><span class="line">    myConstant = <span class="number">23</span>; <span class="comment">//报错，因为myConstant是常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，myConstant被声明为一个整数常量，它的值在程序的执行期间不能被修改。任何尝试修改它的操作都会导致编译器错误。</p><p><strong>2、指向常量的指针</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *ptr;</span><br><span class="line">    ptr = &amp;num1;</span><br><span class="line">    *ptr = <span class="number">20</span>; <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，ptr 是一个指向常量整数的指针，这意味着你可以使用 ptr 访问整数 x，但不能通过 ptr 修改x的值。</p><p>上面这种写法，const 只限制 *ptr 不能修改，而 ptr 本身的地址是可以修改的。</p><p><strong>3、常量指针</strong>：</p><p>如果想限制 ptr不能修改 ，可以把 const 放在 ptr 前面，此时即为常量指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *<span class="type">const</span> ptr = &amp;num1;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">    ptr = &amp;num2; <span class="comment">//报错</span></span><br><span class="line">    </span><br><span class="line">    *ptr = <span class="number">20</span>;   <span class="comment">//未报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> p)</span> &#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">13</span>;</span><br><span class="line">  p = &amp;x; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想同时限制修改 ptr 和 *ptr ，需要使用两个 const 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> ptr = &amp;num1;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">    ptr = &amp;num2; <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line">    *ptr = <span class="number">20</span>;   <span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、常量参数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func4</span><span class="params">(<span class="type">const</span> <span class="type">int</span> param)</span> &#123;</span><br><span class="line">    param = <span class="number">20</span>; <span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数声明中，param 是一个常量参数，这意味着在函数内部不能修改传递给它的参数的值。</p><p><strong>5、常量数组</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">//报错</span></span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">20</span>; <span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>numbers 数组被声明为一个包含整数常量的数组。这表示数组的每个元素都是常量，不能被修改。</p><p><strong>6、常量结构体</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在结构体声明中使用 const 可以创建包含常量成员的结构体，这表示结构体的每个成员都不能被修改。</p><blockquote><p>总结： </p><p>const 关键字有助于编程中的可读性和代码的安全性，因为它使得编译器能够在编译时捕获对常量的非法修改。在编写代码时，使用 const 可以明确表达你的意图，告诉其他人或将来的自己这个值不应该被修改。</p></blockquote><blockquote><p>【四川大学2017研】在C语言中，形参的缺省存储类型是（　　）。<br>A．auto<br>B．register<br>C．static<br>D．extern</p><p>【答案】A</p><p>【解析】形参是局部变量，缺省类型为auto型。</p></blockquote><p>小结：</p><p><img src="/img/images/image-20231011205858506.png" alt="image-20231011205858506"></p><h1 id="第07章-结构体与共用体"><a href="#第07章-结构体与共用体" class="headerlink" title="第07章_结构体与共用体"></a>第07章_结构体与共用体</h1><h2 id="本章专题脉络-6"><a href="#本章专题脉络-6" class="headerlink" title="本章专题脉络"></a>本章专题脉络</h2><p><img src="/img/images/%E7%AC%AC7%E7%AB%A0_%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%85%B1%E7%94%A8%E4%BD%93.png" alt="第7章_结构体与共用体"></p><h2 id="1、结构体-struct-类型的基本使用"><a href="#1、结构体-struct-类型的基本使用" class="headerlink" title="1、结构体(struct)类型的基本使用"></a>1、结构体(struct)类型的基本使用</h2><h3 id="1-1-为什么需要结构体？"><a href="#1-1-为什么需要结构体？" class="headerlink" title="1.1 为什么需要结构体？"></a>1.1 为什么需要结构体？</h3><p>C 语言内置的数据类型，除了几种原始的基本数据类型，只有数组属于复合类型，可以同时包含多个值，但是只能包含<code>相同类型</code>的数据，实际使用场景受限。</p><p><strong>举例1：</strong></p><p>现有一个需求，编写学生档案管理系统，这里需要描述一个学生的信息。该学生的信息包括学号、姓名、性别、年龄、家庭住址等，这些数据共同说明一个学生的总体情况。</p><p><img src="/img/images/image-20230926153344062.png" alt="image-20230926153344062"></p><p>显然，这些数据类型各不相同，无法使用数组进行统一管理。</p><p><strong>举例2：</strong></p><p>隔壁老王养了两只猫咪。一只名字叫小黄，今年2岁，橘色；另一只叫小黑，今年3岁，黑色。请编写一个程序，当用户输入小猫的名字时，就显示该猫的名字，年龄，颜色。如果用户输入的小猫名错误，则显示老王没有这只猫。</p><p><img src="/img/images/image-20230926154542306.png" alt="image-20230926154542306"></p><p>传统的解决方法</p><p><code>尝试1</code>：单独定义多个变量存储，实现需求。但是，多个变量，不便于数据的管理。</p><p><code>尝试2</code>：使用数组，它是一组具有相同类型的数据的集合。但在编程中，往往还需要一组类型不同的数据，例如猫的名字使用字符串、年龄是int，颜色是字符串，因为数据类型不同，不能用一个数组来存放。</p><p><code>尝试3</code>：C语言提供了结构体。使用结构体，内部可以定义多个不同类型的变量作为其成员。</p><blockquote><p>考研中见的最多的就是指针和结构体结合起来构造结点（如链表的结点、二叉树的结点等）。</p></blockquote><h3 id="1-2-结构体的理解"><a href="#1-2-结构体的理解" class="headerlink" title="1.2 结构体的理解"></a>1.2 结构体的理解</h3><p>C 语言提供了 <code>struct</code>关键字，允许自定义复合数据类型，将不同类型的值组合在一起，这种类型称为结构体（structure）类型。</p><p>C 语言没有其他语言的对象(object)和类(class)的概念，struct 结构很大程度上提供了对象和类的功能。</p><p>比如：</p><img src="/img/images/image-20230811182323712.png" alt="image-20230811182323712" style="zoom: 80%;" /><h3 id="1-3-声明结构体"><a href="#1-3-声明结构体" class="headerlink" title="1.3 声明结构体"></a>1.3 声明结构体</h3><p>构建一个结构体类型的一般格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名&#123;</span> </span><br><span class="line">    数据类型<span class="number">1</span> 成员名<span class="number">1</span>;   <span class="comment">//分号结尾</span></span><br><span class="line">    数据类型<span class="number">2</span> 成员名<span class="number">2</span>; </span><br><span class="line">    ……</span><br><span class="line">    数据类型n 成员名n;</span><br><span class="line">&#125;; <span class="comment">//注意最后有一个分号</span></span><br></pre></td></tr></table></figure><p>举例：学生</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>       <span class="comment">// 定义结构体：学生</span></span><br><span class="line">    <span class="type">int</span> id;           <span class="comment">//学号</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];    <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">char</span> gender;      <span class="comment">//性别</span></span><br><span class="line">    <span class="type">char</span> address[<span class="number">50</span>]; <span class="comment">//家庭住址</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>举例：猫</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];   <span class="comment">//名字</span></span><br><span class="line">    <span class="type">int</span> age;         <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> color[<span class="number">20</span>];  <span class="comment">//颜色</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>举例：人类</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];    <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">char</span> gender;      <span class="comment">//性别</span></span><br><span class="line">    <span class="type">int</span> age;          <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">double</span> weight;    <span class="comment">//体重</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>举例：通讯录</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Contacts</span>&#123;</span>            </span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];          <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> year;               <span class="comment">//年</span></span><br><span class="line">    <span class="type">int</span> month;              <span class="comment">//月</span></span><br><span class="line">    <span class="type">int</span> day;                <span class="comment">//日</span></span><br><span class="line">    <span class="type">char</span> email[<span class="number">100</span>];        <span class="comment">//电子邮箱</span></span><br><span class="line">    <span class="type">char</span> phone_number[<span class="number">15</span>]; <span class="comment">//手机号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>举例：员工</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span> &#123;</span>  </span><br><span class="line">    <span class="type">int</span> id;               <span class="comment">//员工编号 </span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];  <span class="comment">//员工姓名</span></span><br><span class="line">    <span class="type">char</span> gender;  <span class="comment">//员工性别</span></span><br><span class="line">    <span class="type">int</span> age;  <span class="comment">//员工年龄</span></span><br><span class="line">    <span class="type">char</span> address[<span class="number">30</span>];  <span class="comment">//员工住址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-4-声明结构体变量并调用成员"><a href="#1-4-声明结构体变量并调用成员" class="headerlink" title="1.4 声明结构体变量并调用成员"></a>1.4 声明结构体变量并调用成员</h3><p>定义了新的数据类型以后，就可以声明该类型的变量，这与声明其他类型变量的写法是一样的。</p><p><strong>声明结构体变量格式1：</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体类型名称 结构体变量名;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，声明自定义类型的变量时，类型名前面，不要忘记加上 struct 关键字。</p></blockquote><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>;</span></span><br></pre></td></tr></table></figure><p><strong>调用结构体变量的成员：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构体变量名.成员名 [= 常量或变量值]</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>;</span> <span class="comment">//声明结构体变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用结构体成员</span></span><br><span class="line">    stu1.id = <span class="number">1001</span>;</span><br><span class="line">    <span class="comment">//stu1.name = &quot;Tom&quot;; //报错，不能直接通过赋值运算符来给字符数组赋值</span></span><br><span class="line">    <span class="built_in">strcpy</span>(stu1.name, <span class="string">&quot;Tony&quot;</span>);</span><br><span class="line">    stu1.gender = <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(stu1.address, <span class="string">&quot;北京市海淀区五道口&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;id = %d,name = %s,gender = %c,address = %s\n&quot;</span>, </span><br><span class="line">           stu1.id, stu1.name, stu1.gender, stu1.address);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：</p><p>1）先声明了一个 struct Student类型的变量 stu1，这时编译器就会为 stu1 分配内存，接着就可以为 stu1 的不同属性赋值。可以看到，struct 结构的属性通过点（ . ）来表示，比如 id 属性要写成 stu1.id。</p><p>2）字符数组是一种特殊的数组，直接改掉字符数组名的地址会报错，因此不能直接通过赋值运算符来对它进行赋值。你可以使用字符串库函数 <code>strcpy()</code> 来进行字符串的复制操作。</p></blockquote><p><strong>声明结构体变量格式2：</strong> </p><p>除了逐一对属性赋值，也可以使用大括号，一次性对 struct 结构的所有属性赋值。此时，初始化的属性个数最好与结构体中成员个数相同，且成员的先后顺序一一对应。格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 结构体变量=</span>&#123;初始化数据&#125;;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  <span class="type">double</span> price;</span><br><span class="line">  <span class="type">int</span> speed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Car</span> <span class="title">audi</span> =</span> &#123;<span class="string">&quot;audi A6L&quot;</span>, <span class="number">460000.99</span>, <span class="number">175</span>&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果大括号里面的值的数量少于属性的数量，那么缺失的属性自动初始化为 0 。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="type">int</span> score;  <span class="comment">//学生成绩</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span> =</span> &#123;<span class="number">1001</span>, <span class="string">&quot;songhk&quot;</span>, <span class="string">&#x27;M&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, stu.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Score: %d\n&quot;</span>, stu.score);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明结构体变量格式3：</strong> </p><p>方式2中大括号里面的值的顺序，必须与 struct 类型声明时属性的顺序一致。此时，可以为每个值指定属性名。</p><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 结构体变量=</span>&#123;.成员<span class="number">1</span>=xxx,.成员<span class="number">2</span>=yyy,...&#125;;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Car</span> <span class="title">audi</span> =</span> &#123;.speed=<span class="number">175</span>, .name=<span class="string">&quot;audi A6L&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>同样，初始化的属性少于声明时的属性，剩下的那些属性都会初始化为 0 。</p></blockquote><p>声明变量以后，可以修改某个属性的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Car</span> <span class="title">audi</span> =</span> &#123;.speed=<span class="number">175</span>, .name=<span class="string">&quot;audi A6L&quot;</span>&#125;;</span><br><span class="line">audi.speed = <span class="number">185</span>;  <span class="comment">//将 speed 属性的值改成 185</span></span><br></pre></td></tr></table></figure><p><strong>声明结构体变量格式4：</strong> 声明类型的同时定义变量</p><p>struct 的数据类型声明语句与变量的声明语句，可以合并为一个语句。格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 &#123;</span></span><br><span class="line">    成员列表</span><br><span class="line">&#125; 变量名列表;</span><br></pre></td></tr></table></figure><p>举例：同时声明了数据类型 Circle 和该类型的变量 c1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">&#125; c1;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="type">char</span> phone[<span class="number">11</span>];</span><br><span class="line">&#125; emp1, emp2;</span><br></pre></td></tr></table></figure><p><strong>声明结构体变量格式5：</strong> 不指定类型名而直接定义结构体类型变量</p><p>如果类型标识符（比如Student、Circle、Employee等）只用在声明时这一个地方，后面不再用到，那就可以将类型名省略。 该结构体称为<code>匿名结构体</code>。</p><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    成员列表;</span><br><span class="line">&#125; 变量名列表;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="type">char</span> phone[<span class="number">11</span>];</span><br><span class="line">&#125; emp1, emp2;</span><br></pre></td></tr></table></figure><p>struct 声明了一个匿名数据类型，然后又声明了这个类型的两个变量emp1、emp2 。与其他变量声明语句一样，可以在声明变量的同时，对变量赋值。</p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="type">char</span> phone[<span class="number">11</span>];</span><br><span class="line">&#125; emp1 = &#123;<span class="string">&quot;Lucy&quot;</span>, <span class="number">23</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&quot;13012341234&quot;</span>&#125;,</span><br><span class="line">  emp2 = &#123;<span class="string">&quot;Tony&quot;</span>, <span class="number">25</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&quot;13367896789&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>上例在声明变量 emp1 和 emp2 的同时，为它们赋值。</p><p>**声明结构体变量格式6：**使用 typedef 命令</p><p>使用 typedef 可以为 struct 结构指定一个别名，这样使用起来更简洁。</p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cell_phone</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> phone_no;              <span class="comment">//电话号码</span></span><br><span class="line">    <span class="type">double</span> minutes_of_charge;  <span class="comment">//每分钟费用</span></span><br><span class="line">&#125; Phone;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明结构体变量</span></span><br><span class="line">Phone p = &#123;<span class="number">13012341234</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>上例中， Phone 就是 struct cell_phone 的别名。声明结构体变量时，可以省略struct关键字。</p><p>这种情况下，C 语言允许省略 struct 命令后面的类型名。进一步改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明匿名结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> phone_no;</span><br><span class="line">    <span class="type">double</span> minutes_of_charge;</span><br><span class="line">&#125; Phone;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明结构体变量</span></span><br><span class="line">Phone p = &#123;<span class="number">13012341234</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>进一步，在考研中，还会出现如下的声明方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> phone_no;</span><br><span class="line">    <span class="type">double</span> minutes_of_charge;</span><br><span class="line">&#125; Phone,*pPhone;</span><br></pre></td></tr></table></figure><p>这里多了个*pPhone，其实在定义一个结点指针p时，<code>Phone *p;</code> 等价于 <code>pPhone p; </code>，前者的写法类似于int *a、char *b等更方便记忆，不必再加个pPhone p来增加记忆负担。所以在考研中我们不采用这种方法，统一删掉 *pPhone的写法。</p><blockquote><p>说明：</p><p>1、在创建一个结构体变量后，需要给成员赋值。在没有给成员赋值的情况下调用，打印的值是垃圾数据，可能导致程序异常终止。</p><p>2、不同结构体变量的成员是独立的，互不影响，一个结构体变量的成员更改，不影响另外一个。</p></blockquote><h3 id="1-5-举例"><a href="#1-5-举例" class="headerlink" title="1.5 举例"></a>1.5 举例</h3><p><strong>练习：盒子案例</strong></p><p>（1）编程创建一个Box结构体，在其中定义三个成员表示一个立方体的长、宽和高，长宽高可以通过控制台输入。</p><p>（2）定义一个函数获取立方体的体积（volume）。</p><p>（3）创建一个结构体，打印给定尺寸的立方体的体积。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义Box结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> length;</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取立方体体积的函数</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">getVolume</span><span class="params">(<span class="keyword">struct</span> Box box)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> box.length * box.width * box.height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建结构体实例</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Box</span> <span class="title">box</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入长度：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;box.length);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入宽度：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;box.width);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入高度：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;box.height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数获取体积并打印</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;体积为: %.2lf\n&quot;</span>, getVolume(box));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-小-结"><a href="#1-6-小-结" class="headerlink" title="1.6 小 结"></a>1.6 小 结</h3><p>区分三个概念：结构体、结构体变量、结构体变量的成员。</p><ul><li><p>结构体是<strong>自定义的数据类型</strong>，表示的是一种数据类型。</p></li><li><p>结构体变量代表一个具体变量。类比：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num1 ; <span class="comment">// int 是数据类型, 而num1是一个具体的int变量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Car</span> <span class="title">car1</span>;</span> <span class="comment">// Car 是结构体数据类型，而car1是一个Car变量</span></span><br></pre></td></tr></table></figure></li><li><p>Car 就像一个“汽车图纸”，生成出来的具体的一辆辆汽车，就类似于一个个的结构体变量。这些结构体变量都含有相同的成员，将结构体变量的成员比作“零件”，同一张图纸生产出来的零件的作用都是一样的。</p></li></ul><p><img src="/img/images/image-20230812142946911.png" alt="image-20230812142946911"></p><h2 id="2、进一步认识结构体"><a href="#2、进一步认识结构体" class="headerlink" title="2、进一步认识结构体"></a>2、进一步认识结构体</h2><h3 id="2-1-结构体嵌套"><a href="#2-1-结构体嵌套" class="headerlink" title="2.1 结构体嵌套"></a>2.1 结构体嵌套</h3><p>结构体的成员也是变量，那么成员可以是<code>基本数据类型</code>，也可以是<code>数组</code>、<code>指针</code>、<code>结构体</code>等类型 。如果结构体的成员是另一个结构体，这就构成了结构体嵌套。</p><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Name</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> firstName[<span class="number">50</span>];</span><br><span class="line">    <span class="type">char</span> lastName[<span class="number">50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Name</span> <span class="title">name</span>;</span></span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">&#125; stu1;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(stu1.name.firstName, <span class="string">&quot;美美&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(stu1.name.lastName, <span class="string">&quot;韩&quot;</span>);</span><br><span class="line">    <span class="comment">//stu1.age = 18;</span></span><br><span class="line">    <span class="comment">//stu1.gender = &#x27;F&#x27;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//或者</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Name</span> <span class="title">myname</span> =</span> &#123;<span class="string">&quot;美美&quot;</span>,<span class="string">&quot;韩&quot;</span>&#125;;</span><br><span class="line">    stu1.name = myname;</span><br><span class="line">    <span class="comment">//stu1.age = 18;</span></span><br><span class="line">    <span class="comment">//stu1.gender = &#x27;F&#x27;;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span> &#123;</span>    <span class="comment">//声明一个结构体类型 struct Date </span></span><br><span class="line">    <span class="type">int</span> year;    <span class="comment">//年</span></span><br><span class="line">    <span class="type">int</span> month;   <span class="comment">//月</span></span><br><span class="line">    <span class="type">int</span> day;     <span class="comment">//日</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span> &#123;</span> <span class="comment">//声明一个结构体类型 struct Employee</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">birthday</span>;</span> <span class="comment">//成员birthday属于struct Date类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>声明结构体变量并调用成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Employee</span> <span class="title">emp1</span>;</span></span><br><span class="line"></span><br><span class="line">    emp1.id = <span class="number">1001</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(emp1.name,<span class="string">&quot;Tony&quot;</span>);</span><br><span class="line">    emp1.age = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    emp1.birthday.year = <span class="number">2001</span>;</span><br><span class="line">    emp1.birthday.month = <span class="number">3</span>;</span><br><span class="line">    emp1.birthday.day = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：如果成员本身又属一个结构体类型，则要用若干个点（ . ），一级一级地找到最低的一级的成员。比如，<code>emp1.birthday.year</code>。</p><p>赋值的时候还有多种写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//方式1：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Employee</span> <span class="title">emp1</span> =</span> &#123;<span class="number">1001</span>, <span class="string">&quot;Tony&quot;</span>, <span class="number">24</span>, &#123;<span class="number">1999</span>, <span class="number">10</span>, <span class="number">11</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式2：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">birthday</span> =</span> &#123;<span class="number">2001</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Employee</span> <span class="title">emp2</span> =</span> &#123;<span class="number">1002</span>, <span class="string">&quot;Tom&quot;</span>, <span class="number">22</span>, birthday&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式3：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Employee</span> <span class="title">emp3</span> =</span> &#123;</span><br><span class="line">            .id = <span class="number">1003</span>,</span><br><span class="line">            .age = <span class="number">24</span>,</span><br><span class="line">            .name = <span class="string">&quot;Jerry&quot;</span>,</span><br><span class="line">            .birthday = &#123;<span class="number">2001</span>, <span class="number">3</span>, <span class="number">16</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式4：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Employee</span> <span class="title">emp4</span> =</span> &#123;</span><br><span class="line">            .id = <span class="number">1003</span>,</span><br><span class="line">            .age = <span class="number">27</span>,</span><br><span class="line">            .name = <span class="string">&quot;Jerry&quot;</span>,</span><br><span class="line">            .birthday.year = <span class="number">1998</span>,</span><br><span class="line">            .birthday.month = <span class="number">8</span>,</span><br><span class="line">            .birthday.day = <span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例3：自我嵌套</p><p>单链表结构的结点定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;            <span class="comment">//这里默认的是int型，如需其他类型可修改</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>   <span class="comment">//指向Node型变量的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode;</span><br></pre></td></tr></table></figure><p>二叉树结构的结点定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;              <span class="comment">//这里默认的是int型，如需其他类型可修改</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span>        <span class="comment">//指向左孩子结点指针,在后续的二叉树章节中讲解</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span>        <span class="comment">//指向右孩子结点指针,在后续的二叉树章节中讲解</span></span><br><span class="line">&#125; BTNode;</span><br></pre></td></tr></table></figure><h3 id="2-2-结构体占用空间"><a href="#2-2-结构体占用空间" class="headerlink" title="2.2 结构体占用空间"></a>2.2 结构体占用空间</h3><p>结构体占用的存储空间，不是各个属性存储空间的总和。为了计算效率，C 语言的内存占用空间一般来说，都必须是 int 类型存储空间的整数倍。如果 int 类型的存储是4字节，那么 struct 类型的存储空间就总是4的倍数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125; s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(s)); <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 s 的存储空间不是5个字节，而是占据8个字节。a 属性与 b 属性之间有3个字节的“空洞”。</p><h3 id="2-3-结构体变量的赋值操作"><a href="#2-3-结构体变量的赋值操作" class="headerlink" title="2.3 结构体变量的赋值操作"></a>2.3 结构体变量的赋值操作</h3><p>同类型的结构体变量可以使用赋值运算符（ &#x3D; ），赋值给另一个变量，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student1 = student2; <span class="comment">//假设student1和student2已定义为同类型的结构体变量</span></span><br></pre></td></tr></table></figure><p>这时会生成一个<code>全新的副本</code>。系统会分配一块新的内存空间，大小与原来的变量相同，把每个属性都复制过去，即原样生成了一份数据。</p><p>也就是说，结构体变量的传递机制是值传递，而非地址传递。这一点跟数组的赋值不同，使用赋值运算符复制数组，不会复制数据，只是传递地址。</p><p><strong>举例1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">30</span>];</span><br><span class="line">&#125; a = &#123;.name = <span class="string">&quot;Audi A6L&quot;</span>, .price = <span class="number">390000.99</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Car</span> <span class="title">b</span> =</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;a); <span class="comment">//结构体a变量的地址 00007ff75a019020</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;b); <span class="comment">//结构体b变量的地址 000000a6201ffcd0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, a.name);  <span class="comment">//结构体a变量的成员name的地址  00007ff719199028</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, b.name);  <span class="comment">//结构体b变量的成员name的地址  000000c2565ffd88</span></span><br><span class="line"></span><br><span class="line">    a.name[<span class="number">0</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a.name); <span class="comment">// Budi A6L</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, b.name); <span class="comment">// Audi A6L</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，变量 b 是变量 a 的副本，两个变量的值是各自独立的，修改掉 b.name 不影响 a.name 。</p><p>**举例2：**将结构体内的字符数组改为字符指针</p><p>上个例子有个前提，就是 struct 结构的属性必须定义成字符数组，才可以复制数据。如果属性定义成字符指针，结果就不一样了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">&#125; a = &#123;<span class="string">&quot;Audi A6L&quot;</span>, <span class="number">390000.99</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Car</span> <span class="title">b</span> =</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;a); <span class="comment">//结构体a变量的地址 00007ff75a019020</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;b); <span class="comment">//结构体b变量的地址 000000a6201ffcd0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, a.name); <span class="comment">//结构体a变量的成员name的地址  00007ff7d778a000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, b.name); <span class="comment">//结构体b变量的成员name的地址  00007ff7d778a000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中， name 属性变成了一个字符指针，这时 a 赋值给 b ，此时的b变量仍然是新开辟的内存空间。但是，a 和 b的 name 成员保存的指针相同，也就是说两个属性共享同一个”Audi A6L”。</p><p>在C语言中，相同的字符串常量通常只会保存一份，即这些字符串常量共享相同的内存。当你声明多个指针变量并让它们指向相同的字符串常量时，它们实际上都指向相同的内存地址。字符串常量的共享，有助于减小程序的内存占用。</p><blockquote><p>注意：C 语言没有提供比较两个自定义数据结构是否相等的方法，无法用比较运算符（比如 &#x3D;&#x3D; 和 !&#x3D; ）比较两个数据结构是否相等或不等。</p></blockquote><blockquote><p> 【武汉科技大学2019研】已知书籍结构体定义如下，则对结构体变量bk的正确赋值是（　）。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BOOK</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="type">int</span> year, month, day;</span><br><span class="line">  &#125; publish;</span><br><span class="line">&#125; bk; </span><br></pre></td></tr></table></figure><p> A．bk.year＝1998；  bk.month＝11；  bk.day＝11；<br> B．publish.year＝1998；  publish.month＝11；  publish.day＝11；<br> C．year＝1998；  month＝11；  day＝11；<br> D．bk.publish.year＝1998；  bk.publish.month＝11；  bk.publish.day＝11；</p><p> 【答案】D</p><p> 【解析】变量bk是结构体BOOK的一个结构体变量，该变量含有一个成员变量publish，publish也是一个结构体变量，该结构变量含三个成员变量，分别是year、month、day，结构体变量中的成员变量不可直接访问，必须以结构体变量名.成员变量名形式访问，所以只能通过bk.publish.year形式访问到最内层的变量并为其赋值，答案选D。</p></blockquote><h2 id="3、结构体数组"><a href="#3、结构体数组" class="headerlink" title="3、结构体数组"></a>3、结构体数组</h2><h3 id="3-1-对比结构体与数组"><a href="#3-1-对比结构体与数组" class="headerlink" title="3.1 对比结构体与数组"></a>3.1 对比结构体与数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个结构体A</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a ;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">float</span> c;</span><br><span class="line">&#125; A;</span><br><span class="line"><span class="comment">//定义一个结构体变量</span></span><br><span class="line">A a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个数组类型的变量</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">3</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>语句int b[3]；定义了一个数组，名字为b，由3个整型分量组成。而语句A a；可以类似认为定义了一个数组，名字为a，只不过组成a数组的3个分量是不同类型的。对于数组b，b[0]、b[1]、b[2]分别代表数组中第1、第2、第3个同为int类型的元素的值。而结构体a中，a. a、a. b、a. c分别对应于结构体变量a 中第1、第2、第3个元素的值，两者十分相似。</p><p><img src="/img/images/image-20230809143639920.png" alt="image-20230809143639920"></p><p>如果有3个结构体A类型的元素，如何存储呢？使用结构体数组，即：<code>A a[3]</code></p><p>对比：<code>A a[3]</code>和<code>int b[3][3]</code>：</p><p>a数组中的每个元素都是结构型且每个元素都有3个分量，可以把它类比成一个二维数组。例如， <code>int b[3][3]</code>。</p><p><img src="/img/images/image-20230809143915726.png" alt="image-20230809143915726"></p><h3 id="3-2-结构体数组的声明"><a href="#3-2-结构体数组的声明" class="headerlink" title="3.2 结构体数组的声明"></a>3.2 结构体数组的声明</h3><p>**结构体数组：数组元素是结构体变量而构成的数组。**先定义结构体类型，然后用结构体类型定义数组变量。</p><p>**方式1：**先声明一个结构体类型，再用此类型定义结构体数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构体类型 数组名[数组长度];</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span> </span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">pers</span>[3];</span> <span class="comment">//pers是结构体数组名</span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>       <span class="comment">// 定义结构体：学生</span></span><br><span class="line">    <span class="type">int</span> id;           <span class="comment">//学号</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];    <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">char</span> gender;      <span class="comment">//性别</span></span><br><span class="line">    <span class="type">int</span> age;          <span class="comment">//年龄</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stus</span>[10];</span> <span class="comment">//stus是结构体数组名</span></span><br></pre></td></tr></table></figure><p>**方式2：**定义结构体类型的同时，定义数组变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名&#123;</span></span><br><span class="line">成员列表;</span><br><span class="line">&#125; 数组名[数组长度];</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span> </span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125; pers[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span></span><br><span class="line"><span class="type">int</span> year;</span><br><span class="line"><span class="type">int</span> month;</span><br><span class="line"><span class="type">int</span> day;</span><br><span class="line">&#125;dates1[<span class="number">10</span>],dates2[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h3 id="3-3-初始化数组元素"><a href="#3-3-初始化数组元素" class="headerlink" title="3.3 初始化数组元素"></a>3.3 初始化数组元素</h3><p><strong>对应前面的声明方式1：</strong></p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stus</span>[3] =</span> &#123; &#123;<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>,<span class="string">&#x27;M&#x27;</span>, <span class="number">14</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">1002</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">13</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">1003</span>, <span class="string">&quot;Lily&quot;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><img src="/img/images/1689149257847.png" alt="1689149257847" style="zoom:120%;" /><p><strong>对应前面的声明方式2：</strong></p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; pers[<span class="number">3</span>] = &#123;&#123;<span class="string">&quot;Tom&quot;</span>,   <span class="number">12</span>&#125;,</span><br><span class="line">             &#123;<span class="string">&quot;Jerry&quot;</span>, <span class="number">11</span>&#125;,</span><br><span class="line">             &#123;<span class="string">&quot;Lily&quot;</span>,  <span class="number">10</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; pers[] = &#123;&#123;<span class="string">&quot;Tom&quot;</span>,   <span class="number">12</span>&#125;,</span><br><span class="line">             &#123;<span class="string">&quot;Jerry&quot;</span>, <span class="number">11</span>&#125;,</span><br><span class="line">             &#123;<span class="string">&quot;Lily&quot;</span>,  <span class="number">10</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>说明：初始化结构体数组元素时，也可以不指定结构体数组的长度。系统在编译时，会自动根据初始化的值决定结构体数组的长度。</p></blockquote><h3 id="3-4-结构体数组元素的成员的调用"><a href="#3-4-结构体数组元素的成员的调用" class="headerlink" title="3.4 结构体数组元素的成员的调用"></a>3.4 结构体数组元素的成员的调用</h3><p><strong>方式1：使用数组角标方式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构体数组名[下标].成员名</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stus[<span class="number">1</span>].age = <span class="number">23</span>;</span><br></pre></td></tr></table></figure><p><strong>方式2：使用指向数组或数组元素的指针(下节讲)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指针-&gt;成员名</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;age=<span class="number">24</span>;  <span class="comment">//p为指向某个数组元素的指针</span></span><br></pre></td></tr></table></figure><p>举例1：输入一个班级的学生信息(包含id、name、gender、score)，并把学习成绩超过全班平均成绩的学生找出来，输出这部分学生的姓名和成绩。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NAME_LENGTH 20</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[MAX_NAME_LENGTH];</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>[<span class="title">N</span>];</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入学生信息 (ID, 姓名, 性别, 成绩): \n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %19s %c %d&quot;</span>, &amp;stu[i].id, stu[i].name, &amp;stu[i].gender, &amp;stu[i].score);</span><br><span class="line">        sum += stu[i].score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> avg = (<span class="type">double</span>)sum / N; <span class="comment">//计算平均成绩</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;平均成绩为: %.2lf\n&quot;</span>, avg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;高于平均分的学生:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stu[i].score &gt; avg) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%-20s:%d\n&quot;</span>, stu[i].name, stu[i].score);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">请输入学生信息 (ID, 姓名, 性别, 成绩):</span><br><span class="line">1 Tom M 89</span><br><span class="line">请输入学生信息 (ID, 姓名, 性别, 成绩):</span><br><span class="line">2 Jerry F 99</span><br><span class="line">请输入学生信息 (ID, 姓名, 性别, 成绩):</span><br><span class="line">3 Lucy F 56</span><br><span class="line">请输入学生信息 (ID, 姓名, 性别, 成绩):</span><br><span class="line">4 Tony M 66</span><br><span class="line">平均成绩为: 77.50</span><br><span class="line">高于平均分的学生:</span><br><span class="line">Tom                 :89</span><br><span class="line">Jerry               :99</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>举例2：编写一个统计选票的系统，根据先后输入的候选人姓名，统计各人的得票数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span> <span class="comment">//声明结构体类型struct Person</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>]; <span class="comment">//候选人姓名</span></span><br><span class="line">    <span class="type">int</span> count; <span class="comment">//候选人得票数</span></span><br><span class="line">&#125; leader[N] = &#123;&#123;<span class="string">&quot;zhang3&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">               &#123;<span class="string">&quot;li4&quot;</span>,    <span class="number">0</span>&#125;,</span><br><span class="line">               &#123;<span class="string">&quot;wang5&quot;</span>,  <span class="number">0</span>&#125;&#125;; <span class="comment">//定义结构体数组并初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> leader_name[<span class="number">20</span>]; <span class="comment">//定义字符数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你要投票给谁？(zhang3、li4、wang5)：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, leader_name); <span class="comment">//输入所选的候选人姓名</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(leader_name, leader[j].name) == <span class="number">0</span>)&#123;</span><br><span class="line">                leader[j].count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n统计结果:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-10s:%d\n&quot;</span>, leader[i].name, leader[i].count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 【武汉科技大学2019研】对于以下定义，能打印出字母h的语句是（　）。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span> </span><br><span class="line"><span class="type">char</span> title[<span class="number">20</span>];  </span><br><span class="line"><span class="type">int</span> code;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">book</span>[5]＝&#123;</span><span class="string">&quot;Physics&quot;</span>,<span class="number">17</span>,<span class="string">&quot;Math&quot;</span>,<span class="number">18</span>,<span class="string">&quot;English&quot;</span>,<span class="number">20</span>,<span class="string">&quot;History&quot;</span>,<span class="number">18</span>&#125;;</span><br></pre></td></tr></table></figure><p> A．printf（”%c”，book[0].title[1]）；<br> B．printf（”%c”，book[1].title[4]）；<br> C．printf（”%c”，book[2].title[7]）；<br> D．printf（”%c”，book[3].title[6]）；</p><p> 【答案】A</p><p> 【解析】person是一个自定义结构体类型，该结构体含有两个成员变量，分别是一个字符数组和一个int数据，BC选项打印出来的是’\0’；D选项打印出来的是y，只有A打印出来的是h，答案选A。</p></blockquote><h2 id="4、结构体指针"><a href="#4、结构体指针" class="headerlink" title="4、结构体指针"></a>4、结构体指针</h2><h3 id="4-1-结构体指针格式"><a href="#4-1-结构体指针格式" class="headerlink" title="4.1 结构体指针格式"></a>4.1 结构体指针格式</h3><p>结构体指针：<strong>指向结构体变量的指针</strong> （将结构体变量的起始地址存放在指针变量中）</p><p>具体应用场景：①可以指向单一的结构体变量  ②可以用作函数的参数 ③可以指向结构体数组</p><p>定义结构体指针变量格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 *结构体指针变量名;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int num;</span></span><br><span class="line"><span class="comment">//int *num;</span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">50</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">10</span>];</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> *<span class="title">b1</span>;</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">50</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">10</span>];</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">&#125; *b1;</span><br></pre></td></tr></table></figure><p>说明：变量 b1 是一个指针，指向的数据是 struct Book 类型的实例。</p><h3 id="4-2-结构体传参"><a href="#4-2-结构体传参" class="headerlink" title="4.2 结构体传参"></a>4.2 结构体传参</h3><p>如果将 struct 变量传入函数，函数内部得到的是一个原始值的副本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> *address;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addAge</span><span class="params">(<span class="keyword">struct</span> Person per)</span> &#123;</span><br><span class="line">    per.age = per.age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span> =</span> &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>, <span class="string">&quot;北京市海淀区&quot;</span>&#125;;</span><br><span class="line">    addAge(p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age = %d\n&quot;</span>, p1.age); <span class="comment">// 输出 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 addAge() 要求传入一个 struct 变量 per，但实际上传递的是 struct 变量p1的<code>副本</code>，改变副本影响不到函数外部的原始数据。</p><p>通常情况下，开发者希望传入函数的是同一份数据，函数内部修改数据以后，会反映在函数外部。而且，传入的是同一份数据，也有利于提高程序性能。这时就需要将 struct 变量的指针传入函数，通过指针来修改 struct 属性。如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> *address;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addAge</span><span class="params">(<span class="keyword">struct</span> Person *per)</span> &#123;   <span class="comment">//说明1</span></span><br><span class="line">    (*per).age = (*per).age + <span class="number">1</span>;    <span class="comment">//说明2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span> =</span> &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>, <span class="string">&quot;北京市海淀区&quot;</span>&#125;;</span><br><span class="line">    addAge(&amp;p1);                    <span class="comment">//说明3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age = %d\n&quot;</span>, p1.age);   <span class="comment">// 说明4：输出 21</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>说明1：per 是 struct 结构的指针，调用函数时传入的是指针。</p></li><li><p>说明2：函数内部必须使用 <code>(*per).age</code> 的写法，从指针拿到 struct 结构本身。因为运算符优先级问题，不能写成<code>*per.age</code>，会将per.age看成是一个指针，然后取其值。</p></li><li><p>说明3：结构体类型跟数组不一样，类型标识符本身并不是指针，所以传入时，指针必须写成 &amp;p1。</p></li><li><p>说明4： addAge() 内部对 struct 结构的操作，就会反映到函数外部。</p></li></ul><p><strong>练习1：</strong></p><p>（1）编写一个Dog结构体，包含name(char[10])、age(int)、weight(double)属性</p><p>（2）编写一个say函数，返回字符串，方法返回信息中包含所有成员值。</p><p>（3）在main方法中，创建Dog结构体变量，调用say函数，将调用结果打印输出。</p><p>写法1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Dog结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];  <span class="comment">//或者  char * name;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义say函数，返回包含所有成员值的字符串</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">say</span><span class="params">(<span class="keyword">struct</span> Dog dog)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> info[<span class="number">100</span>]; <span class="comment">// 静态数组用于存储结果,此数组生命周期会持续到整个程序运行结束。</span></span><br><span class="line">    <span class="built_in">sprintf</span>(info, <span class="string">&quot;Name: %s, Age: %d, Weight: %.2lf&quot;</span>, dog.name, dog.age, dog.weight);</span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Dog结构体变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> <span class="title">myDog</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(myDog.name, <span class="string">&quot;大黄&quot;</span>);</span><br><span class="line">    myDog.age = <span class="number">3</span>;</span><br><span class="line">    myDog.weight = <span class="number">12.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用say函数，打印结果</span></span><br><span class="line">    <span class="type">char</span>* result = say(myDog);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;info = %s\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，sprintf() 函数是C标准库中的一个函数，它用于将格式化的数据写入一个字符数组(字符串)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sprintf(char *str, const char *format, ...);</span><br><span class="line">&gt; str：是一个字符数组，用于存储格式化后的字符串。</span><br><span class="line">&gt; format：是格式化字符串，包含了要输出的文本以及格式说明符，就像 printf() 函数中的格式字符串一样。</span><br><span class="line">&gt; ...：是可变参数，用于提供要格式化的数据。</span><br></pre></td></tr></table></figure><p>顺便看一个问题，如果say()函数如下声明，请问main()中打印dog.name会是多少呢？为什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">say</span><span class="params">(<span class="keyword">struct</span> Dog dog)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> info[<span class="number">100</span>]; <span class="comment">// 静态数组用于存储结果,此数组生命周期会持续到整个程序运行结束。</span></span><br><span class="line">    <span class="built_in">sprintf</span>(info, <span class="string">&quot;Name: %s, Age: %d, Weight: %.2lf&quot;</span>, dog.name, dog.age, dog.weight);</span><br><span class="line">    <span class="built_in">strcpy</span>(dog.name, <span class="string">&quot;小花&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Dog结构体变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> <span class="title">myDog</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(myDog.name, <span class="string">&quot;大黄&quot;</span>);</span><br><span class="line">    myDog.age = <span class="number">3</span>;</span><br><span class="line">    myDog.weight = <span class="number">12.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用say函数，打印结果</span></span><br><span class="line">    <span class="type">char</span>* result = say(myDog);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;info = %s\n&quot;</span>, result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name = %s&quot;</span>, myDog.name);  <span class="comment">//大黄</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C语言中，函数参数是按值传递的，这意味着 say 函数接受的是 dog 结构体的一个副本，而不是原始的 dog 结构体。因此，在 say 函数内部对 dog 结构体的修改不会影响到 main 函数中的原始结构体。</p><p>虽然在 say 函数内部将 dog.name 设置为 “小花”，但这只会影响 say 函数内的副本，而不会影响 main 函数中的 dog 结构体。所以，最后打印 dog.name 时输出的是 “大黄”，而不是 “小花”。</p><p>写法2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Dog结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];  <span class="comment">//或者  char * name;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义say函数，返回包含所有成员值的字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">say</span><span class="params">(<span class="keyword">struct</span> Dog *dog)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> info[<span class="number">100</span>]; <span class="comment">// 静态数组用于存储结果,此数组生命周期会持续到整个程序运行结束。</span></span><br><span class="line">    <span class="built_in">sprintf</span>(info, <span class="string">&quot;Name: %s, Age: %d, Weight: %.2lf&quot;</span>, (*dog).name, (*dog).age, (*dog).weight);</span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Dog结构体变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> <span class="title">myDog</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(myDog.name, <span class="string">&quot;大黄&quot;</span>);</span><br><span class="line">    myDog.age = <span class="number">3</span>;</span><br><span class="line">    myDog.weight = <span class="number">12.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用say函数，打印结果</span></span><br><span class="line">    <span class="type">char</span> *result = say(&amp;myDog);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;info = %s\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>练习2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, <span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体传参</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">(<span class="keyword">struct</span> S s)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体地址传参</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="keyword">struct</span> S *ps)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*ps).num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    print1(s);     <span class="comment">//传结构体</span></span><br><span class="line">    print2(&amp;s);    <span class="comment">//传地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从性能开销角度考虑，上面的 print1 和 print2 函数哪个好些？</p><p>答案：print2函数。函数传参的时候，参数是需要压栈的。如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。（考研中定义的结点作为形参时一定要注意考虑此问题）</p><blockquote><p>结论：结构体传参的时候，建议传结构体的地址。</p></blockquote><p><strong>练习3：景区门票</strong></p><p>一个景区根据游客的年龄收取不同价格的门票。</p><p>（1）请编写游客结构体（Visitor），包含姓名，年龄，应付票价</p><p>（2）编写函数ticket()，根据年龄段决定能够购买的门票价格并输出。</p><p>​          规则：年龄&gt;&#x3D;18，门票为20元，其它情况免费。</p><p>（3）可以循环从控制台输入名字和年龄，打印门票收费情况，如果名字输入n，则退出程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Visitor</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;  <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> age;     <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">double</span> pay;  <span class="comment">//应付票价</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写函数处理业务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ticket</span><span class="params">(<span class="keyword">struct</span> Visitor *visitor)</span> &#123;</span><br><span class="line">    <span class="comment">//判断</span></span><br><span class="line">    <span class="keyword">if</span> ((*visitor).age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">        (*visitor).pay = <span class="number">20</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (*visitor).pay = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//创建结构体变量(创建一个游客)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Visitor</span> <span class="title">visitor</span>;</span></span><br><span class="line">    <span class="comment">//循环的输入名字和年龄</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入游客名字(输入n退出程序):&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, visitor.name);</span><br><span class="line">        <span class="comment">//判断如果名字输入 n ,则退出程序</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;n&quot;</span>, visitor.name)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入游客年龄:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;visitor.age);</span><br><span class="line">        <span class="comment">//调用函数 ticket，获取应付的票价</span></span><br><span class="line">        ticket(&amp;visitor);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该游客应付票价=%.2lf\n&quot;</span>, visitor.pay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;退出程序&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-操作符"><a href="#4-3-操作符" class="headerlink" title="4.3 -&gt; 操作符"></a>4.3 -&gt; 操作符</h3><p>前面例子中，<code>(*per).age</code> 的写法很麻烦，C 语言就引入了一个新的箭头运算符（ <code>-&gt;</code> ），可以从结构体指针上直接获取属性，大大增强了代码的可读性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">addAge</span><span class="params">(<span class="keyword">struct</span> Person * per)</span> &#123;</span><br><span class="line">    per-&gt;age = per-&gt;age + <span class="number">1</span>;  <span class="comment">//使用结构体指针访问指向对象的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//打印结构体信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s</span> =</span> &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>, <span class="string">&#x27;M&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式1：.为结构成员访问操作符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name = %s,age = %d,gender = %c\n&quot;</span>, s.name, s.age, s.gender);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">ps</span> =</span> &amp;s;</span><br><span class="line">    <span class="comment">//方式2：.为结构成员访问操作符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name = %s,age = %d,gender = %c\n&quot;</span>, (*ps).name, (*ps).age, (*ps).gender);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式3：-&gt;操作符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name = %s,age = %d,gender = %c\n&quot;</span>, ps-&gt;name, ps-&gt;age, ps-&gt;gender);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果指针变量p指向一个结构体变量stu，以下3种用法等价：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">① stu.成员名    stu.num</span><br><span class="line">② (*p).成员名   (*p).num</span><br><span class="line">③ p-&gt;成员名     p-&gt;num</span><br></pre></td></tr></table></figure><h3 id="4-4-指向结构体数组的指针"><a href="#4-4-指向结构体数组的指针" class="headerlink" title="4.4 指向结构体数组的指针"></a>4.4 指向结构体数组的指针</h3><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">per</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">arr</span>[5];</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> *<span class="title">p</span>,*<span class="title">q</span>;</span></span><br><span class="line"></span><br><span class="line">    p = &amp;per;  <span class="comment">//指向单个结构体变量</span></span><br><span class="line">    q = arr;   <span class="comment">//指向结构体数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">&#125; stu[<span class="number">3</span>] = &#123;&#123;<span class="number">1001</span>, <span class="string">&quot;Tom&quot;</span>,   <span class="string">&#x27;M&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1002</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="string">&#x27;M&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1003</span>, <span class="string">&quot;Lily&quot;</span>,  <span class="string">&#x27;F&#x27;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式1：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%10s%3c\n&quot;</span>, stu[i].id, stu[i].name, stu[i].gender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式2：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span> =</span> stu;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%10s%3c\n&quot;</span>, p[i].id, p[i].name, p[i].gender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式3：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">q</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (q = stu; q &lt; stu + <span class="number">3</span>; q++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%10s%3c\n&quot;</span>, q-&gt;id, q-&gt;name, q-&gt;gender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【中央财经大学2018研】若有以下说明和语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> &#123;</span></span><br><span class="line"> <span class="type">int</span> no;</span><br><span class="line"> <span class="type">char</span> *name;</span><br><span class="line">&#125; work, *p = &amp;work; </span><br></pre></td></tr></table></figure><p>则以下引用方式不正确的是（　）。<br>A．work.no<br>B．(*p).no<br>C．p-&gt;no<br>D．work-&gt;no</p><p>【答案】D</p><p>【解析】结构体变量访问成员变量的引用方式采用“.”，而结构体指针采用“-&gt;”，因此AC是正确的，B项中*p表示结构体变量，因此可以用“.”，所以答案选择D。</p></blockquote><h2 id="5、结构体在数据结构中的应用"><a href="#5、结构体在数据结构中的应用" class="headerlink" title="5、结构体在数据结构中的应用"></a>5、结构体在数据结构中的应用</h2><h3 id="5-1-声明结点的结构体"><a href="#5-1-声明结点的结构体" class="headerlink" title="5.1 声明结点的结构体"></a>5.1 声明结点的结构体</h3><p>链表是一种动态的数据存储结构（非固定长度），链表的基本单位是<code>结点(node)</code>，同一链表的所有结点具有相同的数据类型。而结点使用<code>结构体</code>类型进行定义。</p><p>一个链表结点包括数据域和指针域两部分：数据域存储需要处理的数据、指针域存储下一个结点的位置。</p><p><img src="/img/images/1689149897740.png" alt="1689149897740"></p><p>单链表结构的结点定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">//这里默认的是int型，如需其他类型可修改</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  <span class="comment">//指向Node型变量的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode;</span><br></pre></td></tr></table></figure><p>二叉树结构的结点定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;                     <span class="comment">//这里默认的是int型，如需其他类型可修改</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span>        <span class="comment">//指向左孩子结点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span>        <span class="comment">//指向右孩子结点指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;                     <span class="comment">//这里默认的是int型，如需其他类型可修改</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span>        <span class="comment">//指向左孩子结点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span>        <span class="comment">//指向右孩子结点指针</span></span><br><span class="line">&#125; BTNode;</span><br></pre></td></tr></table></figure><h3 id="5-2-声明结点变量"><a href="#5-2-声明结点变量" class="headerlink" title="5.2 声明结点变量"></a>5.2 声明结点变量</h3><p>这里不需要事先说明链表所包括的结点个数，新数据到达时创建结点变量即可。</p><p>以创建二叉树结点为例，方式①：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BTNode bt1;</span><br></pre></td></tr></table></figure><p>方式②：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BTNode *bt;</span><br><span class="line">bt = (BTNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (BTNode));<span class="comment">//此句要熟练掌握</span></span><br></pre></td></tr></table></figure><p>方式①中只用一句就制作了一个结点，而方式②中需要两句，使用了系统已有的函数malloc()申请新结点所需内存空间，比①要烦琐。</p><p>②的执行过程为：先定义一个结点的指针bt，然后用函数malloc()来<code>动态申请</code>一个结点的内存空间，接着让指针 bt 指向这片内存空间，这样就完成了一个结点变量的创建。后续不需要数据时，删除结点，释放空间（使用<code>free(bt)</code>释放）即可。</p><h3 id="5-3-两种方式对比"><a href="#5-3-两种方式对比" class="headerlink" title="5.3 两种方式对比"></a>5.3 两种方式对比</h3><p>对比1：是否可以重新赋值</p><blockquote><p>②中的bt是个指针型变量，用来存储刚创建好的结点的地址。因bt是变量，虽然现在bt指向了刚生成的结点，但是在以后必要的时候bt可以离开这个结点转而指向其他结点。而①则不行，①中的bt1就是某个结点的名字，一旦定义好，它就不能脱离这个结点了。</p><p>结论：②比①更灵活，因此②用得多。</p></blockquote><p>对比2：①和②中的BT取分量的操作也是不同的。比如，想取其data 域的值赋给x。</p><p>对于①，用结构体变量直接取分量，其操作用<code>“.”</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = bt1.data;</span><br></pre></td></tr></table></figure><p>对于②，用指向结构体变量的指针来取分量，其操作用<code>“-&gt;”</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = bt-&gt;data;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="type">int</span> x = (*bt).data; <span class="comment">//这里的()不要省略</span></span><br></pre></td></tr></table></figure><blockquote><p>考研数据结构中所有类型结点的内存分配中使用最多的就是方式② ，即使用函数malloc()来完成，模式固定，务必记忆。</p></blockquote><p><strong>注意点</strong></p><p>可能会有人认可如下的两种简便写法。虽然这种写法简单，但是在一些纯C编译器中是不通过的，如果你所报考的目标学校严格要求用纯C语言来写程序，则不能这样写结构体定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表结点：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树结点：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    BTNode *lchild;</span><br><span class="line">    BTNode *rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-4-malloc-模板"><a href="#5-4-malloc-模板" class="headerlink" title="5.4 malloc()模板"></a>5.4 malloc()模板</h3><p>模板：（当需要制作一个新结点时，只要把结点结构型的名称填入括号中的“类型”处即可）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型 *p;</span><br><span class="line">p = (类型 *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(类型));  <span class="comment">//将=右边创建的结点的地址赋给p</span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    BTNode *newNode;</span><br><span class="line">    newNode = (BTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还可以一次申请一组结点，可以看做是动态申请数组空间的方法。如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = (<span class="type">int</span> *) <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>这样就申请了一个由指针p所指的( p指向数组中第一个元素的地址)元素为int 型的、长度为n 的动态数组。取元素时和一般的数组(静态数组)一样，如取第二个元素，则可写成p[1]。</p><h3 id="5-5-举-例"><a href="#5-5-举-例" class="headerlink" title="5.5 举 例"></a>5.5 举 例</h3><p>在考研的数据结构中，只需要熟练掌握以上两种结点(链表、二叉树)的定义方法，其他结点都是由这两种衍生而来的。</p><p>举例：定义结构体，表示学生结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StudentNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建多个结点，彼此构成链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StudentNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StudentNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StuNode;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    StuNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成一个三个节点的列表 &#123;1001,&quot;Tom&quot;&#125; -&gt; &#123;1002,&quot;Jerry&quot;&#125; -&gt; &#123;1003,&quot;Lily&quot;&#125;</span></span><br><span class="line">    head = (StuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StuNode));</span><br><span class="line">    head-&gt;id = <span class="number">1001</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(head-&gt;name, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">    StuNode *p = (StuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StuNode));</span><br><span class="line">    p-&gt;id = <span class="number">1002</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">    head-&gt;next = p;</span><br><span class="line"></span><br><span class="line">    p = (StuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StuNode));</span><br><span class="line">    p-&gt;id = <span class="number">1003</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">&quot;Lily&quot;</span>);</span><br><span class="line">    head-&gt;next-&gt;next = p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    StuNode *cur;</span><br><span class="line">    <span class="keyword">for</span> (cur = head; cur != <span class="literal">NULL</span>; cur = cur-&gt;next) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;id = %d,name = %s\n&quot;</span>, cur-&gt;id, cur-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构成如下图的链表：</p><img src="/img/images/image-20230809144927740.png" alt="image-20230809144927740" style="zoom:80%;" /><p>为了准确定位第一个结点，每个链表要有一个表头指针，从第一个结点开始，沿指针链遍历链表中的所有结点。</p><h2 id="6、共用体类型-union"><a href="#6、共用体类型-union" class="headerlink" title="6、共用体类型(union)"></a>6、共用体类型(union)</h2><h3 id="6-1-共用体概述"><a href="#6-1-共用体概述" class="headerlink" title="6.1 共用体概述"></a>6.1 共用体概述</h3><p>有时需要一种数据结构，不同的场合表示不同的数据类型。比如，如果只用一种数据结构表示学生的“成绩”，这种结构就需要有时是整数（80、90），有时是字符（’A’、’B’），又有时是浮点数（80.5、60.5）。</p><p>**C 语言提供了共用体类型(Union 结构)，用来自定义可以灵活变更的数据结构。**它内部可以包含各种属性，但同一时间只能有一个属性，因为所有属性都保存在同一个内存地址，后面写入的属性会覆盖前面的属性。这样做的最大好处是<code>节省内存空间</code>。</p><p>“共用体”与“结构体”的定义形式相似，但它们的含义是不同的。</p><ul><li>结构体变量所占内存长度是各成员占的内存长度之和；每个成员分别占有其自己的内存单元。</li><li>共用体变量所占的内存长度等于最长的成员的长度；几个成员共用一个内存区。</li></ul><h3 id="6-2-声明共用体"><a href="#6-2-声明共用体" class="headerlink" title="6.2 声明共用体"></a>6.2 声明共用体</h3><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体类型名称&#123;</span></span><br><span class="line">    数据类型 成员名<span class="number">1</span>;</span><br><span class="line">    数据类型 成员名<span class="number">2</span>;</span><br><span class="line">    …</span><br><span class="line">    数据类型 成员名n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> m;</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上例中， union 命令定义了一个包含三个属性的数据类型 Data。虽然包含三个属性，但是同一时间只能取到一个属性。最后赋值的属性，就是可以取到值的那个属性。</p><h3 id="6-3-声明共用体变量"><a href="#6-3-声明共用体变量" class="headerlink" title="6.3 声明共用体变量"></a>6.3 声明共用体变量</h3><p>方式1：先定义共用体类型，再定义共用体变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> m;</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明共用体变量</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">a</span>, <span class="title">b</span>;</span></span><br></pre></td></tr></table></figure><p>方式2：定义共用体类型的同时定义共用体变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> m;</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; a, b;</span><br></pre></td></tr></table></figure><p>方式3：直接定义共用体类型变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> m;</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; a, b;</span><br></pre></td></tr></table></figure><p>以共用体变量a为例，它由3个成员组成，分别是m、x和c，编译时，系统会按照最长的成员为它分配内存，由于成员x的长度最长，它占4个字节，所以共用体变量a的内存空间也为4个字节。</p><img src="/img/images/image-20230809144244532.png" alt="image-20230809144244532" style="zoom:67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> m;</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; a, b;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a));  <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-调用共同体变量的成员"><a href="#6-4-调用共同体变量的成员" class="headerlink" title="6.4 调用共同体变量的成员"></a>6.4 调用共同体变量的成员</h3><p><strong>正确的方式</strong></p><p>方式1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">a</span>;</span></span><br><span class="line">a.c = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>方式2：声明共同体变量的同时，给任一成员赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">a</span> =</span> &#123;.c = <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p>方式3：声明共同体变量的同时，给首成员赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">a</span> =</span> &#123;<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意，方式3不指定成员名，所以只能为第一个成员进行赋值。</p></blockquote><p><strong>错误的方式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">a</span> =</span> &#123;<span class="number">1</span>,<span class="number">1.5</span>,<span class="string">&#x27;a&#x27;</span>&#125;;  <span class="comment">//错误的</span></span><br></pre></td></tr></table></figure><p><strong>后续操作</strong></p><p>执行完上面的代码以后， 另外取其它属性取不到值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">a</span> =</span> &#123;.c = <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c is %i\n&quot;</span>, a.c); <span class="comment">// c is 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is %f\n&quot;</span>, a.x); <span class="comment">// 未定义，x is 0.000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要让 a.x属性可以取到值，就要先为它赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">a</span> =</span> &#123;.c = <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c is %i\n&quot;</span>, a.c); <span class="comment">// c is 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is %f\n&quot;</span>, a.x); <span class="comment">// 未定义，x is 0.000000</span></span><br><span class="line"></span><br><span class="line">    a.x = <span class="number">0.5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is %f\n&quot;</span>, a.x); <span class="comment">// x is 0.500000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c is %i\n&quot;</span>, a.c); <span class="comment">// c is 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦为其他属性赋值，原先可以取到值的 a.c 属性就不再有效了。除了这一点，Union 结构的其他用法与 Struct 结构，基本上是一致的。</p><h3 id="6-5-操作符"><a href="#6-5-操作符" class="headerlink" title="6.5 -&gt;操作符"></a>6.5 -&gt;操作符</h3><p>Union 结构也支持指针运算符 -&gt; 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">evaluation</span> &#123;</span> <span class="comment">//评价</span></span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">    <span class="type">char</span> level;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">evaluation</span> <span class="title">e</span>;</span></span><br><span class="line">    e.score = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">evaluation</span> *<span class="title">p</span>;</span></span><br><span class="line">    p = &amp;e;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;score); <span class="comment">// 85</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中， p 是 e 的指针，那么 p-&gt;score等同于 e.score。</p><p>了解：Union指针与它的属性有关，当前哪个属性能够取到值，它的指针就是对应的数据类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">&#125; x;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    x.a = <span class="number">12</span>;</span><br><span class="line">    <span class="type">int</span> *p1 = (<span class="type">int</span> *) &amp;x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x.a);  <span class="comment">// 12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p1); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line">    x.b = <span class="number">3.141592</span>;</span><br><span class="line">    <span class="type">float</span> *p2 = (<span class="type">float</span> *) &amp;x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, x.b);  <span class="comment">// 3.141592</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, *p2); <span class="comment">// 3.141592</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中， &amp;x 是 foo 结构的指针，它的数据类型完全由当前赋值的属性决定。</p><h3 id="6-6-补充说明"><a href="#6-6-补充说明" class="headerlink" title="6.6 补充说明"></a>6.6 补充说明</h3><ul><li><p>不能对共用体变量名赋值，也不能企图引用变量名来得到一个值。只能引用共用体变量中的成员。</p></li><li><p>C99允许同类型的共用体变量互相赋值。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.i <span class="comment">//引用共用体变量中的整型变量i</span></span><br><span class="line">a.ch <span class="comment">//引用共用体变量中的字符变量ch</span></span><br><span class="line">a.f <span class="comment">//引用共用体变量中的实型变量f</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);   <span class="comment">//错误的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a.i); <span class="comment">//正确的</span></span><br></pre></td></tr></table></figure><ul><li>C99允许用共用体变量作为函数参数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = a; <span class="comment">//a和b是同类型的共用体变量，合法</span></span><br></pre></td></tr></table></figure><ul><li>共用体类型可以出现在结构体类型定义中，也可以定义共用体数组。反之，结构体也可以出现在共用体类型定义中，数组也可以作为共用体的成员。</li></ul><h3 id="6-7-练习"><a href="#6-7-练习" class="headerlink" title="6.7 练习"></a>6.7 练习</h3><p>现有一张关于学生信息和教师信息的表格。</p><p>学生信息包括姓名、编号、性别、职业、分数；</p><p>教师的信息包括姓名、编号、性别、职业、教学科目。</p><p>请看下面的表格，请使用共用体编程完成。</p><table><thead><tr><th>name</th><th>id</th><th>gender</th><th>profession</th><th>score&#x2F;course</th></tr></thead><tbody><tr><td>孙悟空</td><td>12345</td><td>男(m)</td><td>学生(s)</td><td>89.5</td></tr><tr><td>菩提祖师</td><td>1001</td><td>男(m)</td><td>老师(t)</td><td>math</td></tr><tr><td>孙尚香</td><td>54321</td><td>女(f)</td><td>学生(s)</td><td>92.0</td></tr><tr><td>诸葛亮</td><td>34567</td><td>男(m)</td><td>老师(t)</td><td>english</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL 2 <span class="comment">//人员总数</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> gender; <span class="comment">//性别  m-&gt;男  f-&gt;女</span></span><br><span class="line">    <span class="type">char</span> profession;<span class="comment">//职业 s-&gt;学生  t-&gt;老师</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">float</span> score;</span><br><span class="line">        <span class="type">char</span> course[<span class="number">20</span>];</span><br><span class="line">    &#125; sc; <span class="comment">//sc 是一个共用体变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">persons</span>[<span class="title">TOTAL</span>];</span>  <span class="comment">//定义一个结构体数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入人员信息</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TOTAL; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input info: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d %c %c&quot;</span>, persons[i].name, &amp;(persons[i].id), &amp;(persons[i].gender), &amp;(persons[i].profession));</span><br><span class="line">        <span class="keyword">if</span> (persons[i].profession == <span class="string">&#x27;s&#x27;</span>) &#123; <span class="comment">//如果是学生</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请输入学生成绩：&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;persons[i].sc.score);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果是老师</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请输入老师课程：&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, persons[i].sc.course);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出人员信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nName\tid\tgender\tProfession\tScore/Course\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TOTAL; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (persons[i].profession == <span class="string">&#x27;s&#x27;</span>) &#123; <span class="comment">//如果是学生</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\t%c\t%c\t\t%f\n&quot;</span>, persons[i].name,</span><br><span class="line">                   persons[i].id, persons[i].gender, persons[i].profession, persons[i].sc.score);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果是老师</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\t%c\t%c\t\t%s\n&quot;</span>, persons[i].name,</span><br><span class="line">                   persons[i].id, persons[i].gender, persons[i].profession, persons[i].sc.course);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、typedef-的使用-熟悉"><a href="#7、typedef-的使用-熟悉" class="headerlink" title="7、typedef 的使用(熟悉)"></a>7、typedef 的使用(熟悉)</h2><h3 id="7-1-为什么使用typedef"><a href="#7-1-为什么使用typedef" class="headerlink" title="7.1 为什么使用typedef"></a>7.1 为什么使用typedef</h3><p>C语言允许为一个数据类型起一个新的别名，就像给人起“绰号”一样。</p><p>起别名的目的不是为了提高程序运行效率，而是为了<code>编码方便</code>。例如，有一个结构体的名字是 student，定义一个结构体变量stu1，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>;</span></span><br></pre></td></tr></table></figure><p>struct 看起来就是多余的，但不写又会报错。如果为 struct student起了一个别名 Student，书写起来就简单了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student stu1;</span><br></pre></td></tr></table></figure><p>这种写法更加简练，意义也非常明确，不管是在标准头文件中还是以后的编程实践中，都会大量使用这种别名。</p><h3 id="7-2-使用格式"><a href="#7-2-使用格式" class="headerlink" title="7.2 使用格式"></a>7.2 使用格式</h3><p>用typedef声明数组类型、指针类型，结构体类型、共用体类型等，使得编程更加方便。</p><p><strong>1、为某个基本类型起别名</strong></p><p>typedef 命令用来为某个类型起别名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 类型名 别名;</span><br></pre></td></tr></table></figure><blockquote><p>习惯上，常把用typedef声明的类型名的第1个字母用大写表示，以便与系统提供的标准类型标识符相区别。</p></blockquote><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Integer;  <span class="comment">//用Integer作为int类型别名，作用与int相同</span></span><br><span class="line">Integer a, b;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><code>Integer a, b;</code>等同于<code>int a, b;</code>。</p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> Byte;  <span class="comment">//为类型 unsign char 起别名 Byte</span></span><br><span class="line">Byte c = <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure><p>注意：使用 typedef 可以为基本类型一次起多个别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> chocolate, doughnut, mushroom; <span class="comment">//一次性为 int 类型起了三个别名</span></span><br></pre></td></tr></table></figure><p><strong>2、为结构体、共用体起别名</strong></p><p>为 struct、union等命令定义的复杂数据结构创建别名，从而便于引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treenode</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treenode</span>* <span class="title">Tree</span>;</span>  <span class="comment">//Tree 为 struct treenode* 的别名</span></span><br></pre></td></tr></table></figure><p>typedef 也可以与 struct 定义数据类型的命令写在一起。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">animal</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  <span class="type">int</span> legs;</span><br><span class="line">  <span class="type">int</span> speed;</span><br><span class="line">&#125; Animal;</span><br></pre></td></tr></table></figure><p>上例中，自定义数据类型时，同时使用 typedef 命令，为 struct animal 起了一个别名 Animal 。</p><p>这种情况下，C 语言允许省略 struct 命令后面的类型名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  <span class="type">int</span> legs;</span><br><span class="line">  <span class="type">int</span> speed;</span><br><span class="line">&#125; Animal;</span><br></pre></td></tr></table></figure><p>上例相当于为一个匿名的数据类型起了别名 Animal 。进而：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用typedef之前</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">animal</span> <span class="title">dog</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用typedef之后</span></span><br><span class="line">Animal dog;</span><br></pre></td></tr></table></figure><p>再举例：typedef 命令可以为 union 数据类型起别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> count;</span><br><span class="line">  <span class="type">float</span> weight;</span><br><span class="line">  <span class="type">float</span> volume;</span><br><span class="line">&#125; quantity;</span><br></pre></td></tr></table></figure><p>上例中， union 命令定义了一个包含三个属性的数据类型， typedef 命令为它起别名为quantity 。</p><p><strong>3、为指针起别名</strong></p><p>typedef 可以为指针起别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* intptr;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">intptr x = &amp;a;</span><br></pre></td></tr></table></figure><p>上例中， intptr 是 int* 的别名。不过，使用的时候要小心，这样不容易看出来，变量 x 是一个指针类型。</p><p>再举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* String;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * str1 = <span class="string">&quot;hello&quot;</span>; <span class="comment">//之前的写法</span></span><br><span class="line">String str2 = <span class="string">&quot;hello&quot;</span>; <span class="comment">//现在的写法</span></span><br></pre></td></tr></table></figure><p>为字符指针起别名为 String，以后使用 String声明变量时，就可以轻易辨别该变量是字符串。</p><p><strong>4、为数组类型起别名</strong></p><p>typedef 也可以用来为数组类型起别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> five_ints[<span class="number">5</span>];</span><br><span class="line">five_ints x = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//举例2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Num[<span class="number">100</span>]; <span class="comment">//声明Num为整型数组类型名</span></span><br><span class="line">Num a; <span class="comment">//定义a为整型数组名，它有100个元素</span></span><br></pre></td></tr></table></figure><p>上例中， five_ints 是一个数组类型。我们把原有的<code>int [5]</code>看做是数组的类型。</p><p>举例：指针数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*PTR_TO_ARR)</span>[4];</span><br></pre></td></tr></table></figure><p>表示 PTR_TO_ARR 是类型<code>int * [4]</code>的别名，它是一个二维数组指针类型。接着可以使用 PTR_TO_ARR 定义二维数组指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTR_TO_ARR p1, p2;</span><br></pre></td></tr></table></figure><p><strong>5、为函数起别名</strong></p><p>typedef 为函数起别名的写法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="title function_">char</span> <span class="params">(*fp)</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>类型别名 fp 是一个指针，代表函数 signed char (*)(void) 。</p><p>再举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*PTR_TO_FUNC)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">PTR_TO_FUNC pfunc;</span><br></pre></td></tr></table></figure><h3 id="7-3-举-例"><a href="#7-3-举-例" class="headerlink" title="7.3 举 例"></a>7.3 举 例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">3</span>][<span class="number">30</span>] = &#123;<span class="string">&quot;尚硅谷教育&quot;</span>, <span class="string">&quot;www.atguigu.com&quot;</span>, <span class="string">&quot;010-56253825&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(*PTR_FUNC)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">char</span> <span class="params">(*PTR_ARR)</span>[30];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用函数指针</span></span><br><span class="line">    <span class="type">int</span> (*add_ptr)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">    add_ptr = &amp;add;</span><br><span class="line">    <span class="type">int</span> sum = (*add_ptr)(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>,sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用数组指针</span></span><br><span class="line">    <span class="type">char</span> (*arr_ptr)[<span class="number">30</span>]; <span class="comment">//arr_ptr是一个指针，指向30个元素构成的char型数组</span></span><br><span class="line">    arr_ptr = str; <span class="comment">//将str[0]的首地址赋给ptr_arr指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str[%d]=%s\n&quot;</span>,i,*(arr_ptr + i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用typedef之后：</span></span><br><span class="line">    <span class="comment">//调用函数</span></span><br><span class="line">    PTR_FUNC ptr_add = &amp;add;</span><br><span class="line">    <span class="type">int</span> sum1 = (*ptr_add)(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum1 = %d\n&quot;</span>,sum1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用数组</span></span><br><span class="line">    PTR_ARR ptr_arr = str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str[%d]=%s\n&quot;</span>,i,*(ptr_arr + i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-小-结"><a href="#7-4-小-结" class="headerlink" title="7.4 小 结"></a>7.4 小 结</h3><p>(1) typedef的方法实际上是为特定的类型指定了一个同义字(synonyms)。</p><p>(2) 用typedef只是对已经存在的类型指定一个新的类型名，而没有创造新的类型。</p><p>(3) typedef与#define是不同的。#define是在<code>预编译时处理</code>的，它只能作简单的字符串替换，而typedef是在<code>编译阶段处理</code>的，且并非简单的字符串替换。</p><p>(4) 当不同源文件中用到同一类型数据（尤其是像数组、指针、结构体、共用体等类型数据）时，常用typedef 声明这些同一的数据类型。</p><p>技巧：可以把所有的typedef名称声明单独<code>放在一个头文件</code>中，然后在需要用到它们的文件中用#include指令把它们包含到文件中。这样编程者就不需要在各文件中自己定义typedef名称了。</p><p>(5) 使用typedef名称有利于<code>程序的通用与移植</code>。有时程序会依赖于硬件特性，用typedef类型就便于移植。</p><p>某一个值在不同计算机上的类型，可能是不一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">100000</span>;</span><br></pre></td></tr></table></figure><p>上面代码在32位整数的计算机没有问题，但是在16位整数的计算机就会出错。C 语言的解决办法，就是提供了类型别名，在不同计算机上会解释成不同类型，比如 int32_t 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> i = <span class="number">100000</span>;</span><br></pre></td></tr></table></figure><p>上例将变量 i 声明成 int32_t 类型，保证它在不同计算机上都是32位宽度，移植代码时就不会出错。</p><p>这一类的类型别名都是用 typedef 定义的。下面是类似的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">ptrdiff_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">wchar_t</span>;</span><br></pre></td></tr></table></figure><p>这些整数类型别名都放在头文件 stdint.h ，不同架构的计算机只需修改这个头文件即可，而无需修改代码。</p><h3 id="7-5-应用场景"><a href="#7-5-应用场景" class="headerlink" title="7.5 应用场景"></a>7.5 应用场景</h3><p><strong>场景1：</strong></p><p>在考研中， typedef主要用在结构体的定义过程中，如二叉树结点的结构体定义，其他地方几乎不用。新定义的结构体若没有名字，则用typedef 给它起个名字是有必要的。</p><p><strong>场景2：</strong></p><p>对于已有的数据类型，如int、float等已经有了简洁的名字，还有必要给它起个新名字吗？有必要，但不是在考研数据结构中。举个例子：</p><p>在一个大工程中，对于其中的一个变量，在整个工程中都已经用int 型定义过了，但是工程如果要求修改，将所有int 型换成long型，如果事先给int型起个新名字为ElemType，则在整个工程中凡是类似于int x;的语句都写成ElemType x; ，此时只需将typedef int ElemType这一句中的int 换成long 即可实现全局的数据类型替换，这就是typedef 的意义所在。（上述这些对考研答卷的实际意义并不大。）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line">ElemType i1, i2, i3;</span><br></pre></td></tr></table></figure><p>上例中，变量 i1 、 i2 、 i3 的类型都是 int。如果以后需要为它们改类型，只需要修改typedef 语句即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> ElemType;</span><br></pre></td></tr></table></figure><p>上面命令将变量 i1 、 i2 、 i3 的类型都改为 long。</p><h1 id="第08章-C语言常用函数"><a href="#第08章-C语言常用函数" class="headerlink" title="第08章_C语言常用函数"></a>第08章_C语言常用函数</h1><h2 id="本章专题脉络-7"><a href="#本章专题脉络-7" class="headerlink" title="本章专题脉络"></a>本章专题脉络</h2><p><img src="/img/images/%E7%AC%AC8%E7%AB%A0_C%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0.png" alt="第8章_C语言常用函数"></p><h2 id="1、字符串相关函数"><a href="#1、字符串相关函数" class="headerlink" title="1、字符串相关函数"></a>1、字符串相关函数</h2><h3 id="1-1-字符串的表示方式"><a href="#1-1-字符串的表示方式" class="headerlink" title="1.1 字符串的表示方式"></a>1.1 字符串的表示方式</h3><p>C 语言没有单独的字符串类型，字符串被当作字符数组，即 char 类型的数组。表示方式如下：</p><p><strong>方式1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>方式2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="1-2-两种方式的区别"><a href="#1-2-两种方式的区别" class="headerlink" title="1.2 两种方式的区别"></a>1.2 两种方式的区别</h3><p>字符指针和字符数组，这两种声明字符串变量的写法基本是等价的，但是也有区别。</p><p>**区别1：**指针指向的字符串，在 C 语言内部被当作常量，不能修改字符串本身。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* str = <span class="string">&quot;hello!&quot;</span>;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>如果使用数组声明字符串变量，就没有这个问题，可以修改数组的任意成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span>; <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure><p>为什么字符串声明为指针时不能修改，声明为数组时就可以修改？</p><p>因为系统会将字符串的字面量保存在内存的常量区，这个区域是不允许用户修改的。声明为指针时，指针变量存储的值是一个指向常量区的内存地址，因此用户不能通过这个地址去修改常量区。但是，声明为数组时，编译器会给数组单独分配一段内存，字符串字面量会被编译器解释成字符数组，逐个字符写入这段新分配的内存之中，而这段新内存是允许修改的。</p><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;hello&quot;</span>; <span class="comment">//新开辟的空间，保存数组中的数据</span></span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;hello&quot;</span>; <span class="comment">//新开辟的空间，保存数组中的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,str1); <span class="comment">//000000f4a93ff81a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,str2); <span class="comment">//000000f4a93ff814</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> * str3 = <span class="string">&quot;hello&quot;</span>; </span><br><span class="line">    <span class="type">char</span> * str4 = <span class="string">&quot;hello&quot;</span>; <span class="comment">//与前一个str3的数据是共享的，存在于常量区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,str3); <span class="comment">//00007ff6842ca004</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,str4); <span class="comment">//00007ff6842ca004</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**区别2：**指针变量可以指向其它字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure><p>但是，字符数组变量不能指向另一个字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;world&quot;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>字符数组的数组名，总是指向初始化时的字符串地址，不能修改。所以，声明字符数组后，不能直接用字符串赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line">s = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>为什么数组变量不能赋值为另一个数组？</p><p>因为数组变量所在的地址无法改变，或者说，编译器一旦为数组变量分配地址后，这个地址就绑定这个数组变量了，这种绑定关系是不变的，即不能用赋值运算符为它重新赋值。</p><p>想要重新赋值，必须使用 C 语言原生提供的 strcpy() 函数，通过字符串拷贝完成赋值。这样做以后，数组变量的地址还是不变的，即 strcpy() 只是在原地址写入新的字符串，而不是让数组变量指向新的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s, <span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>【武汉科技大学2019研】下面各语句中，能正确进行字符串操作的语句是（　　）。<br>A．char a[10]＝{‘A’，’B’，’C’，’D’，’\0’}；<br>B．char a[10]；  a＝”ABCDE”；<br>C．char *p；  *p＝”ABCDE”；<br>D．char *s； scanf（”%s”， s）；</p><p>【答案】A</p><p>【解析】B项中，字符数组的数组名指向数组的首元素地址，初始化后不可再被更改；CD两项中的字符指针在定义时均没有进行初始化，对其赋值是非法的，答案选A。</p></blockquote><blockquote><p> 【北京航空航天大学2018研】对于以下C程序，其正确的是（　　）。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;  </span><br><span class="line">  <span class="type">char</span> str1[]=<span class="string">&quot;Hello&quot;</span>;  </span><br><span class="line">  <span class="type">char</span> str2[]=<span class="string">&quot;Hello&quot;</span>;  </span><br><span class="line">  <span class="keyword">if</span>(str1==str2)    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Equal\n&quot;</span>);  </span><br><span class="line">  <span class="keyword">else</span>    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Unequal\n&quot;</span>);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p> A．Unequal<br> B．Equal<br> C．该程序无法通过编译<br> D．该程序运行时出错</p><p> 【答案】A</p><p> 【解析】首先该程序符合语法规则，因此不会编译时产生错误，其次字符数组str1和str2都为指针常量，将他们直接用关系运算符进行比较肯定是不相等的，但是它们所指的字符串是相等的，因此最后输出Unequal。</p></blockquote><h3 id="1-2-字符串常用函数"><a href="#1-2-字符串常用函数" class="headerlink" title="1.2 字符串常用函数"></a>1.2 字符串常用函数</h3><p>这里的字符串处理函数，都属于<strong>库函数</strong>。库函数并非C语言本身的组成部分，而是C语言编译系统为方便用户使用而提供的公共函数。不同的编译系统提供的函数数量和函数名、函数功能都不尽相同，使用时要小心，必要时查一下<strong>库函数手册</strong>。</p><p>在使用字符串处理函数时，应当在程序文件的开头用<code>#include &lt;string.h&gt;</code>把 string.h 文件包含到本文件中。</p><h4 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h4><p>作用：返回字符串的字节长度，不包括末尾的空字符 ‘\0’ 。</p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string.h</span></span><br><span class="line"><span class="comment">//参数是字符串变量，返回的是 size_t 类型的无符号整数,一般当做int类型处理。</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span>;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    <span class="comment">//需要加载此头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">10</span>] = <span class="string">&quot;China&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(str));     <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;China&quot;</span>)); <span class="comment">//5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//区别于sizeof(),是两个不同的概念</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(str));        <span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy()"></a>strcpy()</h4><p><strong>strcpy(字符数组1, 字符数组2)</strong> ：字符串的复制，不能使用赋值运算符，直接将字符数组2的字符串复制到字符数组1中。</p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string.h</span></span><br><span class="line"><span class="built_in">strcpy</span>(<span class="type">char</span> dest[], <span class="type">const</span> <span class="type">char</span> source[])</span><br></pre></td></tr></table></figure><p>使用此函数前，如何复制字符串呢？</p><p>一方面，下面两种字符串的复制写法，都是错的。因为数组的变量名是一个固定的地址，不能修改，使其指向另一个地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> str2[<span class="number">10</span>];</span><br><span class="line">str1 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 报错</span></span><br><span class="line">str2 = str1;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>另一方面，如果是字符指针，赋值运算符（ &#x3D; ）只是将一个指针的地址复制给另一个指针，而不是复制字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* str1;</span><br><span class="line"><span class="type">char</span>* str2;</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">str2 = str1;</span><br></pre></td></tr></table></figure><p>此时，可以使用 strcpy(字符数组1,字符数组2) 函数，用于将一个字符串的内容复制到另一个字符串（<strong>前提</strong>：字符数组1的长度不小于字符数组2的长度，否则会溢出）。</p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">10</span>], str2[] = <span class="string">&quot;China&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(str1, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//或</span></span><br><span class="line"><span class="comment">//    strcpy(str1, &quot;China&quot;); //参数2，也可以是一个字符串常量</span></span><br><span class="line"><span class="comment">//    printf(&quot;%s\n&quot;,str1);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进一步</span></span><br><span class="line">    str1[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str1); <span class="comment">//Ahina</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str2); <span class="comment">//China</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：如下程序的输出结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str1[<span class="number">10</span>] = <span class="string">&quot;abcde1234&quot;</span>, str2[] = <span class="string">&quot;China&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(str1, str2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str1); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str1[i]); <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">China</span><br><span class="line">China 2345</span><br></pre></td></tr></table></figure><p>复制时将字符串2和其后的′\0′一起复制到字符数组1中，取代字符数组1中前面的字符，未被取代的字符保持原有内容。</p><h4 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy()"></a>strncpy()</h4><p>作用：将字符串2中前面n个字符复制到字符数组1中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncpy</span>(str1, str2, n);</span><br></pre></td></tr></table></figure><p>将str2中最前面n个字符复制到str1中，取代str1中原有的最前面n个字符。但复制的字符个数n不应多于str1中原有的字符（不包括′\0′）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> s1[<span class="number">40</span>] = <span class="string">&quot;1234567890&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[<span class="number">12</span>] = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(s1, s2, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//    s1[5] = &#x27;\0&#x27;;  //测试这行代码添加的必要性</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s1); <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="strcat"><a href="#strcat" class="headerlink" title="strcat()"></a>strcat()</h4><p><strong>strcat(字符数组1, 字符数组2)</strong>：把两个字符数组中的字符串连接起来，把字符串2接到字符串1的后面，结果放在字符数组1中，函数调用后得到一个函数值——字符数组1的地址。</p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcat</span><span class="params">(<span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2)</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><p>1、字符数组1必须足够大，以便容纳连接后的新字符串。</p><p>2、连接前两个字符串的后面都有′\0′，连接时将字符串1后面的′\0′取消，只在新串最后保留′\0′。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">30</span>] = &#123;<span class="string">&quot;People′s Republic of &quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> str2[] = &#123;<span class="string">&quot;China&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">strcat</span>(str1, str2)); <span class="comment">//People′s Republic of China</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str1);  <span class="comment">//People′s Republic of China</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="strncat"><a href="#strncat" class="headerlink" title="strncat()"></a>strncat()</h4><p>作用：将字符串2中前面n个字符连接到字符数组1中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncat</span>(str1, str2, n);</span><br></pre></td></tr></table></figure><p>strncat() 总是会在拼接结果的结尾，自动添加空字符′\0′ ，所以第三个参数的最大值，应该是 str1 的变量长度减去 str1 的字符串长度，再减去 1 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> s1[<span class="number">10</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[<span class="number">8</span>] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="built_in">strncat</span>(s1, s2, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s1);  <span class="comment">//HelloWor</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h4><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2)</span>;</span><br></pre></td></tr></table></figure><p><strong>strcmp(字符串1, 字符串2)</strong>：比较字符串1和字符串2。</p><p>字符串比较的规则是：将两个字符串自左至右逐个字符相比(按ASCII码值大小比较)，直到出现不同的字符或遇到′\0′为止。</p><p>(1) 如全部字符相同，则认为两个字符串相等。返回值为0</p><p>(2) 若出现不相同的字符，如果返回值为正数，则字符串1大；反之，返回值为负数，则字符串2大。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *str1 = <span class="string">&quot;abxy&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *str2 = <span class="string">&quot;abmn&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strcmp</span>(str1, str2));  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> compare1 = <span class="built_in">strcmp</span>(<span class="string">&quot;China&quot;</span>, <span class="string">&quot;Korea&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,compare1);  <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="strlwr-strupr"><a href="#strlwr-strupr" class="headerlink" title="strlwr()&#x2F;strupr()"></a>strlwr()&#x2F;strupr()</h4><p><strong>strlwr(字符串)</strong>：将字符串中大写字母换成小写字母。</p><p><strong>strupr(字符串)</strong>：将字符串中小写字母换成大写字母。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    strlwr(str);</span><br><span class="line">    <span class="built_in">puts</span>(str); <span class="comment">//helloworld</span></span><br><span class="line"></span><br><span class="line">    strupr(str);</span><br><span class="line">    <span class="built_in">puts</span>(str); <span class="comment">//HELLOWORLD</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-基本数据类型和字符串的转换"><a href="#1-3-基本数据类型和字符串的转换" class="headerlink" title="1.3 基本数据类型和字符串的转换"></a>1.3 基本数据类型和字符串的转换</h3><p>在程序开发中，我们经常需要将基本数据类型转成字符串类型(即 char数组 )。或者将字符串类型转成基本数据类型。</p><h4 id="基本数据类型-字符串"><a href="#基本数据类型-字符串" class="headerlink" title="基本数据类型 -&gt; 字符串"></a>基本数据类型 -&gt; 字符串</h4><p>sprintf()函数可以将其他数据类型转换成字符串类型。此函数声明在<code>stdio.h</code>头文件中。</p><p>sprintf()和平时我们常用的printf()函数的功能相似，只是sprintf()函数输出到字符串中，而printf()函数输出到屏幕上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">20</span>]; <span class="comment">//字符数组，即字符串</span></span><br><span class="line">    <span class="type">char</span> str2[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> a = <span class="number">111</span>, b = <span class="number">222</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">333.444</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(str1, <span class="string">&quot;%d %d&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">sprintf</span>(str2, <span class="string">&quot;%d%c&quot;</span>, a, c);</span><br><span class="line">    <span class="built_in">sprintf</span>(str3, <span class="string">&quot;%.5f&quot;</span>, d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1=%s\n&quot;</span>, str1); <span class="comment">//111 222</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2=%s\n&quot;</span>, str2); <span class="comment">//111a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str3=%s\n&quot;</span>, str3); <span class="comment">//333.44400</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串-基本数据类型"><a href="#字符串-基本数据类型" class="headerlink" title="字符串 -&gt; 基本数据类型"></a>字符串 -&gt; 基本数据类型</h4><p>调用头文件<code> &lt;stdlib.h&gt;</code> 的函数<code>atoi()</code> 或 <code>atof()</code> 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">10</span>] = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">4</span>] = <span class="string">&quot;111&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">10</span>] = <span class="string">&quot;12.67423&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str4[<span class="number">2</span>] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = atoi(str1);</span><br><span class="line">    <span class="type">int</span> j = atof(str1);</span><br><span class="line">    <span class="type">short</span> s = atoi(str2);</span><br><span class="line">    <span class="type">double</span> d = atof(str3);</span><br><span class="line">    <span class="type">char</span> c = str4[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i=%d,j=%d,s=%d,d=%lf,c=%c&quot;</span>, i, j, s, d, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、日期和时间相关函数"><a href="#2、日期和时间相关函数" class="headerlink" title="2、日期和时间相关函数"></a>2、日期和时间相关函数</h2><p>在编程中，程序员会经常使用到日期相关的函数，比如：统计某段代码执行花费的时间等等。头文件是 <code>&lt;time.h&gt;</code>。</p><p>举例说明：</p><ul><li>返回一个值，即格林尼治时间1970年1月1日00:00:00到当前时刻的时长，时长单位是秒。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *t)</span></span><br></pre></td></tr></table></figure><ul><li>获取当前时间，返回一个表示当地时间的字符串(当地时间是基于参数timer的)。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timer)</span></span><br></pre></td></tr></table></figure><ul><li>计算time1和time2之间相差的秒数（time1-time2）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">difftime</span><span class="params">(<span class="type">time_t</span> time1, <span class="type">time_t</span> time2)</span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span> <span class="comment">//该头文件中，声明日期和时间相关的函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  运行test函数，看看执行花费时间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">            sum += j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序启动...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> <span class="type">start_t</span>;</span><br><span class="line">    <span class="comment">//先得到执行test前的时间</span></span><br><span class="line">    time(&amp;<span class="type">start_t</span>); <span class="comment">//获取当前时间</span></span><br><span class="line"></span><br><span class="line">    test(); <span class="comment">//执行test</span></span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> <span class="type">end_t</span>;</span><br><span class="line">    <span class="comment">//再得到执行test后的时间</span></span><br><span class="line">    time(&amp;<span class="type">end_t</span>); <span class="comment">//获取当前时间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="type">diff_t</span>; <span class="comment">//存放时间差</span></span><br><span class="line">    <span class="type">diff_t</span> = difftime(<span class="type">end_t</span>, <span class="type">start_t</span>); <span class="comment">//时间差，按秒 ent_t - start_t</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//然后得到两个时间差就是耗用的时间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="type">start_t</span>); <span class="comment">//1697026306</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="type">end_t</span>); <span class="comment">//1697026308</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;执行test()函数 耗用了%.2f 秒\n&quot;</span>, <span class="type">diff_t</span>); <span class="comment">//执行test()函数 耗用了2.00 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取时间对应的字符串的表示</span></span><br><span class="line">    <span class="type">char</span> * startTimeStr = ctime(&amp;<span class="type">start_t</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,startTimeStr); <span class="comment">//Wed Oct 11 20:11:48 2023</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、数学运算相关的函数"><a href="#3、数学运算相关的函数" class="headerlink" title="3、数学运算相关的函数"></a>3、数学运算相关的函数</h2><p><code>math.h</code>头文件定义了各种数学函数。在这个库中所有可用的功能都带有一个 double 类型的参数，且都返回 double 类型的结果。</p><ul><li>double exp(double x) ：返回 e 的 x 次幂的值。</li><li>double log(double x) ：返回 x 的自然对数（基数为 e 的对数）</li><li>double pow(double x, double y) ：返回 x 的 y 次幂。</li><li>double sqrt(double x) ：返回 x 的平方根。</li><li>double fabs(double x) ：返回 x 的绝对值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> d1 = <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">3.0</span>);</span><br><span class="line">    <span class="type">double</span> d2 = <span class="built_in">sqrt</span>(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d1=%.2f\n&quot;</span>, d1); <span class="comment">//d1=8.00</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d2=%f\n&quot;</span>, d2);   <span class="comment">//d2=2.236068</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、内存管理相关函数"><a href="#4、内存管理相关函数" class="headerlink" title="4、内存管理相关函数"></a>4、内存管理相关函数</h2><h3 id="4-1-C程序的内存分配"><a href="#4-1-C程序的内存分配" class="headerlink" title="4.1 C程序的内存分配"></a>4.1 C程序的内存分配</h3><p><strong>C程序中，不同数据在内存中分配说明：</strong></p><ol><li><p>全局变量和静态局部变量——内存中的静态存储区&#x2F;全局区</p></li><li><p>非静态的局部变量——内存中的动态存储区：stack 栈</p></li><li><p>临时使用的数据——建立动态内存分配区域，需要时随时开辟，不需要时及时释放——heap 堆</p></li><li><p>根据需要<code>向系统申请</code>所需大小的空间，由于未在声明部分定义其为变量或者数组，不能通过变量名或者数组名来引用这些数据，只能通过<strong>指针</strong>来引用）</p></li></ol><p><img src="/img/images/image-20231011215429378.png" alt="image-20231011215429378"></p><h3 id="4-2-void-指针-无类型指针"><a href="#4-2-void-指针-无类型指针" class="headerlink" title="4.2 void 指针(无类型指针)"></a>4.2 void 指针(无类型指针)</h3><ul><li><p>每一块内存都有地址，通过指针变量可以获取指定地址的内存块。</p></li><li><p>指针变量必须有类型，否则编译器无法知道如何解读内存块保存的二进制数据。但是，向系统请求内存的时候，有时不确定会有什么样的数据写入内存，需要先获得内存块，稍后再确定写入的数据类型。</p></li></ul><p>综上，为了满足这种需求，C 语言提供了一种不定类型的指针，叫做 void 指针。它只有内存块的<code>地址信息</code>，<code>没有类型信息</code>，等到使用该块内存的时候，再向编译器补充说明，里面的数据类型是什么。</p><p>此外，由于void 指针等同于无类型指针(typeless pointer)，可以<code>指向任意类型</code>的数据，但是<code>不能解读数据</code>。void 指针与其他所有类型指针之间是<code>互相转换关系</code>，任一类型的指针都可以转为 void 指针，而 void 指针也可以转为任一类型的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> *p = &amp;x; <span class="comment">// 整数指针转为 void 指针</span></span><br><span class="line"><span class="type">int</span> *q = p; <span class="comment">// void 指针转为整数指针</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"><span class="type">void</span>* p = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *p); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>由于不知道 void 指针指向什么类型的值，所以不能用 * 运算符取出它指向的值。</p><blockquote><p>void 指针的重要之处在于，很多内存相关函数的返回值就是 void 指针。</p></blockquote><h3 id="4-3-内存动态分配函数"><a href="#4-3-内存动态分配函数" class="headerlink" title="4.3 内存动态分配函数"></a>4.3 内存动态分配函数</h3><p>头文件<code> &lt;stdlib.h&gt;</code>声明了四个关于内存动态分配的函数。<strong>所谓动态分配内存，就是按需分配，申请才能获得。</strong></p><h4 id="掌握：malloc"><a href="#掌握：malloc" class="headerlink" title="掌握：malloc()"></a>掌握：malloc()</h4><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>;  <span class="comment">//size的类型为无符号整型</span></span><br></pre></td></tr></table></figure><p>作用：在内存的<code>动态存储区(堆区)</code>中分配一个<code>长度为size</code>的<code>连续空间</code>。并将该空间的首地址作为函数值返回，即此函数是一个指针函数。</p><p>由于返回的指针的基类型为 void，应通过显式类型转换后才能存入其他基类型的指针变量，否则会有警告。如果分配不成功，返回空指针（NULL）。</p><p>举例1： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>举例2：动态申请数组空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  p[i] = i * <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>得到一个元素类型为int型，长度为n的数组。取元素方式与之前相同，如获取第2个元素：p[1]。</p><p>举例3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">p</span>;</span></span><br><span class="line">p = (<span class="keyword">struct</span> node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));  <span class="comment">//(struct node*)为强制类型转换</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明二叉树结点方式1</span></span><br><span class="line">BTNode bt1;</span><br><span class="line"><span class="comment">//声明二叉树结点方式2：需熟练掌握</span></span><br><span class="line">BTNode *bt2;</span><br><span class="line">bt2 = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br></pre></td></tr></table></figure><blockquote><p>考研数据结构中所有类型结点的内存分配都可以用函数malloc()来完成，模式固定，容易记忆。</p></blockquote><p>方式2中的BT是指针型变量，还可以指向其它节点。而方式1中的BT则不行。此外，调用结构体成员时，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对于方式1：结构体变量取成员，用&quot;.&quot;</span></span><br><span class="line"><span class="type">int</span> x = bt1.data;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对于方式2：指向结构体的指针取成员，用&quot;-&gt;&quot;</span></span><br><span class="line"><span class="type">int</span> x = bt2-&gt;data;</span><br><span class="line"><span class="type">int</span> x = (*bt2).data;<span class="comment">//以前的写法</span></span><br></pre></td></tr></table></figure><p><strong>关于返回值为NULL：</strong></p><p>malloc() 分配内存有可能分配失败，这时返回常量 NULL。Null 的值为0，是一个无法读写的内存地址，可以理解成一个不指向任何地方的指针。它在包括 <code>stdlib.h</code> 等多个头文件里面都有定义，所以只要可以使用 malloc() ，就可以使用 NULL 。由于存在分配失败的可能，所以最好在使用 malloc() 之后检查一下，是否分配成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123; <span class="comment">// 内存分配失败</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，通过判断返回的指针 p 是否为 NULL ，确定 malloc() 是否分配成功。</p><h4 id="了解：calloc"><a href="#了解：calloc" class="headerlink" title="了解：calloc()"></a>了解：calloc()</h4><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n,<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><p>作用：在内存的**动态存储区(堆区)*<em>中分配n个，单位长度为size的连续空间，这个空间一般比较大，总共占用n</em>size 个字节。并将该空间的首地址作为函数的返回值。如果函数没有成功执行，返回NULL。</p><p>calloc()函数适合为<code>一维数组</code>开辟动态存储空间，n为数组元素个数，每个元素长度为size。</p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="number">10</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//开辟空间的同时，其内容初始化为零</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="type">int</span>* p;</span><br><span class="line">p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>上面示例中， calloc() 相当于 malloc() + memset() 。</p><h4 id="了解：realloc"><a href="#了解：realloc" class="headerlink" title="了解：realloc()"></a>了解：realloc()</h4><p>函数原型： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span>* p, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br></pre></td></tr></table></figure><p>作用：重新分配malloc()或calloc()函数获得的动态空间大小，即调整大小的内存空间。将先前开辟的内存块的指针p指向的动态空间大小改变为size，单位字节。返回值是一个全新的地址（数据也会自动复制过去），也可能返回跟原来一样的地址。分配失败返回NULL。</p><ul><li>realloc() 优先在原有内存块上进行缩减，尽量不移动数据，所以通常是返回原先的地址。</li><li>如果新内存块小于原来的大小，则丢弃超出的部分；如果大于原来的大小，则不对新增的部分进行初始化（程序员可以自动调用 memset() ）。</li></ul><p>举例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* b;</span><br><span class="line">b = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br><span class="line">b = (<span class="type">int</span> *)<span class="built_in">realloc</span>(b, <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>指针 b 原来指向10个成员的整数数组，使用 realloc() 调整为2000个成员的数组。</p><p>举例2：动态栈入栈时，判断是否需要扩容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(SqStack &amp;S, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top - S.bottom &gt;= S.stacksize) &#123;               <span class="comment">//栈满，追加存储空间</span></span><br><span class="line">        S.bottom = (ElemType *) <span class="built_in">realloc</span>(S.bottom,(STACKINCREMENT + S.stacksize) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span> (!S.bottom) <span class="comment">//if(S.bottom == NULL)</span></span><br><span class="line">            <span class="keyword">return</span> FALSE;       <span class="comment">//空间分配失败</span></span><br><span class="line">        S.top = S.bottom + S.stacksize;</span><br><span class="line">        S.stacksize += STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top = e;</span><br><span class="line">    S.top++;     <span class="comment">// 栈顶指针加1</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="掌握：free"><a href="#掌握：free" class="headerlink" title="掌握：free()"></a>掌握：free()</h4><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span>;</span><br></pre></td></tr></table></figure><p>函数无返回值。p是最近一次调用malloc()或calloc()函数时的返回值。</p><p>作用：释放指针变量p所指向的内存空间，使这部分内存能重新被其它变量使用。否则这个内存块会一直占用到程序运行结束。</p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line"><span class="comment">//...各种操作...</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//千万不要忘了使用free()释放内存！</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>1、指针 p 必须是经过动态分配函数 malloc 成功后返回的首地址。</p><p>2、分配的内存块一旦释放，就不应该再次操作已经释放的地址，也不应该再次使用 free() 对该地址释放第二次。</p><p>3、如果忘记调用free()函数，同时p所在的函数调用结束后p指针已经消失了，导致无法访问未回收的内存块，构成内存泄漏。</p></blockquote><h3 id="4-4-举例"><a href="#4-4-举例" class="headerlink" title="4.4 举例"></a>4.4 举例</h3><p>举例：动态创建数组，输入5个学生的成绩，另外一个函数检测成绩低于60 分的，输出不合格的成绩。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> *ptr)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n不及格的成绩有: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr[i] &lt; <span class="number">60</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d &quot;</span>, ptr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="comment">//动态创建数组</span></span><br><span class="line">    p = (<span class="type">int</span> *) <span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个成绩：\n&quot;</span>,N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查不及格的学生</span></span><br><span class="line">    check(p);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">//销毁 堆区 p 指向的空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图示：</p><p><img src="/img/images/image-20230822120152212.png" alt="image-20230822120152212"></p><h3 id="4-5-动态分配内存的基本原则"><a href="#4-5-动态分配内存的基本原则" class="headerlink" title="4.5 动态分配内存的基本原则"></a>4.5 动态分配内存的基本原则</h3><p>1）**避免分配大量的小内存块。**分配堆上的内存有一些系统开销，所以分配许多小的内存块比分配几个大内存块的系统开销大</p><p>2）**仅在需要时分配内存。**只要使用完堆上的内存块，就需要及时释放它，否则可能出现内存泄漏。</p><p>这里需要遵守原则：谁分配，谁释放。</p><p>3）**总是确保释放以分配的内存。**在编写分配内存的代码时，就要确定在代码的什么地方释放内存。</p><h3 id="4-6-常见的内存错误及其对策"><a href="#4-6-常见的内存错误及其对策" class="headerlink" title="4.6 常见的内存错误及其对策"></a>4.6 常见的内存错误及其对策</h3><p><strong>1）内存分配未成功，却使用了它</strong></p><p>新手常犯这种错误，因为他们没有意识到内存分配会不成功。</p><p>常用解决办法是，在使用内存之前检查指针是否为NULL。比如，如果指针p是函数的参数，那么在函数的入口处应该用<code>if(p==NULL)</code>或<code>if(p!=NULL)</code>进行防错处理。</p><p><strong>2）内存分配虽然成功，但是尚未初始化就引用它</strong></p><p>犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line">p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="comment">/*初始化为0*/</span></span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>题外话，无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</p><p><strong>3）内存分配成功并且已经初始化，但操作时提示内存越界</strong></p><p>在使用数组时经常发生下标“+1”或者“-1”的操作，特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</p><p>数组访问越界在运行时，它的表现是不定的，有时什么事也没有，程序一直运行（当然，某些错误结果已造成）；有时，则是程序一下子崩溃。</p><p><strong>4）忘记了释放内存，造成内存泄漏</strong></p><p>含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。</p><p>动态内存的申请与释放必须配对，程序中<code>malloc()</code>与<code>free()</code>的使用次数一定要相同，否则肯定有错误。</p><p><strong>5）未正确的释放内存，造成内存泄漏</strong></p><p>程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存。此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getMemory</span><span class="params">(<span class="type">int</span> *p)</span> &#123;</span><br><span class="line">    p = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 在这里修改的是局部指针 p，不会影响 main 函数中的原始指针 ptr</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">    getMemory(ptr);  <span class="comment">// 将 ptr 的值传递给 getMemory，但是在函数内部修改的是 p，而不是 ptr</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr = %d\n&quot;</span>, *ptr);  <span class="comment">// 这里的 *ptr 是未定义行为，因为 ptr 没有指向有效的内存</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);  <span class="comment">// 这里试图释放未分配的内存，会导致问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，getMemory()中的p申请了新的内存，只是把 p所指的内存地址改变了，但是ptr丝毫未变。getMemory()中的p也始终没有进行内存的释放。事实上，因为没有用free释放内存，每执行一次getMemory()就会泄漏一块内存。</p><p><strong>6）释放了内存却继续使用它</strong></p><p>函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> k;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    p = &amp;k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">port</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> i, j;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        (*p)--;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    addr();</span><br><span class="line">    port();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于addr函数中的变量k在函数返回后就已经不存在了，但是在全局变量p中却保存了它的地址。在下一个函数port中，试图通过全局指针p访问一个不存在的变量，进而出错。</p><p><strong>在计算机系统，特别是嵌入式系统中，内存资源是非常有限的。尤其对于<code>移动端开发者</code>来说，硬件资源的限制使得其在程序设计中首要考虑的问题就是如何<code>有效地管理内存资源</code>。</strong></p><h1 id="第09章-文件操作"><a href="#第09章-文件操作" class="headerlink" title="第09章_文件操作"></a>第09章_文件操作</h1><h2 id="本章专题脉络-8"><a href="#本章专题脉络-8" class="headerlink" title="本章专题脉络"></a>本章专题脉络</h2><p><img src="/img/images/%E7%AC%AC9%E7%AB%A0_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.png" alt="第9章_文件操作"></p><h2 id="1、文件和流的介绍"><a href="#1、文件和流的介绍" class="headerlink" title="1、文件和流的介绍"></a>1、文件和流的介绍</h2><p>文件，对我们并不陌生，文件是数据源（保存数据的地方）的一种，比如大家经常使用的word文档，txt文件，excel文件，avi文件…都是文件。文件最主要的作用就是<code>保存数据</code>，它既可以保存一张图片，也可以保持视频，声音…</p><p>C程序中，对于文件中数据的输入&#x2F;输出操作以“<code>流(stream)</code>” 的方式进行，可以看做是一种数据的流动。</p><p><img src="/img/images/image-20220503123117300.png" alt="image-20220503123117300"></p><p><strong>输入流</strong>：数据从数据源(比如:文件)到程序(或内存)的流动过程。</p><p><strong>输出流</strong>：数据从程序(或内存)到数据源(比如:文件)的流动过程。</p><p><img src="/img/images/image-20230822120902244.png" alt="image-20230822120902244"></p><h2 id="2、C-输入-输出"><a href="#2、C-输入-输出" class="headerlink" title="2、C 输入 &amp; 输出"></a>2、C 输入 &amp; 输出</h2><ul><li><p>当我们提到输入时，这意味着要向程序(或内存)中写入一些数据。输入的数据来源可以是从<code>键盘</code>中、从<code>文件</code>中或从<code>网络</code>中。C 语言提供了一系列<code>内置的函数</code>来读取给定的输入，并根据需要写入到程序中。</p></li><li><p>当我们提到输出时，这意味着要在<code>屏幕</code>上、<code>打印机</code>上或<code>任意文件中</code>显示(或保存)一些数据。同样，C 语言提供了一系列<code>内置的函数</code>来输出数据到指定的载体上。</p></li></ul><h3 id="2-1-标准文件I-O"><a href="#2-1-标准文件I-O" class="headerlink" title="2.1 标准文件I&#x2F;O"></a>2.1 标准文件I&#x2F;O</h3><p>C 语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。</p><table><thead><tr><th><strong>标准文件</strong></th><th><strong>文件指针</strong></th><th><strong>设备</strong></th></tr></thead><tbody><tr><td><strong>标准输入</strong></td><td>stdin</td><td>键盘</td></tr><tr><td><strong>标准输出</strong></td><td>stdout</td><td>屏幕</td></tr><tr><td><strong>标准错误</strong></td><td>stderr</td><td>屏幕</td></tr></tbody></table><p>文件指针是访问文件的方式，我们会讲解如何从屏幕读取值以及如何把结果输出到屏幕上。</p><h3 id="2-2-scanf-和printf-函数"><a href="#2-2-scanf-和printf-函数" class="headerlink" title="2.2 scanf()和printf()函数"></a>2.2 scanf()和printf()函数</h3><p>C 语言中的 I&#x2F;O （输入&#x2F;输出）通常使用<code>printf()</code> 和<code>scanf()</code> 两个函数。</p><ul><li><code>int scanf(const char *format, ...)</code> 函数从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入。</li><li><code>int printf(const char *format, ...)</code> 函数把输出写入到标准输出流 stdout ，并根据提供的格式产生输出。</li></ul><p>其中，format 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。如需了解完整的细节，可以查看这些函数的参考手册。</p><p>举例1：将内容输出到屏幕</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">// 执行printf() 函数需要该库</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">//显示引号中的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, str, &amp;i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: %s %d &quot;</span>, str, i);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-getchar-和putchar-函数"><a href="#2-3-getchar-和putchar-函数" class="headerlink" title="2.3 getchar()和putchar() 函数"></a>2.3 getchar()和putchar() 函数</h3><ul><li><p><code>int getchar(void)</code> 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。</p></li><li><p><code>int putchar(int c)</code>函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。</p></li></ul><p>举例：程序会读取一个单一的字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>); </span><br><span class="line">    c = getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: &quot;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-4-gets-和puts-函数"><a href="#2-4-gets-和puts-函数" class="headerlink" title="2.4 gets()和puts() 函数"></a>2.4 gets()和puts() 函数</h3><ul><li><p><code>char *gets(char *s)</code> 函数从stdin读取一行到 s 所指向的缓冲区，直到一个终止符或EOF。</p></li><li><p><code>int puts(const char *s)</code> 函数把字符串s 和一个尾随的换行符写入到stdout。</p></li></ul><p>举例：程序读取一整行直到该行结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>); </span><br><span class="line">    gets(str);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: &quot;</span>); </span><br><span class="line"><span class="built_in">puts</span>( str );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、C-文件的读写"><a href="#3、C-文件的读写" class="headerlink" title="3、C 文件的读写"></a>3、C 文件的读写</h2><p>一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C 语言不仅提供了访问顶层的函数，也提供了底层调用来处理存储设备上的文件。</p><h3 id="3-1-创建-打开文件"><a href="#3-1-创建-打开文件" class="headerlink" title="3.1 创建&#x2F;打开文件"></a>3.1 创建&#x2F;打开文件</h3><p>使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。</p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * filename e, <span class="type">const</span> <span class="type">char</span> * mode )</span>;</span><br></pre></td></tr></table></figure><p>说明：在这里，filename是字符串，用来命名文件；访问模式mode的值可以是下列值中的一个。</p><p>第1波：</p><table><thead><tr><th>模 式</th><th>描 述</th></tr></thead><tbody><tr><td><strong>r</strong></td><td><code>只读</code>。打开一个已有的文本文件，只允许读取。</td></tr><tr><td><strong>w</strong></td><td><code>只写</code>。打开一个文本文件，只允许写入文件。如果文件不存在，则会创建一个新文件，<br/>并从文件的开头写入内容。如果文件存在，则截断文件为零长度，从开始写入！</td></tr><tr><td><strong>a</strong></td><td><code>追加</code>。打开一个文本文件，用于写入。如果文件不存在，则创建一个新文件。<br/>如果文件已存在，则将写入的数据追加到文件末尾。</td></tr><tr><td><strong>rb</strong></td><td><code>只读（二进制）</code>。打开一个二进制文件，只允许读取。</td></tr><tr><td><strong>wb</strong></td><td><code>只写（二进制）</code>。打开一个二进制文件，只允许写入。如果文件不存在，则创建一个<br/>新文件。如果文件已存在，则截断文件为零长度，从开始写入！</td></tr><tr><td><strong>ab</strong></td><td><code>追加（二进制）</code>。打开一个二进制文件，用于写入。如果文件不存在，则创建一个<br/>新文件。如果文件已存在，则将写入的数据追加到文件末尾。</td></tr></tbody></table><p>第2波：</p><table><thead><tr><th>模 式</th><th>描 述</th></tr></thead><tbody><tr><td><strong>r+</strong></td><td><code>读写</code>。打开一个文本文件，允许读取和写入。</td></tr><tr><td><strong>w+</strong></td><td><code>读写</code>。打开一个文本文件，允许读取和写入。如果文件不存在，则创建一个新文件。<br/>如果文件已存在，则截断文件为零长度，从开始写入！</td></tr><tr><td><strong>a+</strong></td><td><code>读写</code>。打开一个文本文件，允许读取和写入。如果文件不存在，则创建一个新文件。<br/>如果文件已存在，则将写入的数据追加到文件末尾。</td></tr><tr><td><strong>r+b</strong></td><td>或 <strong>“rb+”</strong>：<code>读写（二进制）</code>。打开一个二进制文件，允许读取和写入。</td></tr><tr><td><strong>w+b</strong></td><td>或 <strong>“wb+”</strong>：<code>读写（二进制）</code>。打开一个二进制文件，允许读取和写入。如果文件<br/>不存在，则创建一个新文件。如果文件已存在，则截断文件为零长度。</td></tr><tr><td><strong>a+b</strong></td><td>或 <strong>“ab+”</strong>：<code>读写（二进制）</code>。打开一个二进制文件，允许读取和写入。如果文件<br/>不存在，则创建一个新文件。如果文件已存在，则将写入的数据追加到文件末尾。</td></tr></tbody></table><p>技巧：这些访问模式字符串可以根据需要进行组合使用。例如，”r+” 表示读写，”r+b” 表示读写(二进制)。</p><p>注意：如果处理的是二进制文件（图片，视频..），则需使用下面的访问模式： “rb”, “wb”, “ab”, “rb+”, “r+b”, “wb+”, “w+b”, “ab+”, “a+b” 。</p><h3 id="3-2-关闭文件"><a href="#3-2-关闭文件" class="headerlink" title="3.2 关闭文件"></a>3.2 关闭文件</h3><p>使用完文件后（读，写），一定要将该文件关闭。</p><p>关闭文件，使用fclose( ) 函数。</p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">( FILE *fp )</span>;</span><br></pre></td></tr></table></figure><ul><li>如果成功关闭文件，fclose( ) 函数返回零。此时，会<code>清空缓冲区中的数据</code>，关闭文件，并释放用于该文件的所有内存。</li><li>如果关闭文件时发生错误，函数返回 EOF。EOF 是一个定义在头文件 <code>stdio.h</code> 中的常量。</li></ul><h3 id="3-3-写入文件"><a href="#3-3-写入文件" class="headerlink" title="3.3 写入文件"></a>3.3 写入文件</h3><p>C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读&#x2F;写文件。</p><p><strong>1）fputc 函数</strong></p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> c, FILE *fp )</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><p>函数 fputc() 把参数c 的<code>字符值</code>写入到fp 所指向的输出流中。如果写入成功， 它会返回写入的字符，如果发生错误，则会返回 EOF。</p><p><strong>2）fputs 函数</strong></p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *s, FILE *fp )</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><p>函数fputs() 把<code>字符串 s</code> 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。</p><p><strong>3）fprintf 函数</strong></p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *fp,cons t <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>功能与fputs()类似，将一个<code>字符串</code>写入到文件中。</p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个文件指针</span></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开该文件</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;d:/hello.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>); <span class="comment">//w+模式是:如果文件已存在，则截断文件为零长度。</span></span><br><span class="line">    <span class="comment">//fp = fopen(&quot;d:/hello.txt&quot;, &quot;a+&quot;); //a+模式是:如果文件已存在，则将写入的数据追加到文件末尾。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将内容写入到文件中</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;你好，北京！！\n&quot;</span>, fp);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;你好，世界！！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件！如果不关闭 ，我们的内容没有保存到文件中!</span></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建，写入信息完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-读取文件"><a href="#3-4-读取文件" class="headerlink" title="3.4 读取文件"></a>3.4 读取文件</h3><p><strong>1）fgetc 函数</strong></p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">( FILE * fp )</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><p>fgetc() 函数从fp 所指向的输入文件中<code>读取一个字符</code>。返回值是读取的字符， 如果发生错误则返回 EOF。</p><p><strong>2）fscanf 函数</strong></p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br></pre></td></tr></table></figure><p>说明：</p><p>使用 fscanf() 函数从文件中读取格式化的数据，比如<code>整数、浮点数等各种类型的数据</code>。<code>format</code> 参数指定了数据的格式，后面的参数是用于存储读取数据的变量。</p><p>如果使用 fscanf() 函数从文件中<code>读取字符串</code>，会在遇到第一个空白字符（空格、制表符、换行符等）时，停止读取，之后的内容会被忽略。</p><p> 如果函数成功读取了一些数据并按照指定格式存储到相应的变量中，它会返回成功读取的参数个数。或者在读取失败或文件结束时返回 EOF。</p><p><strong>3）fgets 函数</strong></p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">( <span class="type">char</span> *buf, <span class="type">int</span> n, FILE *fp )</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><p>此函数按行读取数据，它从文件中<code>读取一行数据</code>（包括换行符 ‘\n’），并将这一行的内容存储到指定的缓冲区中。参数中 buf 是用于存储读取的文本的缓冲区，n 是缓冲区的大小，fp 是文件指针。</p><p> 如果成功读取，返回参数 buf，即读取到的字符串的首地址。如果到达文件末尾或者读取失败，返回NULL。</p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个文件指针</span></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//定义一个缓冲区</span></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;d:/hell.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">//方法1</span></span><br><span class="line">    <span class="comment">//fscanf(fp, &quot;%s&quot;, buff);</span></span><br><span class="line">    <span class="comment">////输出</span></span><br><span class="line">    <span class="comment">//printf(&quot;%s\n&quot;, buff);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法2 读取整个文件</span></span><br><span class="line">    <span class="comment">//说明，循环读取fp指向的文件内容，如果读到NULL,就结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(buff, <span class="number">1024</span>, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第01章附录1：CLion使用"><a href="#第01章附录1：CLion使用" class="headerlink" title="第01章附录1：CLion使用"></a>第01章附录1：CLion使用</h1><h2 id="1-认识CLion"><a href="#1-认识CLion" class="headerlink" title="1. 认识CLion"></a>1. 认识CLion</h2><h3 id="1-1-JetBrains-公司介绍"><a href="#1-1-JetBrains-公司介绍" class="headerlink" title="1.1 JetBrains  公司介绍"></a>1.1 JetBrains  公司介绍</h3><p>CLion，是 JetBrains (<a href="https://www.jetbrains.com/)%E5%85%AC%E5%8F%B8%E7%9A%84%E4%BA%A7%E5%93%81%EF%BC%8C%E8%AF%A5%E5%85%AC%E5%8F%B8%E6%88%90%E7%AB%8B%E4%BA%8E2000%E5%B9%B4%EF%BC%8C%E6%80%BB%E9%83%A8%E4%BD%8D%E4%BA%8E%E6%8D%B7%E5%85%8B%E7%9A%84%E5%B8%83%E6%8B%89%E6%A0%BC%EF%BC%8C%E8%87%B4%E5%8A%9B%E4%BA%8E%E4%B8%BA%E5%BC%80%E5%8F%91%E8%80%85%E6%89%93%E9%80%A0%E6%9C%80%E9%AB%98%E6%95%88%E6%99%BA%E8%83%BD%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E3%80%82">https://www.jetbrains.com/)公司的产品，该公司成立于2000年，总部位于捷克的布拉格，致力于为开发者打造最高效智能的开发工具。</a></p><p><img src="/img/images/1692692710108.png" alt="1692692710108"></p><p>公司旗下的各种产品：</p><ul><li>CLion：用于开发 C&#x2F;C++</li><li>IDEA：用于开发 Java</li><li>PyCharm：用于开发 python</li></ul><ul><li>WebStorm：用于开发 JavaScript、HTML5、CSS3 等前端技术</li><li>PhpStorm：用于开发 PHP</li><li>RubyMine：用于开发 Ruby&#x2F;Rails</li><li>AppCode：用于开发 Objective - C&#x2F;Swift</li><li>DataGrip：用于开发数据库和 SQL</li><li>Rider：用于开发.NET</li><li>GoLand：用于开发 Go</li></ul><h3 id="1-2-CLion-介绍"><a href="#1-2-CLion-介绍" class="headerlink" title="1.2 CLion 介绍"></a>1.2 CLion 介绍</h3><p>Clion是一款专门开发C以及C++所设计的跨平台的集成开发环境(IDE)。它是以IntelliJ为基础设计的，包含了许多智能功能来提高开发人员的生产力。这种强大的IDE帮助开发人员在Linux、OS X和Windows上来开发C&#x2F;C++，同时它还能使用智能编辑器来提高代码质量、自动代码重构并且深度整合Cmake编译系统，从而提高开发人员的工作效率。</p><h3 id="1-3-Clion-的下载"><a href="#1-3-Clion-的下载" class="headerlink" title="1.3 Clion  的下载"></a>1.3 Clion  的下载</h3><ul><li><p>下载网址： <a href="https://www.jetbrains.com/clion/download/#section=windows">https://www.jetbrains.com/clion/download/#section=windows</a></p></li><li><p>Clion 目前没有 <code>社区版(Community)</code>。</p></li></ul><p><img src="/img/images/1692685638894.png" alt="1692685638894"></p><p>官网提供的详细使用文档：<br><a href="https://www.jetbrains.com.cn/clion/features/">https://www.jetbrains.com.cn/clion/features/</a></p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><h3 id="2-1-安装前的准备"><a href="#2-1-安装前的准备" class="headerlink" title="2.1 安装前的准备"></a>2.1 安装前的准备</h3><ul><li>64 位 Microsoft Windows 11、10、8</li><li>最低 2 GB 可用 RAM，推荐 8 GB 系统总 RAM</li><li>3.5 GB 硬盘空间，推荐 至少5G的SSD硬盘</li><li>最低屏幕分辨率 1024x768，推荐1920×1080</li></ul><h3 id="2-2-安装过程"><a href="#2-2-安装过程" class="headerlink" title="2.2 安装过程"></a>2.2 安装过程</h3><p>1、下载完安装包，双击直接安装<img src="/img/images/1692685747275.png" alt="1692685747275"></p><p>2、欢迎安装</p><p><img src="/img/images/1692685818554.png" alt="1692685818554"></p><p>4、选择安装目录</p><p><img src="/img/images/1692685875043.png" alt="1692685875043"></p><p>选择安装目录，目录中要避免中文和空格。</p><p><img src="/img/images/1692685853085.png" alt="1692685853085"></p><p>5、创建桌面快捷图标等</p><p><img src="/img/images/1692686073729.png" alt="1692686073729"></p><p>确认是否与.c、.h、.cpp格式文件进行关联。这里建议不关联。</p><p>6、在【开始】菜单新建一个文件夹（这里需要确认文件夹的名称），来管理CLion的相关内容。</p><p><img src="/img/images/1692686114854.png" alt="1692686114854"></p><p><img src="/img/images/1692686134454.png" alt="1692686134454"></p><p>7、完成安装</p><p><img src="/img/images/1692686267537.png" alt="1692686267537"></p><p>8、双击打开</p><p><img src="/img/images/1692686314524.png" alt="1692686314524"></p><p>9、选择“Do not import settings”，点击“OK”按钮</p><img src="/img/images/1692686365691.png" alt="1692686365691" style="zoom:80%;" /><p>10、如图所示，需要激活CLion</p><img src="/img/images/1692686434862.png" alt="1692686434862" style="zoom: 80%;" /><h3 id="2-3-注册"><a href="#2-3-注册" class="headerlink" title="2.3 注册"></a>2.3 注册</h3><ul><li><p>选择1：适用30天。在CLion版本中，需要先登录，才能开启试用。</p><img src="/img/images/1692686513431.png" alt="1692686513431" style="zoom:80%;" /></li><li><p>选择2：付费购买旗舰版</p><img src="/img/images/1692686556166.png" alt="1692686556166" style="zoom:80%;" /><img src="/img/images/1692686590056.png" alt="1692686590056" style="zoom: 67%;" /></li><li><p>选择3：（推荐）</p><ul><li>大家参照《<code>02-软件\CLion-2022.1.3安装包\CLion注册文档\CLion注册文档.docx</code>》操作即可。</li><li>由于存在时效性，如果失效，大家可以自行搜索注册方式即可。</li></ul></li></ul><h2 id="3-HelloWorld的实现"><a href="#3-HelloWorld的实现" class="headerlink" title="3. HelloWorld的实现"></a>3. HelloWorld的实现</h2><h3 id="3-1-新建Project"><a href="#3-1-新建Project" class="headerlink" title="3.1 新建Project"></a>3.1 新建Project</h3><p>选择”New Project”：</p><img src="/img/images/1692686679397.png" alt="1692686679397" style="zoom:80%;" /><p>指定创建C可执行文件、工程目录，图中的“untitled1”需要修改为自己的工程名称。如下所示：</p><img src="/img/images/1692687949240.png" alt="1692687949240" style="zoom:80%;" /><p>选择C可执行文件，修改工程名称为demo1</p><img src="/img/images/1692687854607.png" alt="1692687854607" style="zoom:80%;" /><p>点击“Create”进行下一步，如图所示</p><img src="/img/images/1692688033686.png" alt="1692688033686" style="zoom:80%;" /><p>此处选择编译器，默认MinGW即可，点击“OK”按钮，如图所示，默认创建了main.c文件。</p><img src="/img/images/1692688090496.png" alt="1692688090496" style="zoom:67%;" /><h3 id="3-2-运行"><a href="#3-2-运行" class="headerlink" title="3.2 运行"></a>3.2 运行</h3><p>点击执行按钮，如下所示</p><img src="/img/images/1692688278731.png" alt="1692688278731" style="zoom: 67%;" /><h2 id="4-详细设置"><a href="#4-详细设置" class="headerlink" title="4. 详细设置"></a>4. 详细设置</h2><p><img src="/img/images/image-20230823143234863.png" alt="image-20230823143234863"></p><p>CLion的设置都在 File - Settings 中进行。</p><h3 id="4-1-设置整体主题"><a href="#4-1-设置整体主题" class="headerlink" title="4.1 设置整体主题"></a>4.1 设置整体主题</h3><h4 id="1、选择主题"><a href="#1、选择主题" class="headerlink" title="1、选择主题"></a>1、选择主题</h4><p><img src="/img/images/image-20230823143412251.png" alt="image-20230823143412251"></p><h4 id="2、设置菜单和窗口字体和大小"><a href="#2、设置菜单和窗口字体和大小" class="headerlink" title="2、设置菜单和窗口字体和大小"></a>2、设置菜单和窗口字体和大小</h4><p><img src="/img/images/image-20230823143554720.png" alt="image-20230823143554720"></p><h3 id="4-2-设置编辑器主题样式"><a href="#4-2-设置编辑器主题样式" class="headerlink" title="4.2 设置编辑器主题样式"></a>4.2 设置编辑器主题样式</h3><h4 id="1、字体大小"><a href="#1、字体大小" class="headerlink" title="1、字体大小"></a>1、字体大小</h4><p><img src="/img/images/1655136907073.png" alt="1655136907073"></p><p>更详细的字体与颜色如下：</p><p><img src="/img/images/image-20230823144141946.png" alt="image-20230823144141946"></p><blockquote><p>温馨提示：如果选择某个font字体，中文乱码，可以在fallback font（备选字体）中选择一个支持中文的字体。</p></blockquote><h4 id="2、注释的字体颜色"><a href="#2、注释的字体颜色" class="headerlink" title="2、注释的字体颜色"></a>2、注释的字体颜色</h4><p><img src="/img/images/image-20220616121435182.png" alt="image-20220616121435182"></p><ul><li>Block comment：修改多行注释的字体颜色</li><li>Doc Comment –&gt; Text：修改文档注释的字体颜色</li><li>Line comment：修改单行注释的字体颜色</li></ul><h3 id="4-3-代码智能提示功能"><a href="#4-3-代码智能提示功能" class="headerlink" title="4.3 代码智能提示功能"></a>4.3 代码智能提示功能</h3><p><img src="/img/images/1655137649491.png" alt="1655137649491"></p><p>代码提示和补充功能有一个特性：<code>区分大小写</code>。 如果想不区分大小写的话，就把这个对勾去掉。<code>建议去掉勾选</code>。</p><h3 id="4-4-设置项目文件编码（一定要改）"><a href="#4-4-设置项目文件编码（一定要改）" class="headerlink" title="4.4 设置项目文件编码（一定要改）"></a>4.4 设置项目文件编码（一定要改）</h3><p><img src="/img/images/image-20220615190832482.png" alt="image-20220615190832482"></p><p>说明： Transparent native-to-ascii conversion主要用于转换ascii，显式原生内容。一般都要勾选。</p><h3 id="4-5-设置控制台的字符编码"><a href="#4-5-设置控制台的字符编码" class="headerlink" title="4.5 设置控制台的字符编码"></a>4.5 设置控制台的字符编码</h3><p><img src="/img/images/image-20230823144626692.png" alt="image-20230823144626692"></p><h2 id="5-插件的使用-重要"><a href="#5-插件的使用-重要" class="headerlink" title="5. 插件的使用(重要)"></a>5. 插件的使用(重要)</h2><p><strong>1、为何安装C&#x2F;C++ Single File Execution插件？</strong></p><p>前面已经创建了一个demo1工程，项目文件夹内存在一个代码文件，名为<code>main.c</code>。如果再创建一个C源文件，内部如果也包含main()函数，则会报错！因为默认C工程下只能有一个main()函数。如何解决此问题呢？</p><p>2、安装并测试</p><p>1）在 File - Settings - Plugins 中搜索 <code>C/C++ Single File Execution</code> 插件并安装</p><p><img src="/img/images/image-20230823145107293.png" alt="image-20230823145107293"></p><p>2）在需要运行的代码中右键，点击 Add executable for single c&#x2F;cpp file</p><p><img src="/img/images/1692774502830.png" alt="1692774502830"></p><p>3）此时可以在 Cmakelists.text 文件中看到多出的这一行代码，这就是插件帮我们完成的事情</p><p><img src="/img/images/1692774556495.png" alt="1692774556495"></p><p>4）右键项目文件夹，点击 Reload CMake Project 进行刷新</p><p><img src="/img/images/1692774575597.png" alt="1692774575597"></p><p>5）此时右上角标签处已经增加了我们的文件选项，选择需要的标签</p><p><img src="/img/images/1692774598633.png" alt="1692774598633"></p><p>6）点击小三角，或右键代码处点击 Run 选项，即可运行代码。</p><p><img src="/img/images/1692774678384.png" alt="1692774678384"></p><p>7）在该工程下创建main2.c文件，文件中的代码如下所示，执行上面相同的步骤。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World2!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现一个工程中允许存在多个main方法了，而且可以独立允许。</p><h2 id="6-快捷键的使用"><a href="#6-快捷键的使用" class="headerlink" title="6. 快捷键的使用"></a>6. 快捷键的使用</h2><h3 id="6-1-常用快捷键"><a href="#6-1-常用快捷键" class="headerlink" title="6.1 常用快捷键"></a>6.1 常用快捷键</h3><h4 id="第1组：通用型"><a href="#第1组：通用型" class="headerlink" title="第1组：通用型"></a>第1组：通用型</h4><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>复制代码-copy</td><td>ctrl + c</td></tr><tr><td>粘贴-paste</td><td>ctrl + v</td></tr><tr><td>剪切-cut</td><td>ctrl + x</td></tr><tr><td>撤销-undo</td><td>ctrl + z</td></tr><tr><td>反撤销-redo</td><td>ctrl + shift + z</td></tr><tr><td>保存-save all</td><td>ctrl + s</td></tr><tr><td>全选-select all</td><td>ctrl + a</td></tr></tbody></table><h4 id="第2组：提高编写速度（上）"><a href="#第2组：提高编写速度（上）" class="headerlink" title="第2组：提高编写速度（上）"></a>第2组：提高编写速度（上）</h4><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>提示代码模板-insert live template</td><td>ctrl+j</td></tr><tr><td>使用xx块环绕-surround with …</td><td>ctrl+alt+t</td></tr><tr><td>调出生成getter&#x2F;setter&#x2F;构造器等结构-generate …</td><td>alt+insert</td></tr><tr><td>自动生成返回值变量-introduce variable …</td><td>ctrl+alt+v</td></tr><tr><td>复制指定行的代码-duplicate line or selection</td><td>ctrl+d</td></tr><tr><td>删除指定行的代码-delete line</td><td>ctrl+y</td></tr><tr><td>切换到下一行代码空位-start new line</td><td>shift + enter</td></tr><tr><td>切换到上一行代码空位-start new line before current</td><td>ctrl +alt+ enter</td></tr><tr><td>向上移动代码-move statement up</td><td>ctrl+shift+↑</td></tr><tr><td>向下移动代码-move statement down</td><td>ctrl+shift+↓</td></tr><tr><td>向上移动一行-move line up</td><td>alt+shift+↑</td></tr><tr><td>向下移动一行-move line down</td><td>alt+shift+↓</td></tr></tbody></table><h4 id="第3组：提高编写速度（下）"><a href="#第3组：提高编写速度（下）" class="headerlink" title="第3组：提高编写速度（下）"></a>第3组：提高编写速度（下）</h4><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>批量修改指定的变量名、方法名、类名等-rename</td><td>shift+f6</td></tr><tr><td>抽取代码重构方法-extract method …</td><td>ctrl+alt+m</td></tr><tr><td>选中的结构的大小写的切换-toggle case</td><td>ctrl+shift+u</td></tr></tbody></table><h4 id="第4组：类结构、查找和查看源码"><a href="#第4组：类结构、查找和查看源码" class="headerlink" title="第4组：类结构、查找和查看源码"></a>第4组：类结构、查找和查看源码</h4><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>退回到前一个编辑的页面-back</td><td>ctrl+alt+←</td></tr><tr><td>进入到下一个编辑的页面-forward</td><td>ctrl+alt+→</td></tr><tr><td>打开的类文件之间切换-select previous&#x2F;next tab</td><td>alt+←&#x2F;→</td></tr><tr><td>定位某行-go to line&#x2F;column</td><td>ctrl+g</td></tr><tr><td>回溯变量或方法的来源-go to implementation(s)</td><td>ctrl+alt+b</td></tr><tr><td>折叠方法实现-collapse all</td><td>ctrl+shift+ -</td></tr><tr><td>展开方法实现-expand all</td><td>ctrl+shift+ +</td></tr></tbody></table><h4 id="第5组：查找、替换与关闭"><a href="#第5组：查找、替换与关闭" class="headerlink" title="第5组：查找、替换与关闭"></a>第5组：查找、替换与关闭</h4><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>查找指定的结构</td><td>ctlr+f</td></tr><tr><td>快速查找：选中的Word快速定位到下一个-find next</td><td>ctrl+l</td></tr><tr><td>查找与替换-replace</td><td>ctrl+r</td></tr><tr><td>直接定位到当前行的首位-move caret to line start</td><td>home</td></tr><tr><td>直接定位到当前行的末位 -move caret to line end</td><td>end</td></tr><tr><td>查询当前元素在当前文件中的引用，然后按 F3 可以选择</td><td>ctrl+f7</td></tr><tr><td>全项目搜索文本-find in path …</td><td>ctrl+shift+f</td></tr><tr><td>关闭当前窗口-close</td><td>ctrl+f4</td></tr></tbody></table><h4 id="第6组：调整格式"><a href="#第6组：调整格式" class="headerlink" title="第6组：调整格式"></a>第6组：调整格式</h4><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>格式化代码-reformat code</td><td>ctrl+alt+l</td></tr><tr><td>使用单行注释-comment with line comment</td><td>ctrl + &#x2F;</td></tr><tr><td>使用&#x2F;取消多行注释-comment with block comment</td><td>ctrl + shift + &#x2F;</td></tr><tr><td>选中数行，整体往后移动-tab</td><td>tab</td></tr><tr><td>选中数行，整体往前移动-prev tab</td><td>shift + tab</td></tr></tbody></table><h4 id="第7组-Debug快捷键"><a href="#第7组-Debug快捷键" class="headerlink" title="第7组-Debug快捷键"></a>第7组-Debug快捷键</h4><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>单步调试（不进入函数内部）- step over</td><td>F8</td></tr><tr><td>单步调试（进入函数内部）- step into</td><td>F7</td></tr><tr><td>强制单步调试（进入函数内部） - force step into</td><td>alt+shift+f7</td></tr><tr><td>选择要进入的函数 - smart step into</td><td>shift + F7</td></tr><tr><td>跳出函数 - step out</td><td>shift + F8</td></tr><tr><td>运行到断点 - run to cursor</td><td>alt + F9</td></tr><tr><td>继续执行，进入下一个断点或执行完程序 - resume program</td><td>F9</td></tr><tr><td>停止 - stop</td><td>Ctrl+F2</td></tr><tr><td>查看断点 - view breakpoints</td><td>Ctrl+Shift+F8</td></tr><tr><td>关闭 - close</td><td>Ctrl+F4</td></tr></tbody></table><h3 id="6-2-查看快捷键"><a href="#6-2-查看快捷键" class="headerlink" title="6.2 查看快捷键"></a>6.2 查看快捷键</h3><h4 id="1、已知快捷键操作名，未知快捷键"><a href="#1、已知快捷键操作名，未知快捷键" class="headerlink" title="1、已知快捷键操作名，未知快捷键"></a>1、已知快捷键操作名，未知快捷键</h4><p><img src="/img/images/1692752261713.png" alt="1692752261713"></p><h4 id="2、已知快捷键，不知道对应的操作名"><a href="#2、已知快捷键，不知道对应的操作名" class="headerlink" title="2、已知快捷键，不知道对应的操作名"></a>2、已知快捷键，不知道对应的操作名</h4><p><img src="/img/images/1692752357783.png" alt="1692752357783"></p><h3 id="6-3-自定义快捷键"><a href="#6-3-自定义快捷键" class="headerlink" title="6.3 自定义快捷键"></a>6.3 自定义快捷键</h3><p><img src="/img/images/1692752523743.png" alt="1692752523743"></p><h1 id="第01章附录2：MinGW编译器的安装和配置"><a href="#第01章附录2：MinGW编译器的安装和配置" class="headerlink" title="第01章附录2：MinGW编译器的安装和配置"></a>第01章附录2：MinGW编译器的安装和配置</h1><h2 id="1、MinGW介绍"><a href="#1、MinGW介绍" class="headerlink" title="1、MinGW介绍"></a>1、MinGW介绍</h2><p>MinGW（Minimalist GNU on Windows）实际上是GCC在Windows平台上的移植版本，因此可以将源代码编译为可在 Windows 中运行的可执行程序。MinGW是，主要用于在Windows上本地编译C和C++代码。</p><blockquote><p>目前适用于 Windows 平台、受欢迎的 GCC 移植版主要有 2 种，分别为 MinGW 和 Cygwin。<br>其中：</p><p>MinGW 侧重于服务 Windows 用户可以使用 GCC 编译环境，是真正的GCC移植，相比后者体积更小，使用更方便；<br>Cygwin 只是提供一个类unix的环境内部是原生的GCC，借助它不仅可以在 Windows 平台上使用 GCC 编译器，理论上可以运行 Linux 平台上所有的程序；</p><p>Cygwin 只是提供一个类unix的环境内部是原生的GCC。</p><p>如果读者仅需要在 Windows 平台上使用 GCC，可以使用 MinGW 或者 Cygwin；除此之外，如果还有更高的需求（例如运行 POSIX 应用程序），就只能选择安装 Cygwin。</p></blockquote><h2 id="2、下载与安装"><a href="#2、下载与安装" class="headerlink" title="2、下载与安装"></a>2、下载与安装</h2><h3 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1 下载"></a>2.1 下载</h3><p>下载地址：<a href="https://sourceforge.net/projects/mingw/files/">https://sourceforge.net/projects/mingw/files/</a></p><p>点击“Download Latest Version”即可</p><p><img src="/img/images/1692674344122.png" alt="1692674344122"></p><h3 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h3><p>下载完成后，会得到一个名为 mingw-get-setup.exe 的安装包，双击打开它，可以看到如下的对话框：</p><p><img src="/img/images/1692674777924.png" alt="1692674777924"></p><p>直接点击“Install”，进入下面的对话框：</p><p><img src="/img/images/1692674793945.png" alt="1692674793945"></p><p>读者可根据自己操作系统的实际情况，自定义 MinGW 的安装位置（<code>建议安装到非C盘的指定目录下</code>），然后点击“continue”，进入下面的对话框：</p><p><img src="/img/images/1692674846199.png" alt="1692674846199"></p><p>​进入安装 MinGW 配置器的界面，耐心等待安装完成（显示 100%）即可。</p><p><img src="/img/images/1692675129933.png" alt="1692675129933"></p><p>安装完成之后，继续点击“continue”，进入下面的对话框，这是一个名为 “<code>MinGW Installer Manager</code>” 的软件，借助它，我们可以随时根据需要修改 GCC 编译器的配置。</p><p><img src="/img/images/1692675199055.png" alt="1692675199055"></p><p>常见的安装包介绍如下。</p><table><thead><tr><th>安装包名称</th><th>作用</th></tr></thead><tbody><tr><td>mingw32-binutils</td><td>用于编译生成的 .o 文件的链接、汇编、生成静态库等</td></tr><tr><td>mingw32-gcc</td><td>核心的 C 编译器</td></tr><tr><td>mingw32-gcc-ada</td><td>Ada 编译器</td></tr><tr><td>mingw32-gcc-fortran</td><td>Fortran 编译器</td></tr><tr><td>mingw32-gcc-g++</td><td>C++ 编译器</td></tr><tr><td>mingw32-gcc-objc</td><td>Objective-C 编译器</td></tr><tr><td>mingw32-libgcc</td><td>C 编译器编译出来的程序的运行库</td></tr></tbody></table><p>其中minw32-gcc-g++支持C++编译和minw32-gcc支持C编译。</p><p><img src="/img/images/1692693959356.png" alt="1692693959356"></p><p>为使 GCC 同时支持编译 <code>C</code> 语言和 <code>C++</code>，需勾选上图中标注的 2 项。选中其中一项，鼠标右键点击，选择“Mark for Installation”，如图所示。</p><p><img src="/img/images/1692675410414.png" alt="1692675410414"></p><p>标记完以后如图所示。</p><p><img src="/img/images/1692698300912.png" alt="1692698300912"></p><blockquote><p>GCC 还支持其它编程语言，读者可借助此配置器，随时根据需要安装自己需要的编译环境。</p></blockquote><p>勾选完成后，在菜单栏中选择 <code>Installation -&gt; Apply Changes</code>，</p><p><img src="/img/images/1692675512853.png" alt="1692675512853"></p><p>弹出如下对话框：</p><p><img src="/img/images/1692675528090.png" alt="1692675528090"></p><p>选择“Apply”。然后耐心等待，直至安装成功，即可关闭此界面。</p><p><img src="/img/images/1692675556189.png" alt="1692675556189"></p><h2 id="3、配置：path环境变量"><a href="#3、配置：path环境变量" class="headerlink" title="3、配置：path环境变量"></a>3、配置：path环境变量</h2><p>在安装完成的基础上，我们需要手动配置 PATH 环境变量。</p><p>1）依次 <code>右击计算机（我的电脑） -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量</code>，例如我将其安装到了C:\MinGW文件夹中，因此 PATH 环境变量的设置如下：</p><p><img src="/img/images/image-20230822181721360.png" alt="image-20230822181721360"></p><p><img src="/img/images/image-20230822181849566.png" alt="image-20230822181849566"></p><p>2）打开命令行窗口（通过在搜索栏中执行 cmd 指令即可），输入<code>gcc -v</code>指令，如果输出 GCC 编译器的具体信息，则表示安装成功，例如：</p><p><img src="/img/images/image-20230822182303099.png" alt="image-20230822182303099"></p><p>通过上面的安装，我们就可以在当前 Windows 平台上编译、运行 C 或者 C++ 程序了。</p><p>因为 MinGW-w64 本来就是将 GCC 移植到 Windows 上的产物，所以操作方式和 GCC 一样，只是在 Linux 下命令是被键入到“终端”中，而 Windows 下则是被键入到“命令提示符”里。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 汇总 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言 五</title>
      <link href="/2025/05/21/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E4%BA%94/"/>
      <url>/2025/05/21/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p>  --><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#%E6%95%B0%E7%BB%84"><strong>数组</strong></a><br><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5">数组的概念</a><br><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C">数组的操作</a><br><a href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89">字符数组（字符串）</a><br><a href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">多维数组</a>        </p> <p id = "数组"></p> <h2 id="10-数组"><a href="#10-数组" class="headerlink" title="10 数组"></a>10 数组</h2> <p id = "数组的概念"></p> <h3 id="10-1-数组的概念"><a href="#10-1-数组的概念" class="headerlink" title="10.1 数组的概念"></a>10.1 数组的概念</h3><h4 id="①-数组四要素"><a href="#①-数组四要素" class="headerlink" title="① 数组四要素"></a>① 数组四要素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组名：本质上是标识符常量，需要符合标识符规范。</span><br><span class="line">元素：数组中的成员，同一个数组中的元素必须是相同的数据类型。</span><br><span class="line">下标：也称为索引、角标，就是元素的数字编号，是从0开始的连续数字；通过下标可以访问到数组中的某一个元素。</span><br><span class="line">长度：元素的个数。</span><br></pre></td></tr></table></figure><h4 id="②-C-语言数组特点（不用背）"><a href="#②-C-语言数组特点（不用背）" class="headerlink" title="② C 语言数组特点（不用背）"></a>② C 语言数组特点（不用背）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）创建数组时会在内存中开辟一整块连续的空间，占据的空间的大小，取决于数组的长度和数组中元素的类型。</span><br><span class="line">（2）数组中的元素在内存中是依次紧密排列的且有序的。</span><br><span class="line">（3）数组一旦初始化完成，其长度就是确定的，数组的长度一旦确定，就不能修改。</span><br><span class="line">（4）我们可以直接通过索引（下标）获取指定位置的元素，速度很快。</span><br></pre></td></tr></table></figure> <p id = "数组的操作"></p> <h3 id="10-2-数组的操作"><a href="#10-2-数组的操作" class="headerlink" title="10.2 数组的操作"></a>10.2 数组的操作</h3><h4 id="①-如何定义数组"><a href="#①-如何定义数组" class="headerlink" title="① 如何定义数组"></a>① 如何定义数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1）方式一：先指定元素的个数和类型，再进行初始化（先声明，再初始化赋值）</span></span><br><span class="line"><span class="type">int</span> arr1[<span class="number">4</span>];</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">arr1[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">arr1[<span class="number">2</span>] = <span class="number">300</span>;</span><br><span class="line">arr1[<span class="number">3</span>] = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2）方式二：指定元素的类型和个数并同时进行初始化(声明并同时初始化赋值)</span></span><br><span class="line"><span class="type">double</span> arr2[<span class="number">5</span>] = &#123;</span><br><span class="line">    <span class="number">1.5</span>,</span><br><span class="line">    <span class="number">2.5</span>,</span><br><span class="line">    <span class="number">3.5</span>,</span><br><span class="line">    <span class="number">4.5</span>,</span><br><span class="line">    <span class="number">5.5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3）方式三：指定元素的类型，不指定元素个数，同时进行初始化(声明时不指定长度，必须同时进行初始化赋值);</span></span><br><span class="line"><span class="type">short</span> arr3[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="②-访问数组元素"><a href="#②-访问数组元素" class="headerlink" title="② 访问数组元素"></a>② 访问数组元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[下标]</span><br></pre></td></tr></table></figure><h4 id="③-数组越界"><a href="#③-数组越界" class="headerlink" title="③ 数组越界"></a>③ 数组越界</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">合理的下标范围：0 ~ 长度-1; 如果使用不在合理范围内的下标，越界访问，访问的是数组之外的内存区域。</span><br></pre></td></tr></table></figure><h4 id="④-数组长度计算"><a href="#④-数组长度计算" class="headerlink" title="④ 数组长度计算"></a>④ 数组长度计算</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总的存储空间大小 / 单个元素的存储空间大小</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> 数组名 / <span class="keyword">sizeof</span> 数组名[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">sizeof</span> 数组名 / <span class="keyword">sizeof</span> (元素的数据类型关键字)</span><br></pre></td></tr></table></figure><h4 id="⑤-遍历数组"><a href="#⑤-遍历数组" class="headerlink" title="⑤ 遍历数组"></a>⑤ 遍历数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用计数循环，让循环变量作为下标</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; 数组长度; i++)</span><br><span class="line">&#123;</span><br><span class="line">    数组名[i];<span class="comment">// 读写数组元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p id = "字符数组（字符串）"></p> <h3 id="10-3-字符数组（字符串）"><a href="#10-3-字符数组（字符串）" class="headerlink" title="10.3 字符数组（字符串）"></a>10.3 字符数组（字符串）</h3><h4 id="①-字符串的本质"><a href="#①-字符串的本质" class="headerlink" title="① 字符串的本质"></a>① 字符串的本质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字符串就是由字符组成的数组</span><br><span class="line">特点：</span><br><span class="line">① 有专门的占位符 %s</span><br><span class="line">② 字符串结尾，会自动添加一个 \0 作为字符串结束的标志，所以字符数组最后一个元素必须是 \0。</span><br></pre></td></tr></table></figure><h4 id="②-如何定义字符串"><a href="#②-如何定义字符串" class="headerlink" title="② 如何定义字符串"></a>② 如何定义字符串</h4><p><strong>普通方式初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 手动添加字符串结束标记（\0）</span></span><br><span class="line"><span class="type">char</span> str1[<span class="number">9</span>] = &#123;<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; </span><br><span class="line"><span class="type">char</span> str2[] = &#123;<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 自动添加字符串结束标记(只要长度给的够大)</span></span><br><span class="line"><span class="type">char</span> str3[<span class="number">5</span>] = &#123;<span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;; </span><br><span class="line"><span class="type">char</span> str4[<span class="number">15</span>] = &#123;<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;n&#x27;</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 不会自动添加字符串结束标记</span></span><br><span class="line"><span class="type">char</span> str5[<span class="number">4</span>] = &#123;<span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> str6[] = &#123;<span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>简写方式初始化：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一： 定义字符串  可以自动添加结束标记</span></span><br><span class="line"><span class="type">char</span> str1[] = &#123;<span class="string">&quot;Shanghai&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 方式一： 定义字符串  可以自动添加结束标记</span></span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;Beijing&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="③-字符串的访问和遍历"><a href="#③-字符串的访问和遍历" class="headerlink" title="③ 字符串的访问和遍历"></a>③ 字符串的访问和遍历</h4><p><strong>字符串长度计算：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sizeof： 字符串的内存存储大小就是字符串的长度，字符串的每个元素都是1字节</span><br><span class="line">strlen():  位于标准库头文件 &lt;string.h&gt; 中， 从第一个字符开始计数一直到字符串结束标记（不包括结束标记） </span><br></pre></td></tr></table></figure><p><strong>占位符：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s ：可以用来输出字符串。</span><br></pre></td></tr></table></figure> <p id = "多维数组"></p> <h3 id="10-4-多维数组"><a href="#10-4-多维数组" class="headerlink" title="10.4 多维数组"></a>10.4 多维数组</h3><h4 id="①-多维数组的概念"><a href="#①-多维数组的概念" class="headerlink" title="① 多维数组的概念"></a>① 多维数组的概念</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 如果数组的元素还是数组，这样的数组就称为多维数组。</span><br><span class="line">2. 多维数组分为二维数组、三维数组等</span><br><span class="line">3. 二维数组相关概念：行数、列数、行下标、列下标</span><br></pre></td></tr></table></figure><h4 id="②-二维数组的定义"><a href="#②-二维数组的定义" class="headerlink" title="② 二维数组的定义"></a>② 二维数组的定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 先声明再初始化赋值   标识符arr1的类型是 int [3][2]</span></span><br><span class="line"><span class="type">int</span> arr1[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">arr1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">arr1[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">arr1[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">arr1[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">arr1[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1000</span>;</span><br><span class="line">arr1[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义二维数组：同时声明并初始化赋值，双层大括号</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;,</span><br><span class="line">    &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 定义二维数组：同时声明并初始化赋值; 一层大括号，可以自动分配</span></span><br><span class="line"><span class="type">int</span> arr3[<span class="number">2</span>][<span class="number">4</span>] = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 定义二维数组：同时声明并初始化赋值;一层大括号, 可以自动分配，省略行数</span></span><br><span class="line"><span class="type">int</span> arr4[][<span class="number">3</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="③-二维数组的访问和遍历"><a href="#③-二维数组的访问和遍历" class="headerlink" title="③ 二维数组的访问和遍历"></a>③ 二维数组的访问和遍历</h4><p><strong>长度计算：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行数： sizeof 数组名 / sizeof 数组名[0]</span><br><span class="line">列数： sizeof 数组名[0] / sizeof 数组名[0][0]</span><br></pre></td></tr></table></figure><p><strong>访问内层元素：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[行下标][行下标]</span><br></pre></td></tr></table></figure><h4 id="④-二维数组的内存形式"><a href="#④-二维数组的内存形式" class="headerlink" title="④ 二维数组的内存形式"></a>④ 二维数组的内存形式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存中，各元素是连续存放的，先顺序存放第一行的元素，再存放第二行的元素。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> C语言 五 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言 四</title>
      <link href="/2025/05/20/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E5%9B%9B/"/>
      <url>/2025/05/20/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p>  --><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><strong>流程控制</strong></a><br><a href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">循环控制语句</a><br><a href="#while">while</a><br><a href="#do_while">do while</a><br><a href="#for">for</a><br><a href="#%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">跳转控制语句</a><br><a href="#break">break</a><br><a href="#continue">continue</a><br><a href="#goto">goto</a><br><a href="#%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95"><strong>断点调试</strong></a>       </p> <p id = "流程控制"></p> <h2 id="7-流程控制"><a href="#7-流程控制" class="headerlink" title="7 流程控制"></a>7 流程控制</h2><p id = "循环控制语句"></p>  <h3 id="7-2-循环控制语句"><a href="#7-2-循环控制语句" class="headerlink" title="7.2 循环控制语句"></a>7.2 循环控制语句</h3><p id = "while"></p> <h4 id="①-while-循环"><a href="#①-while-循环" class="headerlink" title="① while 循环"></a>① while 循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件表达式)</span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>**死循环（不会结束的循环）：**条件表达式永远成立！</p><p>**可以结束的循环：**条件表达式不能永远成立，且随着循环次数增加越来越趋向于不成立。</p></blockquote><p id = "do_while"></p> <h4 id="②-do-while-循环"><a href="#②-do-while-循环" class="headerlink" title="② do while 循环"></a>② do while 循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125; <span class="keyword">while</span> (条件表达式);</span><br></pre></td></tr></table></figure><blockquote><p><strong>while 和 do while 区别：</strong></p><p>do while 循环结构，循环体语句第一次执行未经过条件判断，但以后的每一次循环体语句的执行还是会先经过条件判断。</p></blockquote><p id = "for"></p> <h4 id="③-for-循环"><a href="#③-for-循环" class="headerlink" title="③ for 循环"></a>③ for 循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (循环变量初始化; 条件表达式; 循环变量变化)</span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>总结：</strong></p><p>循环变量初始化： 循环之前执行，执行一次。</p><p>条件表达式：每次执行循环体语句先判断，同 while 一致； 执行次数比循环次数多1次。</p><p>循环变量变化：循环体语句(大括号中的语句)后面执行，执行次数同循环次数一致。</p></blockquote><p id = "跳转控制语句"></p> <h3 id="7-3-跳转控制语句"><a href="#7-3-跳转控制语句" class="headerlink" title="7.3 跳转控制语句"></a>7.3 跳转控制语句</h3><p id = "break"></p> <h4 id="①-break"><a href="#①-break" class="headerlink" title="① break"></a>① break</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 在 switch case 结构中使用： 结束所在的 case</span><br><span class="line">2. 在循环结构（for、while、do while）中使用： 结束循环</span><br></pre></td></tr></table></figure><blockquote><p>break 跳出整个循环！</p></blockquote><p id = "continue"></p> <h4 id="②-continue"><a href="#②-continue" class="headerlink" title="② continue"></a>② continue</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在循环结构（for、while、do while）中使用： 结束本次循环</span><br></pre></td></tr></table></figure><blockquote><p>continue 跳出本次循环！</p></blockquote><p id = "goto"></p> <h4 id="③-goto"><a href="#③-goto" class="headerlink" title="③ goto"></a>③ goto</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 使用 goto 可以跳转到指定位置</span><br><span class="line">   goto 标签名;</span><br><span class="line">2. 标签名是自定义的，需要符合标识符规范</span><br><span class="line">3. 尽量避免使用！</span><br></pre></td></tr></table></figure><p id = "断点调试"></p> <h2 id="9-断点调试"><a href="#9-断点调试" class="headerlink" title="9 断点调试"></a>9 断点调试</h2><h3 id="9-1-断点调试介绍"><a href="#9-1-断点调试介绍" class="headerlink" title="9.1 断点调试介绍"></a>9.1 断点调试介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下，然后程序可以进行分析从而找到这个Bug。</span><br></pre></td></tr></table></figure><h3 id="9-2-如何设置断点"><a href="#9-2-如何设置断点" class="headerlink" title="9.2 如何设置断点"></a>9.2 如何设置断点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在代码行号的前面单击中即可添加断点，再次点击可以取消断点； 或者使用快捷键 F9，会给光标所在行添加或取消断点。</span><br><span class="line">启动调试之后，代码执行到断点会暂停。</span><br></pre></td></tr></table></figure><h3 id="9-3-断点调试应用案例-——-逐过程调试"><a href="#9-3-断点调试应用案例-——-逐过程调试" class="headerlink" title="9.3 断点调试应用案例 —— 逐过程调试"></a>9.3 断点调试应用案例 —— 逐过程调试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用逐过程断点调试查看下面代码中变量的变化情况，逐过程是从断点开始逐条语句执行，执行一条语句就暂停一次，可以点击“逐过程”按钮或使用快捷键F10执行下一条语句。</span><br></pre></td></tr></table></figure><h3 id="9-4-断点调试应用案例-——-逐断点调试"><a href="#9-4-断点调试应用案例-——-逐断点调试" class="headerlink" title="9.4 断点调试应用案例 —— 逐断点调试"></a>9.4 断点调试应用案例 —— 逐断点调试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们程序中存在多个断点时，程序执行到第一个断点开始暂停，我们想直接执行到下一个断点再次暂停，而不是逐行执行到下一个断点，我们可以单击“继续”按钮或者使用快捷键F5。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> C语言 四 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 流程控制 </tag>
            
            <tag> 断点调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言 三</title>
      <link href="/2025/05/19/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E4%B8%89/"/>
      <url>/2025/05/19/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p>  --><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><strong>运算符</strong></a><br><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E5%9F%BA%E7%A1%80">运算符基础</a><br><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</a><br><a href="#%E5%85%B3%E7%B3%BB%EF%BC%88%E6%AF%94%E8%BE%83%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6">关系（比较）运算符</a><br><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a><br><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</a><br><a href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</a><br><a href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6">三元运算符</a><br><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><strong>流程控制</strong></a><br><a href="#%E5%88%86%E6%94%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">分支控制语句</a><br><a href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</a>       </p> <p id = "运算符"></p> <h2 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6 运算符"></a>6 运算符</h2> <p id = "运算符基础"></p><h3 id="6-1-运算符基础"><a href="#6-1-运算符基础" class="headerlink" title="6.1 运算符基础"></a>6.1 运算符基础</h3><blockquote><p>**运算符：**也称为操作符，是一种特殊的符号，用以用于数据的运算、赋值和比较等。</p><p><strong>运算数：</strong> 也称为操作数，参与运算的数据，可以是变量、常量、表达式。</p><p><strong>表达式：</strong> 表达式具有值，可以是一个变量、一个常量，也可以是变量、常量和运算符的组合。</p></blockquote><blockquote><p><strong>运算符4要素：</strong> 功能、所需操作数个数、所组成表达式的值、有无副作用。</p><p><strong>运算符分类(按操作数个数)：</strong> 一元运算符、二元运算符、三元运算符。</p><p><strong>运算符分类(按功能)：</strong> 算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、其他运算符</p></blockquote> <p id = "算术运算符"></p><h3 id="6-2-算术运算符"><a href="#6-2-算术运算符" class="headerlink" title="6.2 算术运算符"></a>6.2 算术运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>+</code></td><td>正号</td><td>1</td><td>操作数的值</td><td>无</td></tr><tr><td><code>-</code></td><td>负号</td><td>1</td><td>操作数的值符号取反</td><td>无</td></tr><tr><td><code>+</code></td><td>相加</td><td>2</td><td>相加的值</td><td>无</td></tr><tr><td><code>-</code></td><td>相减</td><td>2</td><td>相减的值</td><td>无</td></tr><tr><td><code>*</code></td><td>相乘</td><td>2</td><td>相乘的值</td><td>无</td></tr><tr><td><code>/</code></td><td>相除</td><td>2</td><td>相除的值</td><td>无</td></tr><tr><td><code>%</code></td><td>取余（取模）</td><td>2</td><td>余数</td><td>无</td></tr><tr><td><code>++</code></td><td>自增</td><td>1</td><td></td><td>有</td></tr><tr><td><code>--</code></td><td>自减</td><td>1</td><td></td><td>有</td></tr></tbody></table><blockquote><p><strong>总结：</strong></p><ol><li>正号、负号</li><li>加、减、乘、除</li><li>取余（取模）<ul><li>表达式的值的符号与第一个操作数保持一致。</li><li>要求两个操作数必须都是整数。</li></ul></li><li>自增、自减<ul><li>如果操作数在前，取操作数自增自减之前的值作为表达式的值（i++&#x2F;i–）</li><li>如果运算符在前，取操作数自增自减之后的值作为表达式的值（++i&#x2F;–i）</li></ul></li></ol></blockquote><blockquote><p><strong>注意：</strong></p><ul><li>带有副作用的运算符，要求操作数必须是变量的形式。</li><li>C 语言规定，同一个表达中，不允许出现互相影响的带有副作用的子表达式（C 语言标准没有规定各个操作数的计算顺序，由编译器自行实现）。</li></ul></blockquote> <p id = "关系（比较）运算符"></p><h3 id="6-3-关系（比较）运算符"><a href="#6-3-关系（比较）运算符" class="headerlink" title="6.3 关系（比较）运算符"></a>6.3 关系（比较）运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>&gt;</code></td><td>大于</td><td>2</td><td>1或0</td><td>无</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td><td>2</td><td>1或0</td><td>无</td></tr><tr><td><code>&lt;</code></td><td>小于</td><td>2</td><td>1或0</td><td>无</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td><td>2</td><td>1或0</td><td>无</td></tr><tr><td><code>==</code></td><td>相等</td><td>2</td><td>1或0</td><td>无</td></tr><tr><td><code>!=</code></td><td>不相等</td><td>2</td><td>1或0</td><td>无</td></tr></tbody></table><blockquote><p><strong>总结：</strong></p><ol><li>比大小</li><li>判等</li></ol></blockquote> <p id = "逻辑运算符"></p><h3 id="6-4-逻辑运算符"><a href="#6-4-逻辑运算符" class="headerlink" title="6.4 逻辑运算符"></a>6.4 逻辑运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑与</td><td>2</td><td>两个条件都成立得1，否则得0</td><td>无</td></tr><tr><td><code>ll</code></td><td>逻辑或</td><td>2</td><td>只要一个条件成立就得1，都不成立得0</td><td>无</td></tr><tr><td><code>！</code></td><td>逻辑非</td><td>1</td><td>操作数非0表达式得0，操作数0表达式得1</td><td>无</td></tr></tbody></table><blockquote><p><strong>注意：</strong></p><p>逻辑与 短路：如果第一个条件不成立，第二个条件将不会执行到。</p><p>逻辑或 短路：如果第一个条件就成立，第二个条件将不会比执行。</p></blockquote> <p id = "位运算符"></p><h3 id="6-5-位运算符"><a href="#6-5-位运算符" class="headerlink" title="6.5 位运算符"></a>6.5 位运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与</td><td>2</td><td>按位相同为1，否则为0</td><td>无</td></tr><tr><td><code>l</code></td><td>按位或</td><td>2</td><td>按位只要有一个为1，都为1</td><td>无</td></tr><tr><td><code>^</code></td><td>按位异或</td><td>2</td><td>按位不同为1，否则为0</td><td>无</td></tr><tr><td><code>~</code></td><td>按位取反</td><td>1</td><td>0变1，1变0</td><td>无</td></tr><tr><td><code>&lt;&lt;</code></td><td>按位左移</td><td>2</td><td>最低位补0</td><td>无</td></tr><tr><td><code>&gt;&gt;</code></td><td>按位右移</td><td>2</td><td>注意</td><td>无</td></tr></tbody></table><blockquote><p><strong>总结：</strong></p><ul><li>按位左移和右移的快捷计算方式：</li></ul></blockquote><blockquote><p><strong>注意：</strong></p><ul><li>对于有符号数，如果最高位为1（负数），则右移时会在最高位补1。<ul><li>​                    如果最高位为0（正数），则右移时会在最高位补0。</li></ul></li></ul></blockquote> <p id = "赋值运算符"></p><h3 id="6-6-赋值运算符"><a href="#6-6-赋值运算符" class="headerlink" title="6.6 赋值运算符"></a>6.6 赋值运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td><code>=</code></td><td>赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>+=</code></td><td>相加赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>-=</code></td><td>相减赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>*=</code></td><td>相乘赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>/=</code></td><td>相除赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>%=</code></td><td>取余赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>&amp;=</code></td><td>按位与赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>l=</code></td><td>按位或赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>^=</code></td><td>按位异或赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>&lt;&lt;=</code></td><td>左移赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr><tr><td><code>&gt;&gt;=</code></td><td>右移赋值</td><td>2</td><td>左边操作数的值</td><td>有</td></tr></tbody></table><blockquote><p><strong>总结：</strong></p><p>  c +&#x3D; 3;  &#x2F;&#x2F; 等价于 c &#x3D; c + 3;  计算后c的值变为33</p><p>  c +&#x3D; b;  &#x2F;&#x2F; 等价于 c &#x3D; c + b;  计算后c的值变为53</p><p>  a +&#x3D; 1.7; &#x2F;&#x2F; 等价于 a &#x3D; a + 1.7  计算后a的值变为11</p></blockquote><blockquote><p><strong>注意：</strong></p><p>（1）赋值运算符的第一个操作数（左值）必须是变量的形式，第二个操作数可以是任何形式的表达式。</p><p>（2）赋值运算符的副作用针对第一个操作数。</p></blockquote> <p id = "三元运算符"></p><h3 id="6-7-三元运算符"><a href="#6-7-三元运算符" class="headerlink" title="6.7 三元运算符"></a>6.7 三元运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>操作数个数</th><th>所组成表达式的值</th><th>有无副作用</th></tr></thead><tbody><tr><td>条件表达式? 表达式1: 表达式2；</td><td></td><td>3</td><td>注意</td><td>无</td></tr></tbody></table><blockquote><p><strong>总结：</strong></p><ol><li>a &gt; b ? 1.1 : 1.2</li><li>若a&gt;b为1.1，若a&lt;b为1.2</li></ol></blockquote><blockquote><p><strong>注意：</strong></p><p>（1）如果条件表达式为非0（真），整个表达式的值是表达式1；</p><p>（2）如果条件表达式为0（假），整个表达式的值是表达式2；</p></blockquote> <p id = "流程控制"></p><h2 id="7-流程控制"><a href="#7-流程控制" class="headerlink" title="7 流程控制"></a>7 流程控制</h2> <p id = "分支控制语句"></p> <h3 id="7-1-分支控制语句"><a href="#7-1-分支控制语句" class="headerlink" title="7.1 分支控制语句"></a>7.1 分支控制语句</h3><h4 id="①-单向分支"><a href="#①-单向分支" class="headerlink" title="① 单向分支"></a>① 单向分支</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-双向分支"><a href="#②-双向分支" class="headerlink" title="② 双向分支"></a>② 双向分支</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③-多向分支-else-if"><a href="#③-多向分支-else-if" class="headerlink" title="③ 多向分支 else if"></a>③ 多向分支 else if</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式<span class="number">1</span>)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">2</span>)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">3</span>)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">4</span>)  </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;  </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④-多向分支-switch-case"><a href="#④-多向分支-switch-case" class="headerlink" title="④ 多向分支 switch case"></a>④ 多向分支 switch case</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 表达式可能的值<span class="number">1</span>：</span><br><span class="line">        语句块;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 表达式可能的值<span class="number">2</span>：</span><br><span class="line">        语句块;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 表达式可能的值<span class="number">3</span>：</span><br><span class="line">        语句块;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 表达式可能的值<span class="number">4</span>：</span><br><span class="line">        语句块;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>（1）switch 后面表达式的值必须是一个整型（char、short, int, long等）或 枚举类型。</p><p>（2）case 后面的值必须是字面量常量，而不能是变量、标识符常量。</p><p>（3）default 是可选的，当没有匹配的 case 时，执行 default。</p><p>（4）break 语句可以使程序跳出 switch 语句块，如果没有break，会执行下一个case 语句块，直到遇到break或者执行到switch结尾，这个现象称为穿透。</p></blockquote><h4 id="⑤-嵌套分支"><a href="#⑤-嵌套分支" class="headerlink" title="⑤ 嵌套分支"></a>⑤ 嵌套分支</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (条件表达式)  </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (条件表达式)  </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> C语言 三 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 运算符 </tag>
            
            <tag> 流程控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言 一</title>
      <link href="/2025/05/17/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E4%B8%80/"/>
      <url>/2025/05/17/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p>  --><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#%E7%A8%8B%E5%BA%8F">程序</a><br><a href="#c%E8%AF%AD%E8%A8%80">c语言</a><br><a href="#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7">开发工具</a><br><a href="#%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a><br><a href="#c%E8%AF%AD%E8%A8%80%E6%89%A7%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B">c语言执行的流程</a><br><a href="#%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86">源文件中的组成部分</a><br><a href="#%E5%8F%98%E9%87%8F">变量</a><br><a href="#%E5%B8%B8%E9%87%8F">常量</a>        </p><p id = "程序"></p><h2 id="1-程序"><a href="#1-程序" class="headerlink" title="1 程序"></a>1 程序</h2><p>编写的编程语言(大量的代码(指令)组成)<br>  比如 xxx.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">   retun <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p id = "c语言"></p><h2 id="2-c语言"><a href="#2-c语言" class="headerlink" title="2 c语言"></a>2 c语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">概念: 是一个程序员使用的高级语言</span><br><span class="line">使用场景: 作为嵌入式开发的基础语言    </span><br></pre></td></tr></table></figure><p id = "开发工具"></p><h2 id="3-开发工具"><a href="#3-开发工具" class="headerlink" title="3 开发工具"></a>3 开发工具</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsCode: 免费,轻量级的开发工具</span><br></pre></td></tr></table></figure> <p id = "编译器"></p><h2 id="4-编译器"><a href="#4-编译器" class="headerlink" title="4 编译器"></a>4 编译器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minGW: 是一个windows系统的工具包,其中包含了c语言的编译器--&gt;gcc</span><br></pre></td></tr></table></figure> <p id = "c语言执行的流程"></p><h2 id="5-c语言执行的流程"><a href="#5-c语言执行的流程" class="headerlink" title="5 c语言执行的流程"></a>5 c语言执行的流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.编写源代码  xxx.c</span><br><span class="line">2.预处理     xxx.i  : 修理xxx.c的源文件(去除多余的注释,空格)</span><br><span class="line">3.编译       xxx.s  把预处理文件编译成汇编文件</span><br><span class="line">4.汇编       xxx.o  把汇编文件编译成二进制文件(机器码)</span><br><span class="line">5.链接       xxx.exe 把所有的可执行文件组合起来(自定义的xxx.o和库文件)</span><br><span class="line">6.执行       执行的就是windows中的可执行文件 xxx.exe</span><br></pre></td></tr></table></figure> <p id = "源文件中的组成部分"></p><h2 id="6-源文件中的组成部分"><a href="#6-源文件中的组成部分" class="headerlink" title="6 源文件中的组成部分"></a>6 源文件中的组成部分</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="meta">#<span class="keyword">include</span> 引入头文件</span></span><br><span class="line"><span class="number">2.</span><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="number">0</span>&#125; 主函数</span><br></pre></td></tr></table></figure> <p id = "变量"></p><h2 id="7-变量"><a href="#7-变量" class="headerlink" title="7 变量"></a>7 变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">变量的作用:  在内存中保存可变的数据</span><br><span class="line">     特点： 变量在内存中的数据是可以修改的</span><br><span class="line">   三要素:  1.变量的类型 2.标识符(变量的名字) 3.变量的值</span><br><span class="line">   </span><br><span class="line"> 标识符(变量,常量,函数,数组)的命名 的规则  </span><br><span class="line">  强制要求:</span><br><span class="line">     1.必须由字母、数字、下划线组成</span><br><span class="line">     2.数字不能开头</span><br><span class="line">     3.不能使用关键字 (类型关键字:int float ....)</span><br><span class="line">     4.严格区分大小写  （hello  ,Hello）</span><br><span class="line">     </span><br><span class="line">   推荐: 1.见名知意 (有效的单词)</span><br><span class="line">        2.小驼峰命名 (如果多个单词: myAge)</span><br></pre></td></tr></table></figure><p id = "常量"></p><h2 id="8-常量"><a href="#8-常量" class="headerlink" title="8 常量"></a>8 常量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">概念: 就是不能改变的量(内存中的数据不能被修改)</span><br><span class="line">作用: 定义程序中使用到的不可更改的数据  比如(PI=3.14)</span><br><span class="line">表现形式: </span><br><span class="line">1.const定义  ： 必须指定类型</span><br><span class="line"></span><br><span class="line">2.#define定义   不能指定类型</span><br><span class="line">   注意: 在预处理阶段自动把定义的常量值替换到程序中</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> C语言 一 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言 二</title>
      <link href="/2025/05/17/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E4%BA%8C/"/>
      <url>/2025/05/17/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%20%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p>  --><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a><br><a href="#%E8%BF%9B%E5%88%B6%E5%88%86%E7%B1%BB">进制分类</a><br><a href="#%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F">进制表示形式</a><br><a href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</a><br><a href="#%E5%8E%9F%E5%8F%8D%E8%A1%A5%E7%A0%81">原码 反码 补码</a><br><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a><br><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96">数据类型转化</a>        </p> <p id = "二进制"></p> <h2 id="5-二进制"><a href="#5-二进制" class="headerlink" title="5 二进制"></a>5 二进制</h2> <p id = "进制分类"></p> <h3 id="5-1-进制分类"><a href="#5-1-进制分类" class="headerlink" title="5.1 进制分类"></a>5.1 进制分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.二进制</span><br><span class="line">2.十进制</span><br><span class="line">3.十六进制</span><br></pre></td></tr></table></figure><p id = "进制表示形式"></p> <h3 id="5-2-不同进制表示形式"><a href="#5-2-不同进制表示形式" class="headerlink" title="5.2 不同进制表示形式"></a>5.2 不同进制表示形式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">十进制: 就是十进制(无特殊)</span><br><span class="line">二进制: 0b010101</span><br><span class="line">十六进制: 0x  0X  #0x  #0X</span><br></pre></td></tr></table></figure> <p id = "进制转换"></p> <h3 id="5-3-进制之间的转换"><a href="#5-3-进制之间的转换" class="headerlink" title="5.3 进制之间的转换"></a>5.3 进制之间的转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">二进制转十进制</span><br><span class="line">    方式:  从低位开始,提取每一位的数据,乘以<span class="number">2</span>的(位数<span class="number">-1</span>)次方， 结果相加</span><br><span class="line">       <span class="number">0111</span> 二进制</span><br><span class="line">       <span class="number">0</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">       <span class="number">1</span>*<span class="number">2</span>^(<span class="number">1</span><span class="number">-1</span>)=<span class="number">1</span></span><br><span class="line">       <span class="number">1</span>*<span class="number">2</span>^(<span class="number">2</span><span class="number">-1</span>)=<span class="number">2</span></span><br><span class="line">       <span class="number">1</span>*<span class="number">2</span>^(<span class="number">3</span><span class="number">-1</span>)=<span class="number">4</span></span><br><span class="line">       <span class="number">0</span>*<span class="number">2</span>^(<span class="number">3</span><span class="number">-1</span>)=<span class="number">0</span></span><br><span class="line">       <span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span>+<span class="number">0</span>=<span class="number">7</span></span><br><span class="line"></span><br><span class="line">十进制转二进制</span><br><span class="line">    方式: 使用该数不断的除以<span class="number">2</span>,直到商为零结束， 最后把每一步计算的余数倒叙组合就是二进制       </span><br><span class="line">       <span class="number">10</span>十进制 转为二进制</span><br><span class="line">        <span class="number">10</span>%<span class="number">2</span>=<span class="number">5</span> 余 <span class="number">0</span></span><br><span class="line">        <span class="number">5</span>%<span class="number">2</span>=<span class="number">2</span> 余 <span class="number">1</span></span><br><span class="line">        <span class="number">2</span>%<span class="number">2</span>=<span class="number">1</span> 余 <span class="number">0</span></span><br><span class="line">        <span class="number">1</span>%<span class="number">2</span>=<span class="number">0</span> 余 <span class="number">1</span></span><br><span class="line">        <span class="number">1010</span></span><br><span class="line"></span><br><span class="line">十六进制转为十进制</span><br><span class="line">    方式:  从低位开始,提取每一位的数据,乘以<span class="number">16</span>的(位数<span class="number">-1</span>)次方， 结果相加   </span><br><span class="line">           #<span class="number">0x12A</span></span><br><span class="line">           (A)<span class="number">10</span>*<span class="number">16</span>^<span class="number">0</span>=<span class="number">10</span></span><br><span class="line">           (<span class="number">2</span>)<span class="number">2</span>* <span class="number">16</span>^<span class="number">1</span>=<span class="number">32</span></span><br><span class="line">           (<span class="number">1</span>)<span class="number">1</span>*<span class="number">16</span>^<span class="number">2</span>=<span class="number">256</span></span><br><span class="line">          <span class="number">256</span>+<span class="number">32</span>+<span class="number">10</span>=<span class="number">298</span></span><br><span class="line">十进制转为十六进制     </span><br><span class="line">    方式: 使用该数不断的除以<span class="number">16</span>,直到商为零结束， 最后把每一步计算的余数倒叙组合就是二进制  </span><br><span class="line">             <span class="number">33</span>（十进制）</span><br><span class="line">             <span class="number">33</span>%<span class="number">16</span>=<span class="number">2</span> 余 <span class="number">1</span></span><br><span class="line">             <span class="number">2</span>%<span class="number">16</span>=<span class="number">0</span>  余 <span class="number">2</span></span><br><span class="line">            十六进制的结果: <span class="number">21</span></span><br><span class="line">   </span><br><span class="line">二进制转为十六进制</span><br><span class="line">    方式: 把二进制每<span class="number">4</span>位一组,计算十六进制          </span><br><span class="line">      <span class="number">1001</span>  <span class="number">1100</span>   </span><br><span class="line">       <span class="number">9</span>（十进制）     <span class="number">12</span>（十进制）</span><br><span class="line">      十六进制结果:  <span class="number">9</span>C  </span><br><span class="line">                </span><br><span class="line">十六进制转为二进制   </span><br><span class="line">    方式:  把每一位转成<span class="number">4</span>位一组的二进制  </span><br><span class="line">                    <span class="number">9</span>C    </span><br><span class="line">         （C）<span class="number">12</span>=<span class="number">8</span>+<span class="number">4</span>  二进制表示:  <span class="number">1010</span>  </span><br><span class="line">          (<span class="number">9</span>) <span class="number">9</span>=<span class="number">8</span>+<span class="number">1</span>  二进制表示:  <span class="number">1001</span>   </span><br><span class="line">            二进制结果: <span class="number">10011010</span>     </span><br></pre></td></tr></table></figure> <p id = "原反补码"></p> <h3 id="5-4-原码-反码-补码"><a href="#5-4-原码-反码-补码" class="headerlink" title="5.4 原码 反码 补码"></a>5.4 原码 反码 补码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">机器数: 就是二进制数据</span><br><span class="line">形式值：没有符号位   1111  最高位不是符号位</span><br><span class="line">真值： 有符号位     1111（ 最高位是符号位）</span><br><span class="line"></span><br><span class="line">原码:  真值</span><br><span class="line">反码:  </span><br><span class="line">  正数的反码就是原码</span><br><span class="line">  负数的反码符号位不变其余取反 1111---&gt; 1000</span><br><span class="line">补码：</span><br><span class="line">  正数的补码就是原码</span><br><span class="line">  负数的补码就是反码+1,符号位不变</span><br><span class="line">  </span><br><span class="line">总结:1.正数的 原码 反码 补码 一致  </span><br><span class="line">    2.计算中存储的数据都是以补码形式存在  </span><br></pre></td></tr></table></figure> <p id = "数据类型"></p> <h3 id="5-5-数据类型"><a href="#5-5-数据类型" class="headerlink" title="5.5 数据类型"></a>5.5 数据类型</h3><table><thead><tr><th>整型</th><th>浮点型</th><th>布尔类型</th></tr></thead><tbody><tr><td>char           1字节</td><td>float 4字节</td><td>宏定义(自定义布尔类): #define BOOL int</td></tr><tr><td>short          2字节</td><td>double 8字节</td><td>使用c99标准中:<em>Bool</em></td></tr><tr><td>int               4字节</td><td>long double 16字节</td><td>使用c99标准: 导入头文件<br /><br />&lt;stdbool.h&gt;</td></tr><tr><td>long           （32:4字节    64：8字节） —&gt; 现在的笔记本是使用了32位系统的转化方式(4字节)</td><td></td><td></td></tr><tr><td>long long    8字节</td><td></td><td></td></tr></tbody></table><p id = "数据类型转化"></p> <h3 id="5-6-数据类型转化"><a href="#5-6-数据类型转化" class="headerlink" title="5.6 数据类型转化"></a>5.6 数据类型转化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">自动类型转换:  窄类型转为宽类型</span><br><span class="line">1.运算过程中的自动类型转换(隐式转换)   </span><br><span class="line">比如: int a=1;short b=2  </span><br><span class="line">计算: a+b 结果是int类型</span><br><span class="line"></span><br><span class="line">2.赋值过程中的自动类型转换(隐式转换)   </span><br><span class="line">比如: float f=3.14;  自动把double类型转为了float类型</span><br><span class="line"></span><br><span class="line">3.强制类型转化</span><br><span class="line">   宽类型转为窄类型</span><br><span class="line">   案例: </span><br><span class="line">      //计算三个人的平均年龄  </span><br><span class="line">      int age1=20,age2=23,age3=24;</span><br><span class="line">      </span><br><span class="line">      //printf(&quot;%lf&quot;,(age1+age2+age3)/3.0);         // 22.333333</span><br><span class="line">      printf(&quot;%lf&quot;,(double)((age1+age2+age3)/3));   // 22.000000</span><br><span class="line">      printf(&quot;%lf&quot;,(double)(age1+age2+age3)/3);     // 22.333333</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> C语言 二 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构十一（快速排序QuickSort）</title>
      <link href="/2025/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%E4%B8%80%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FQuickSort%EF%BC%89/"/>
      <url>/2025/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%E4%B8%80%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FQuickSort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录key，key一般都是最左边，目的就是为了把key排到正确的位置，同时将key设为坑位<br>开始坑在左边，右边开始找值补坑，right找到比key小的值，放入坑位，right形成新的坑<br>现在坑在右边，左边开始找值补坑，left找到比key大的值，放入坑位，left形成新的坑<br>直到left和right相遇就结束，最后把key放到坑位，key就排到正确的位置</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%E4%B8%80%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FQuickSort%EF%BC%89/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序" title="快速排序"></p><p>More info: <a href="https://github.com/gybpersist/QuickSort">QuickSort</a></p><h2 id="快速排序（QuickSort）"><a href="#快速排序（QuickSort）" class="headerlink" title="快速排序（QuickSort）"></a>快速排序（QuickSort）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> begin,<span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份关键元素</span></span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//备份首元素下标，尾元素下标</span></span><br><span class="line">    <span class="type">int</span> left = begin,right = end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 避免元素为空</span></span><br><span class="line">    <span class="keyword">if</span>(begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//备份关键元素(把首元素先作为关键元素)</span></span><br><span class="line">        temp = buf[begin];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当左右找到相同元素是停止</span></span><br><span class="line">        <span class="keyword">while</span> (left != right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先是从右向左找 找到比关键元素大的，不交换，然后向左移动（h--）,直到找到比关键元素小的</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; buf[right] &gt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断左右两边是否指到同一个位置，不是则把 比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">                buf[left] = buf[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//然后是从左向右找 找到比关键元素小的，不交换，然后向左移动（right--）,直到找到比关键元素小的</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; buf[left] &lt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断左右两边是否指到同一个位置，不是则把 比关键元素大的元素放到关键元素位置上</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">                buf[right] = buf[left];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左右两边指到同一个位置(buf[left] = buf[right]) 把关键元素放到这个位置上</span></span><br><span class="line">        buf[left] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在基准元素归位之后，数组被分成了两个子数组：</span></span><br><span class="line">        <span class="comment">//左子数组：从begin到left - 1</span></span><br><span class="line">        <span class="comment">//右子数组：从left + 1到end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//随后，对这两个子数组分别调用QuickSort函数进行递归排序：</span></span><br><span class="line">        <span class="comment">//对左子数组进行排序</span></span><br><span class="line">        QuickSort(buf,begin,left<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右子数组进行排序</span></span><br><span class="line">        QuickSort(buf,left+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素（Prin）"><a href="#遍历元素（Prin）" class="headerlink" title="遍历元素（Prin）"></a>遍历元素（Prin）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    QuickSort(buf, <span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element:<span class="number">2</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">1</span>  <span class="number">7</span>  <span class="number">4</span></span><br><span class="line">Element:<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//记录key，key一般都是最左边，目的就是为了把key排到正确的位置，同时将key设为坑位</span></span><br><span class="line"><span class="comment">//开始坑在左边，右边开始找值补坑，right找到比key小的值，放入坑位，right形成新的坑</span></span><br><span class="line"><span class="comment">//现在坑在右边，左边开始找值补坑，left找到比key大的值，放入坑位，left形成新的坑</span></span><br><span class="line"><span class="comment">//直到left和right相遇就结束，最后把key放到坑位，key就排到正确的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> begin,<span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份关键元素</span></span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//备份首元素下标，尾元素下标</span></span><br><span class="line">    <span class="type">int</span> left = begin,right = end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 避免元素为空</span></span><br><span class="line">    <span class="keyword">if</span>(begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//备份关键元素(把首元素先作为关键元素)</span></span><br><span class="line">        temp = buf[begin];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当左右找到相同元素是停止</span></span><br><span class="line">        <span class="keyword">while</span> (left != right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先是从右向左找 找到比关键元素大的，不交换，然后向左移动（h--）,直到找到比关键元素小的</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; buf[right] &gt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断左右两边是否指到同一个位置，不是则把 比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">                buf[left] = buf[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//然后是从左向右找 找到比关键元素小的，不交换，然后向左移动（right--）,直到找到比关键元素小的</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; buf[left] &lt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断左右两边是否指到同一个位置，不是则把 比关键元素大的元素放到关键元素位置上</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//比关键元素小的元素放到关键元素位置上</span></span><br><span class="line">                buf[right] = buf[left];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左右两边指到同一个位置(buf[left] = buf[right]) 把关键元素放到这个位置上</span></span><br><span class="line">        buf[left] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在基准元素归位之后，数组被分成了两个子数组：</span></span><br><span class="line">        <span class="comment">//左子数组：从begin到left - 1</span></span><br><span class="line">        <span class="comment">//右子数组：从left + 1到end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//随后，对这两个子数组分别调用QuickSort函数进行递归排序：</span></span><br><span class="line">        <span class="comment">//对左子数组进行排序</span></span><br><span class="line">        QuickSort(buf,begin,left<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右子数组进行排序</span></span><br><span class="line">        QuickSort(buf,left+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    QuickSort(buf, <span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 十一 快速排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构十（选择排序SelectSort）</title>
      <link href="/2025/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8FSelectSort%EF%BC%89/"/>
      <url>/2025/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8FSelectSort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>选择排序 从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8FSelectSort%EF%BC%89/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序" title="选择排序"></p><p>More info: <a href="https://github.com/gybpersist/SelectSort">SelectSort</a></p><h2 id="选择排序（SelectSort）"><a href="#选择排序（SelectSort）" class="headerlink" title="选择排序（SelectSort）"></a>选择排序（SelectSort）</h2><h3 id="选择排序-从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序"><a href="#选择排序-从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序" class="headerlink" title="选择排序 从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序"></a>选择排序 从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份交换元素</span></span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 通过线性查找找到最小元素，需要比较 n-1 轮（最后一轮不用排）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; bufsize<span class="number">-1</span>; ++n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//假设每轮序列中第一个元素为最小</span></span><br><span class="line">        <span class="type">int</span> min = n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到最小元素的下标（m=n为自己和自己比,可以优化掉）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = n+<span class="number">1</span>; m &lt; bufsize; ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//比较找到最小元素下标</span></span><br><span class="line">            <span class="keyword">if</span>(buf[min] &gt; buf[m])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新最小值下标</span></span><br><span class="line">                min = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把最小元素放到前面（交换元素）</span></span><br><span class="line">        temp = buf[n];</span><br><span class="line">        buf[n] = buf[min];</span><br><span class="line">        buf[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素（Prin）"><a href="#遍历元素（Prin）" class="headerlink" title="遍历元素（Prin）"></a>遍历元素（Prin）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    SelectSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element:<span class="number">2</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">1</span>  <span class="number">7</span>  <span class="number">4</span></span><br><span class="line">Element:<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序 从序列中找到一个最小元素，把最小元素放到整个序列的首部，重复n轮，直到整个序列有序</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份交换元素</span></span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 通过线性查找找到最小元素，需要比较 n-1 轮（最后一轮不用排）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; bufsize<span class="number">-1</span>; ++n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//假设每轮序列中第一个元素为最小</span></span><br><span class="line">        <span class="type">int</span> min = n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到最小元素的下标（m=n为自己和自己比,可以优化掉）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = n+<span class="number">1</span>; m &lt; bufsize; ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//比较找到最小元素下标</span></span><br><span class="line">            <span class="keyword">if</span>(buf[min] &gt; buf[m])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新最小值下标</span></span><br><span class="line">                min = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把最小元素放到前面（交换元素）</span></span><br><span class="line">        temp = buf[n];</span><br><span class="line">        buf[n] = buf[min];</span><br><span class="line">        buf[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    SelectSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 十 选择排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构九（冒泡排序BubbleSort）</title>
      <link href="/2025/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8FBubbleSort%EF%BC%89/"/>
      <url>/2025/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8FBubbleSort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>插入排序 是把无序序列依次插入到有序序列，一般是从尾部开始比较</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8FBubbleSort%EF%BC%89/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序" title="插入排序"></p><p>More info: <a href="https://github.com/gybpersist/BubbleSort">BubbleSort</a></p><h2 id="冒泡排序（BubbleSort）"><a href="#冒泡排序（BubbleSort）" class="headerlink" title="冒泡排序（BubbleSort）"></a>冒泡排序（BubbleSort）</h2><h3 id="元素两两之间进行交换，需要比较n轮-n初值为1-，每轮需要-bufsize-n-次-从左到右比较，升序"><a href="#元素两两之间进行交换，需要比较n轮-n初值为1-，每轮需要-bufsize-n-次-从左到右比较，升序" class="headerlink" title="元素两两之间进行交换，需要比较n轮(n初值为1)，每轮需要 bufsize-n 次(从左到右比较，升序)"></a>元素两两之间进行交换，需要比较n轮(n初值为1)，每轮需要 bufsize-n 次(从左到右比较，升序)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份元素 临时存储交换值</span></span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 循环比较元素，比较的第n轮，总共需要比较(bufsize-1)轮</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt; bufsize; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每轮比较中需要 两两比较 的次数为（n=1 两两比较bufsize-1次；n=2 两两比较bufsize-2次...）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span> ; m &lt; bufsize-n ; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//两两比较</span></span><br><span class="line">            <span class="keyword">if</span>(buf[m] &gt; buf[m+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp=buf[m];</span><br><span class="line">                buf[m]=buf[m+<span class="number">1</span>];</span><br><span class="line">                buf[m+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素（Prin）"><a href="#遍历元素（Prin）" class="headerlink" title="遍历元素（Prin）"></a>遍历元素（Prin）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    BubbleSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element:<span class="number">2</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">1</span>  <span class="number">7</span>  <span class="number">4</span></span><br><span class="line">Element:<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序 是元素两两之间进行交换，需要比较n轮（n初值为1），每轮需要 bufsize-n 次(从左到右比较，升序)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份元素 临时存储交换值</span></span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 循环比较元素，比较的第n轮，总共需要比较(bufsize-1)轮</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt; bufsize; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每轮比较中需要 两两比较 的次数为（n=1 两两比较bufsize-1次；n=2 两两比较bufsize-2次...）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span> ; m &lt; bufsize-n ; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//两两比较</span></span><br><span class="line">            <span class="keyword">if</span>(buf[m] &gt; buf[m+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp=buf[m];</span><br><span class="line">                buf[m]=buf[m+<span class="number">1</span>];</span><br><span class="line">                buf[m+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    BubbleSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 九 冒泡排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构八（插入排序InsertSort）</title>
      <link href="/2025/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%EF%BC%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8FInsertSort%EF%BC%89/"/>
      <url>/2025/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%EF%BC%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8FInsertSort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>插入排序 是把无序序列依次插入到有序序列，一般是从尾部开始比较</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%EF%BC%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8FInsertSort%EF%BC%89/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg" alt="插入排序" title="插入排序"></p><p>More info: <a href="https://github.com/gybpersist/InsertSort">InsertSort</a></p><h2 id="插入排序（InsertSort）"><a href="#插入排序（InsertSort）" class="headerlink" title="插入排序（InsertSort）"></a>插入排序（InsertSort）</h2><h3 id="把无序序列的第一个当有序序列，然后每次从无序序列中拿出一个元素-在有序序列中进行比较（一般是从尾部开始比较）"><a href="#把无序序列的第一个当有序序列，然后每次从无序序列中拿出一个元素-在有序序列中进行比较（一般是从尾部开始比较）" class="headerlink" title="把无序序列的第一个当有序序列，然后每次从无序序列中拿出一个元素 在有序序列中进行比较（一般是从尾部开始比较）"></a>把无序序列的第一个当有序序列，然后每次从无序序列中拿出一个元素 在有序序列中进行比较（一般是从尾部开始比较）</h3><h3 id="1-如果比较结果为-待插入大于被比较的有序元素-则把待插入元素插入到被比较的有序元素后面"><a href="#1-如果比较结果为-待插入大于被比较的有序元素-则把待插入元素插入到被比较的有序元素后面" class="headerlink" title="1.如果比较结果为 待插入大于被比较的有序元素 则把待插入元素插入到被比较的有序元素后面"></a>1.如果比较结果为 待插入大于被比较的有序元素 则把待插入元素插入到被比较的有序元素后面</h3><h3 id="2-如果比较结果为-待插入小于被比较的有序元素-则把被比较的元素向后移动一位（依次与有序元素进行比较）直到来到首位或大于被比较的元素"><a href="#2-如果比较结果为-待插入小于被比较的有序元素-则把被比较的元素向后移动一位（依次与有序元素进行比较）直到来到首位或大于被比较的元素" class="headerlink" title="2.如果比较结果为 待插入小于被比较的有序元素 则把被比较的元素向后移动一位（依次与有序元素进行比较）直到来到首位或大于被比较的元素"></a>2.如果比较结果为 待插入小于被比较的有序元素 则把被比较的元素向后移动一位（依次与有序元素进行比较）直到来到首位或大于被比较的元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份元素</span></span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 选择第一个元素作为已经排序过的，剩下的元素作为无序序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; bufsize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//备份待插入元素</span></span><br><span class="line">        temp = buf[i];</span><br><span class="line">        <span class="comment">//备份待插入元素下标</span></span><br><span class="line">        <span class="type">int</span> subscript=i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把当前待插入元素与有序序列中元素进行比较，从有序序列尾部开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">-1</span> ; j &gt;= <span class="number">0</span> ; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当待插入元素 &gt; 当待插入元素前面的值</span></span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= buf[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当待插入元素 &lt; 当待插入元素前面的值</span></span><br><span class="line">            <span class="keyword">if</span>(temp &lt; buf[j])</span><br><span class="line">            &#123;</span><br><span class="line">                subscript=j;</span><br><span class="line">                <span class="comment">//把待插入元素前面的值向后移动</span></span><br><span class="line">                buf[j + <span class="number">1</span>] = buf[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把待插入元素插入指定位置</span></span><br><span class="line">        buf[subscript]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历元素（Prin）"><a href="#遍历元素（Prin）" class="headerlink" title="遍历元素（Prin）"></a>遍历元素（Prin）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    InsertSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element:<span class="number">2</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">1</span>  <span class="number">7</span>  <span class="number">4</span></span><br><span class="line">Element:<span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序 是把无序序列依次插入到有序序列，一般是从尾部开始比较</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> bufsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备份元素</span></span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 选择第一个元素作为已经排序过的，剩下的元素作为无序序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; bufsize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//备份待插入元素</span></span><br><span class="line">        temp = buf[i];</span><br><span class="line">        <span class="comment">//备份待插入元素下标</span></span><br><span class="line">        <span class="type">int</span> subscript=i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把当前待插入元素与有序序列中元素进行比较，从有序序列尾部开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">-1</span> ; j &gt;= <span class="number">0</span> ; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当待插入元素 &gt; 当待插入元素前面的值</span></span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= buf[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当待插入元素 &lt; 当待插入元素前面的值</span></span><br><span class="line">            <span class="keyword">if</span>(temp &lt; buf[j])</span><br><span class="line">            &#123;</span><br><span class="line">                subscript=j;</span><br><span class="line">                <span class="comment">//把待插入元素前面的值向后移动</span></span><br><span class="line">                buf[j + <span class="number">1</span>] = buf[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把待插入元素插入指定位置</span></span><br><span class="line">        buf[subscript]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Prin</span><span class="params">(<span class="type">int</span> buf[],<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个数组 10个整数</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    InsertSort(buf, <span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    Prin(buf,<span class="keyword">sizeof</span>(buf)/ <span class="keyword">sizeof</span>(buf[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 八 插入排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构七（二叉树BSTree）</title>
      <link href="/2025/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91BSTree%EF%BC%89/"/>
      <url>/2025/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91BSTree%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>设计BST二叉查找树，方便对二叉树进行结点的增删，采用双向不循环链表实现，每个结点<br>都需要2个指针，分别指向该结点的左子树（lchild）和右子树（rchild）<br>附加1：计算所有节点的数量<br>附加2: 计算所以叶子节点的数量（度为0）<br>附加3: 计算二叉树的深度</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91BSTree%EF%BC%89/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树" title="二叉树"></p><p>More info: <a href="https://github.com/gybpersist/BSTree">BSTree</a></p><h2 id="构造二叉树（BSTree）"><a href="#构造二叉树（BSTree）" class="headerlink" title="构造二叉树（BSTree）"></a>构造二叉树（BSTree）</h2><h3 id="构造BST树的结点-BST树中所以结点的数据类型应该是相同的（BSTreeNode）"><a href="#构造BST树的结点-BST树中所以结点的数据类型应该是相同的（BSTreeNode）" class="headerlink" title="构造BST树的结点 BST树中所以结点的数据类型应该是相同的（BSTreeNode）"></a>构造BST树的结点 BST树中所以结点的数据类型应该是相同的（BSTreeNode）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> &#123;</span></span><br><span class="line">    dataType_t Keyval;                 <span class="comment">//BST树的键值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> *<span class="title">lchild</span>;</span>      <span class="comment">//BST树的左子树的指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> *<span class="title">rchild</span>;</span>      <span class="comment">//BST树的右子树的指针域</span></span><br><span class="line">&#125; BSTNode_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个带根结点的BST树，对BST树的根结点进行初始化（BSTree-Create）"><a href="#创建一个带根结点的BST树，对BST树的根结点进行初始化（BSTree-Create）" class="headerlink" title="创建一个带根结点的BST树，对BST树的根结点进行初始化（BSTree_Create）"></a>创建一个带根结点的BST树，对BST树的根结点进行初始化（BSTree_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BSTNode_t* <span class="title function_">BSTree_Create</span><span class="params">(dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个根结点并给根结点申请内存</span></span><br><span class="line">    BSTNode_t *Root = (BSTNode_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BSTNode_t));</span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Root is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对根结点进行初始化</span></span><br><span class="line">    Root-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    Root-&gt;Keyval = Keyval;</span><br><span class="line">    Root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（BSTree-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（BSTree-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（BSTree_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（BSTree_NewNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BSTNode_t *<span class="title function_">BSTree_NewNode</span><span class="params">(dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    BSTNode_t *NewNode = (BSTNode_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(BSTNode_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域2个）</span></span><br><span class="line">    NewNode-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    NewNode-&gt;Keyval = Keyval;</span><br><span class="line">    NewNode-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向BST树中加入结点-根结点的左子树键值比根结点的键值小，根结点的右子树键值比根结点的键值大-体现递归思想（BSTree-InsertNode）"><a href="#向BST树中加入结点-根结点的左子树键值比根结点的键值小，根结点的右子树键值比根结点的键值大-体现递归思想（BSTree-InsertNode）" class="headerlink" title="向BST树中加入结点  根结点的左子树键值比根结点的键值小，根结点的右子树键值比根结点的键值大 体现递归思想（BSTree_InsertNode）"></a>向BST树中加入结点  根结点的左子树键值比根结点的键值小，根结点的右子树键值比根结点的键值大 体现递归思想（BSTree_InsertNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_InsertNode</span><span class="params">(BSTNode_t *Root,dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.0 避免根结点地址丢失，对根结点地址进行备份</span></span><br><span class="line">    BSTNode_t *Proot = Root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.1 创建新结点并对新结点进行初始化</span></span><br><span class="line">    BSTNode_t *NewNode = BSTree_NewNode(Keyval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 此时分析当前BST树是否为空树（空树 or 非空树）</span></span><br><span class="line">    <span class="comment">//为空树</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把新结点做为BST树的根结点</span></span><br><span class="line">        Root = NewNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//为非空树,2种情况（键值 等于/不等于 根结点）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(Proot)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//新结点的键值和当前新的根结点的键值比较,相等 直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(NewNode-&gt;Keyval == Proot-&gt;Keyval)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Can Not Insert,......\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//新结点的键值和当前新的根结点的键值比较,不相等 继续分析</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//新结点的键值和当前新的根结点的键值比较,小于 把根结点的左子树作为新的根</span></span><br><span class="line">                <span class="keyword">if</span>(NewNode-&gt;Keyval &lt; Proot-&gt;Keyval)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Proot-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Proot-&gt;lchild = NewNode;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Proot = Proot-&gt;lchild;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  <span class="comment">//新结点的键值和当前新的根结点的键值比较,大于 把根结点的右子树作为新的根</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Proot-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Proot-&gt;rchild = NewNode;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Proot = Proot-&gt;rchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前序遍历-根左右-体现递归思想（BSTree-PreOrder）"><a href="#前序遍历-根左右-体现递归思想（BSTree-PreOrder）" class="headerlink" title="前序遍历 根左右 体现递归思想（BSTree_PreOrder）"></a>前序遍历 根左右 体现递归思想（BSTree_PreOrder）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_PreOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  \n&quot;</span>,Root-&gt;Keyval);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在输出根节点的左子树</span></span><br><span class="line">    BSTree_PreOrder(Root-&gt;lchild);</span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_PreOrder(Root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历-左根右-体现递归思想（BSTree-InOrder）"><a href="#中序遍历-左根右-体现递归思想（BSTree-InOrder）" class="headerlink" title="中序遍历 左根右 体现递归思想（BSTree_InOrder）"></a>中序遍历 左根右 体现递归思想（BSTree_InOrder）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_InOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先输出根节点的左子树</span></span><br><span class="line">    BSTree_InOrder(Root-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  \n&quot;</span>,Root-&gt;Keyval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_InOrder(Root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历-左右根-体现递归思想（BSTree-PostOrder）"><a href="#后序遍历-左右根-体现递归思想（BSTree-PostOrder）" class="headerlink" title="后序遍历 左右根 体现递归思想（BSTree_PostOrder）"></a>后序遍历 左右根 体现递归思想（BSTree_PostOrder）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_PostOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先输出根节点的左子树</span></span><br><span class="line">    BSTree_PostOrder(Root-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_PostOrder(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  \n&quot;</span>,Root-&gt;Keyval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附加1：计算所有节点的数量-可采用递归（BSTree-CountNode）"><a href="#附加1：计算所有节点的数量-可采用递归（BSTree-CountNode）" class="headerlink" title="附加1：计算所有节点的数量 可采用递归（BSTree_CountNode）"></a>附加1：计算所有节点的数量 可采用递归（BSTree_CountNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BSTree_CountNode</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的节点数</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设采用后序遍历计算节点数量</span></span><br><span class="line">    n1 = BSTree_CountNode(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_CountNode(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n1 + n2 +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附加2：计算所有叶子节点的数量-可采用递归（BSTree-CountLeafNode）"><a href="#附加2：计算所有叶子节点的数量-可采用递归（BSTree-CountLeafNode）" class="headerlink" title="附加2：计算所有叶子节点的数量 可采用递归（BSTree_CountLeafNode）"></a>附加2：计算所有叶子节点的数量 可采用递归（BSTree_CountLeafNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BSTree_CountLeafNode</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的节点数</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明只有一个根节点</span></span><br><span class="line">    <span class="keyword">if</span>(Root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; Root-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明有子树</span></span><br><span class="line">    n1 = BSTree_CountLeafNode(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_CountLeafNode(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附加3：计算二叉树的深度-可采用递归（BSTree-GetDepth）"><a href="#附加3：计算二叉树的深度-可采用递归（BSTree-GetDepth）" class="headerlink" title="附加3：计算二叉树的深度 可采用递归（BSTree_GetDepth）"></a>附加3：计算二叉树的深度 可采用递归（BSTree_GetDepth）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BSTree_GetDepth</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的深度</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的深度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    //被下面情况包括</span></span><br><span class="line"><span class="comment">//    //说明只有一个根节点</span></span><br><span class="line"><span class="comment">//    if(Root-&gt;lchild == NULL &amp;&amp; Root-&gt;rchild == NULL)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return 1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明有子树 计算左子树的深度 再 计算右子树的深度 最后 比较找最大再加一</span></span><br><span class="line">    n1 = BSTree_GetDepth(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_GetDepth(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ( (n1&gt;n2)?n1:n2 ) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1 创建一个带根节点的BST树</span></span><br><span class="line">    BSTNode_t *Root = BSTree_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向BST树插入新节点</span></span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">5</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">20</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">7</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">12</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">8</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">3</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">25</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//                     10</span></span><br><span class="line"><span class="comment">//            5                   20</span></span><br><span class="line"><span class="comment">//        3       7           12      25</span></span><br><span class="line"><span class="comment">//                    8                     26</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;前序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_PreOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n中序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_InOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n后序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_PostOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n总节点数：%d&quot;</span>,BSTree_CountNode(Root));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n所有叶子节点数：%d&quot;</span>,BSTree_CountLeafNode(Root));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n二叉树的深度：%d&quot;</span>,BSTree_GetDepth(Root));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">前序遍历为:</span><br><span class="line"><span class="number">10</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">20</span>  <span class="number">12</span>  <span class="number">25</span>  <span class="number">26</span></span><br><span class="line">中序遍历为:</span><br><span class="line"><span class="number">3</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">10</span>  <span class="number">12</span>  <span class="number">20</span>  <span class="number">25</span>  <span class="number">26</span></span><br><span class="line">后序遍历为:</span><br><span class="line"><span class="number">3</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">5</span>  <span class="number">12</span>  <span class="number">26</span>  <span class="number">25</span>  <span class="number">20</span>  <span class="number">10</span></span><br><span class="line">总节点数：<span class="number">9</span></span><br><span class="line">所有叶子节点数：<span class="number">4</span></span><br><span class="line">二叉树的深度：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设计BST二叉查找树，方便对二叉树进行节点的增删，采用双向不循环链表实现，每个节点</span></span><br><span class="line"><span class="comment">都需要2个指针，分别指向该节点的左子树（lchild）和右子树（rchild）</span></span><br><span class="line"><span class="comment">附加1：计算所有节点的数量</span></span><br><span class="line"><span class="comment">附加2: 计算所以叶子节点的数量（度为0）</span></span><br><span class="line"><span class="comment">附加3: 计算二叉树的深度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名 节点有效键值</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造BST树的节点 BST树中所以节点的数据类型应该是相同的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> &#123;</span></span><br><span class="line">    dataType_t Keyval;                 <span class="comment">//BST树的键值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> *<span class="title">lchild</span>;</span>      <span class="comment">//BST树的左子树的指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span> *<span class="title">rchild</span>;</span>      <span class="comment">//BST树的右子树的指针域</span></span><br><span class="line">&#125; BSTNode_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建一个带根节点的BST树，对BST树的根节点进行初始化</span></span><br><span class="line">BSTNode_t* <span class="title function_">BSTree_Create</span><span class="params">(dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个根节点并给根节点申请内存</span></span><br><span class="line">    BSTNode_t *Root = (BSTNode_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BSTNode_t));</span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Root is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对根节点进行初始化</span></span><br><span class="line">    Root-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    Root-&gt;Keyval = Keyval;</span><br><span class="line">    Root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头节点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 创建新的节点，并对新节点进行初始化（数据域 指针域）</span></span><br><span class="line">BSTNode_t *<span class="title function_">BSTree_NewNode</span><span class="params">(dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新节点并给新节点申请内存</span></span><br><span class="line">    BSTNode_t *NewNode = (BSTNode_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(BSTNode_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新节点进行初始化（数据域 指针域2个）</span></span><br><span class="line">    NewNode-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    NewNode-&gt;Keyval = Keyval;</span><br><span class="line">    NewNode-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新节点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//3 向BST树中加入节点  根节点的左子树键值比根节点的键值小，根节点的右子树键值比根节点的键值大 体现递归思想</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_InsertNode</span><span class="params">(BSTNode_t *Root,dataType_t Keyval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.0 避免根节点地址丢失，对根节点地址进行备份</span></span><br><span class="line">    BSTNode_t *Proot = Root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.1 创建新节点并对新节点进行初始化</span></span><br><span class="line">    BSTNode_t *NewNode = BSTree_NewNode(Keyval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 此时分析当前BST树是否为空树（空树 or 非空树）</span></span><br><span class="line">    <span class="comment">//为空树</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把新节点做为BST树的根节点</span></span><br><span class="line">        Root = NewNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//为非空树,2种情况（键值 等于/不等于 根节点）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(Proot)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//新节点的键值和当前新的根节点的键值比较,相等 直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(NewNode-&gt;Keyval == Proot-&gt;Keyval)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Can Not Insert,......\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//新节点的键值和当前新的根节点的键值比较,不相等 继续分析</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//新节点的键值和当前新的根节点的键值比较,小于 把根节点的左子树作为新的根</span></span><br><span class="line">                <span class="keyword">if</span>(NewNode-&gt;Keyval &lt; Proot-&gt;Keyval)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Proot-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Proot-&gt;lchild = NewNode;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Proot = Proot-&gt;lchild;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  <span class="comment">//新节点的键值和当前新的根节点的键值比较,大于 把根节点的右子树作为新的根</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Proot-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Proot-&gt;rchild = NewNode;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Proot = Proot-&gt;rchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 前序遍历 根左右 体现递归思想</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_PreOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,Root-&gt;Keyval);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在输出根节点的左子树</span></span><br><span class="line">    BSTree_PreOrder(Root-&gt;lchild);</span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_PreOrder(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 中序遍历 左根右 体现递归思想</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_InOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先输出根节点的左子树</span></span><br><span class="line">    BSTree_InOrder(Root-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,Root-&gt;Keyval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_InOrder(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 后序遍历 左右根 体现递归思想</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BSTree_PostOrder</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先输出根节点的左子树</span></span><br><span class="line">    BSTree_PostOrder(Root-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的右子树</span></span><br><span class="line">    BSTree_PostOrder(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在输出根节点的键值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,Root-&gt;Keyval);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 附加1：计算所有节点的数量 可采用递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BSTree_CountNode</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的节点数</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设采用后序遍历计算节点数量</span></span><br><span class="line">    n1 = BSTree_CountNode(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_CountNode(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n1 + n2 +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 附加2：计算所有叶子节点的数量 可采用递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BSTree_CountLeafNode</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的节点数</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明只有一个根节点</span></span><br><span class="line">    <span class="keyword">if</span>(Root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; Root-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明有子树</span></span><br><span class="line">    n1 = BSTree_CountLeafNode(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_CountLeafNode(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 附加3：计算二叉树的深度 可采用递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BSTree_GetDepth</span><span class="params">(BSTNode_t *Root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>;     <span class="comment">//记录左子树的深度</span></span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">0</span>;     <span class="comment">//记录右子树的深度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归函数，必须先写好终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (Root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    //被下面情况包括</span></span><br><span class="line"><span class="comment">//    //说明只有一个根节点</span></span><br><span class="line"><span class="comment">//    if(Root-&gt;lchild == NULL &amp;&amp; Root-&gt;rchild == NULL)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return 1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明有子树 计算左子树的深度 再 计算右子树的深度 最后 比较找最大再加一</span></span><br><span class="line">    n1 = BSTree_GetDepth(Root-&gt;lchild);</span><br><span class="line">    n2 = BSTree_GetDepth(Root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ( (n1&gt;n2)?n1:n2 ) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1 创建一个带根节点的BST树</span></span><br><span class="line">    BSTNode_t *Root = BSTree_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向BST树插入新节点</span></span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">5</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">20</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">7</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">12</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">8</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">3</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">25</span>);</span><br><span class="line">    BSTree_InsertNode(Root,<span class="number">26</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//                     10</span></span><br><span class="line"><span class="comment">//            5                   20</span></span><br><span class="line"><span class="comment">//        3       7           12      25</span></span><br><span class="line"><span class="comment">//                    8                     26</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;前序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_PreOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n中序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_InOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n后序遍历为:\n&quot;</span>);</span><br><span class="line">    BSTree_PostOrder(Root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n总节点数：%d&quot;</span>,BSTree_CountNode(Root));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n所有叶子节点数：%d&quot;</span>,BSTree_CountLeafNode(Root));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n二叉树的深度：%d&quot;</span>,BSTree_GetDepth(Root));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 七 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构六（顺序栈sequenceStack）</title>
      <link href="/2025/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/"/>
      <url>/2025/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个顺序栈实现对顺序栈内元素的<br> ——入栈<br> ——出栈<br> ——遍历顺序栈</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/%E9%A1%BA%E5%BA%8F%E6%A0%88.jpg" alt="顺序栈" title="顺序栈"></p><p>More info: <a href="https://github.com/gybpersist/sequenceStack">sequenceStack</a></p><h2 id="构造顺序栈（sequenceStack）"><a href="#构造顺序栈（sequenceStack）" class="headerlink" title="构造顺序栈（sequenceStack）"></a>构造顺序栈（sequenceStack）</h2><h3 id="构造顺序栈记录参数-顺序栈的栈底地址-顺序栈的容量-顺序栈的栈顶元素的下标"><a href="#构造顺序栈记录参数-顺序栈的栈底地址-顺序栈的容量-顺序栈的栈顶元素的下标" class="headerlink" title="构造顺序栈记录参数(顺序栈的栈底地址 顺序栈的容量 顺序栈的栈顶元素的下标)"></a>构造顺序栈记录参数(顺序栈的栈底地址 顺序栈的容量 顺序栈的栈顶元素的下标)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sequenceStack</span> &#123;</span></span><br><span class="line">    dataType_t *Bottom;       <span class="comment">//顺序栈的栈底地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;      <span class="comment">//顺序栈的容量</span></span><br><span class="line">    <span class="type">int</span> Top;               <span class="comment">//顺序栈的栈顶元素的下标</span></span><br><span class="line">&#125; sqStack_t;</span><br></pre></td></tr></table></figure><h2 id="创建顺序栈并对顺序栈进行初始化（sqStack-Create）"><a href="#创建顺序栈并对顺序栈进行初始化（sqStack-Create）" class="headerlink" title="创建顺序栈并对顺序栈进行初始化（sqStack_Create）"></a>创建顺序栈并对顺序栈进行初始化（sqStack_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sqStack_t *<span class="title function_">sqStack_Create</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 利用calloc为顺序栈的管理结构体申请堆内存</span></span><br><span class="line">    sqStack_t *manager = (sqStack_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (manager));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for manager is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 为所有元素申请堆内存 calloc,并完成错误处理</span></span><br><span class="line">    manager-&gt;Bottom = (dataType_t*)<span class="built_in">calloc</span>(size,<span class="keyword">sizeof</span>(dataType_t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager-&gt;Bottom)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for element is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(manager);  <span class="comment">//释放内存</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 对管理顺序栈的结构体进行初始化（元素容量 最后元素下标）</span></span><br><span class="line">    manager-&gt;size = size; <span class="comment">//对顺序栈的容量进行初始化</span></span><br><span class="line">    manager-&gt;Top = <span class="number">-1</span>;   <span class="comment">//由于顺序栈为空，则最后元素下标初值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序栈是否以满（sqStack-IsFull）"><a href="#判断顺序栈是否以满（sqStack-IsFull）" class="headerlink" title="判断顺序栈是否以满（sqStack_IsFull）"></a>判断顺序栈是否以满（sqStack_IsFull）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断顺序栈是否以满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_IsFull</span><span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;Top+<span class="number">1</span> == manager-&gt;size) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//        if(manager-&gt;Top+1 == manager-&gt;size)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return ture;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return false;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入栈-sqStack-Push"><a href="#入栈-sqStack-Push" class="headerlink" title="入栈(sqStack_Push)"></a>入栈(sqStack_Push)</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/%E5%85%A5%E6%A0%88.png" alt="入栈" title="入栈"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_Push</span> <span class="params">(sqStack_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 判断顺序栈是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqStack_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceStack is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 若顺序栈有空闲空间，则把新元素添加到顺序栈尾部</span></span><br><span class="line"><span class="comment">/*    manager-&gt;Top++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Bottom + manager-&gt;Top) = data;   */</span></span><br><span class="line">    manager-&gt;Bottom[++manager-&gt;Top] = data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序栈是否为空（sqStack-IsEmpty）"><a href="#判断顺序栈是否为空（sqStack-IsEmpty）" class="headerlink" title="判断顺序栈是否为空（sqStack_IsEmpty）"></a>判断顺序栈是否为空（sqStack_IsEmpty）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_IsEmpty</span><span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;Top == <span class="number">-1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出栈（sqStack-Pop）"><a href="#出栈（sqStack-Pop）" class="headerlink" title="出栈（sqStack_Pop）"></a>出栈（sqStack_Pop）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%A0%88sequenceStack%EF%BC%89/%E5%87%BA%E6%A0%88.png" alt="出栈" title="出栈"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dataType_t <span class="title function_">sqStack_Pop</span> <span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    dataType_t temp=<span class="number">-1</span>;     <span class="comment">//记录需要出栈的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.1 判断顺序栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(sqStack_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SequenceStack is Empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 由于删掉一个元素，则顺序栈有效元素下标减一 后--（先赋值后--）</span></span><br><span class="line">    temp = manager-&gt;Bottom[manager-&gt;Top--];</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return manager-&gt;Bottom[manager-&gt;Top--];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历顺序栈（sqStack-print）"><a href="#遍历顺序栈（sqStack-print）" class="headerlink" title="遍历顺序栈（sqStack_print）"></a>遍历顺序栈（sqStack_print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5 遍历顺序栈中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqStack_print</span> <span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=manager-&gt;Top;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element[%d]=%d\n&quot;</span>,i,manager-&gt;Bottom[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 创建顺序栈</span></span><br><span class="line">    sqStack_t *manager = sqStack_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向顺序栈  入栈</span></span><br><span class="line">    sqStack_Push (manager,<span class="number">5</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">2</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">1</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">4</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">6</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 遍历顺序栈</span></span><br><span class="line">    sqStack_print (manager);     <span class="comment">//5 2 1 4 6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6 出栈</span></span><br><span class="line">    dataType_t temp1,temp2,temp3,temp4;</span><br><span class="line">    </span><br><span class="line">    temp1 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp1);</span><br><span class="line"></span><br><span class="line">    temp2 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp2);</span><br><span class="line"></span><br><span class="line">    temp3 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp3);</span><br><span class="line"></span><br><span class="line">    temp4 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d\n&quot;</span>,temp4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7 遍历顺序栈</span></span><br><span class="line">    sqStack_print (manager);     <span class="comment">//8 8 4 8 2 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Element[<span class="number">0</span>]=<span class="number">5</span></span><br><span class="line">Element[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line">Element[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">Element[<span class="number">3</span>]=<span class="number">4</span></span><br><span class="line">Element[<span class="number">4</span>]=<span class="number">6</span></span><br><span class="line">Element[<span class="number">5</span>]=<span class="number">8</span></span><br><span class="line"></span><br><span class="line"> 出栈：<span class="number">8</span>  出栈：<span class="number">6</span>  出栈：<span class="number">4</span>  出栈：<span class="number">1</span></span><br><span class="line">Element[<span class="number">0</span>]=<span class="number">5</span></span><br><span class="line">Element[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造顺序栈记录参数(顺序栈的栈底地址 顺序栈的容量 顺序栈的栈顶元素的下标)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sequenceStack</span> &#123;</span></span><br><span class="line">    dataType_t *Bottom;       <span class="comment">//顺序栈的栈底地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;      <span class="comment">//顺序栈的容量</span></span><br><span class="line">    <span class="type">int</span> Top;               <span class="comment">//顺序栈的栈顶元素的下标</span></span><br><span class="line">&#125; sqStack_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建顺序栈并对顺序栈进行初始化</span></span><br><span class="line">sqStack_t *<span class="title function_">sqStack_Create</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 利用calloc为顺序栈的管理结构体申请堆内存</span></span><br><span class="line">    sqStack_t *manager = (sqStack_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (manager));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for manager is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 为所有元素申请堆内存 calloc,并完成错误处理</span></span><br><span class="line">    manager-&gt;Bottom = (dataType_t*)<span class="built_in">calloc</span>(size,<span class="keyword">sizeof</span>(dataType_t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager-&gt;Bottom)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for element is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(manager);  <span class="comment">//释放内存</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 对管理顺序栈的结构体进行初始化（元素容量 最后元素下标）</span></span><br><span class="line">    manager-&gt;size = size; <span class="comment">//对顺序栈的容量进行初始化</span></span><br><span class="line">    manager-&gt;Top = <span class="number">-1</span>;   <span class="comment">//由于顺序栈为空，则最后元素下标初值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//判断顺序栈是否以满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_IsFull</span><span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;Top+<span class="number">1</span> == manager-&gt;size) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//        if(manager-&gt;Top+1 == manager-&gt;size)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return ture;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return false;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 顺序栈   入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_Push</span> <span class="params">(sqStack_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 判断顺序栈是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqStack_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceStack is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 若顺序栈有空闲空间，则把新元素添加到顺序栈尾部</span></span><br><span class="line"><span class="comment">/*    manager-&gt;Bottom++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Bottom + manager-&gt;Top) = data;   */</span></span><br><span class="line">    manager-&gt;Bottom[++manager-&gt;Top] = data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//判断顺序栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqStack_IsEmpty</span><span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;Top == <span class="number">-1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//4 顺序栈  出栈</span></span><br><span class="line">dataType_t <span class="title function_">sqStack_Pop</span> <span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    dataType_t temp=<span class="number">-1</span>;     <span class="comment">//记录需要出栈的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.1 判断顺序栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(sqStack_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SequenceStack is Empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 由于删掉一个元素，则顺序栈有效元素下标减一 后--（先赋值后--）</span></span><br><span class="line">    temp = manager-&gt;Bottom[manager-&gt;Top--];</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return manager-&gt;Bottom[manager-&gt;Top--];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//5 遍历顺序栈中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqStack_print</span> <span class="params">(sqStack_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=manager-&gt;Top;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element[%d]=%d\n&quot;</span>,i,manager-&gt;Bottom[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 创建顺序栈</span></span><br><span class="line">    sqStack_t *manager = sqStack_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向顺序栈  入栈</span></span><br><span class="line">    sqStack_Push (manager,<span class="number">5</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">2</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">1</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">4</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">6</span>);</span><br><span class="line">    sqStack_Push (manager,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 遍历顺序栈</span></span><br><span class="line">    sqStack_print (manager);     <span class="comment">//5 2 1 4 6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6 出栈</span></span><br><span class="line">    dataType_t temp1,temp2,temp3,temp4;</span><br><span class="line">    </span><br><span class="line">    temp1 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp1);</span><br><span class="line"></span><br><span class="line">    temp2 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp2);</span><br><span class="line"></span><br><span class="line">    temp3 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d &quot;</span>,temp3);</span><br><span class="line"></span><br><span class="line">    temp4 = sqStack_Pop (manager);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; 出栈：%d\n&quot;</span>,temp4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7 遍历顺序栈</span></span><br><span class="line">    sqStack_print (manager);     <span class="comment">//8 8 4 8 2 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 六 顺序栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 顺序栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构五（双向循环链表DoubleCirLList）</title>
      <link href="/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCircularLinkeList%EF%BC%89/"/>
      <url>/2025/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCircularLinkeList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个双向循环链表实现对双向循环链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历双向循环链表</p><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="双向循环链表" title="双向循环链表"></p><p>More info: <a href="https://github.com/gybpersist/DoubleCirLList">DoubleCirLList</a></p><h2 id="构造双向循环链表（DoubleCirLList）"><a href="#构造双向循环链表（DoubleCirLList）" class="headerlink" title="构造双向循环链表（DoubleCirLList）"></a>构造双向循环链表（DoubleCirLList）</h2><h3 id="构造双向循环链表的结点-双向循环链表中所有结点的数据类型应该是相同的"><a href="#构造双向循环链表的结点-双向循环链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造双向循环链表的结点 双向循环链表中所有结点的数据类型应该是相同的"></a>构造双向循环链表的结点 双向循环链表中所有结点的数据类型应该是相同的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">// 双向循环链表的数据域，用于存储具体的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> *<span class="title">prev</span>;</span>   <span class="comment">// 双向循环链表的前驱指针域，指向前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> *<span class="title">next</span>;</span>   <span class="comment">// 双向循环链表的后继指针域，指向后一个节点</span></span><br><span class="line">&#125; DoubleLList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（DoubleCirLList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（DoubleCirLList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（DoubleCirLList_Create）"></a>创建一个空链表，空链表应该有一个头结点（DoubleCirLList_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t* <span class="title function_">DoubleCirLList_Create</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个头结点并给头结点申请内存，使用 calloc 函数将内存初始化为 0</span></span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span> (Head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若内存分配失败，使用 perror 输出错误信息并退出程序</span></span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对头结点进行初始化，体现循环，将头结点的 prev 和 next 指针都指向自己</span></span><br><span class="line">    Head-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把头结点的地址返回，方便后续操作</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleCirLList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleCirLList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleCirLList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleCirLList_NewNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t *<span class="title function_">DoubleCirLList_NewNode</span><span class="params">(dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新结点并给新结点申请内存，使用 calloc 函数将内存初始化为 0</span></span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若内存分配失败，使用 perror 输出错误信息并返回 NULL</span></span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对新结点进行初始化（数据域 指针域2个），体现循环，将新结点的 prev 和 next 指针都指向自己</span></span><br><span class="line">    NewNode-&gt;prev = NewNode;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把新结点的地址返回，方便后续操作</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入新节点到指定节点之后（insertAfter）"><a href="#插入新节点到指定节点之后（insertAfter）" class="headerlink" title="插入新节点到指定节点之后（insertAfter）"></a>插入新节点到指定节点之后（insertAfter）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertAfter</span><span class="params">(DoubleLList_t *node, DoubleLList_t *newNode)</span> &#123;</span><br><span class="line">    <span class="comment">// 将新节点的 next 指针指向指定节点的下一个节点</span></span><br><span class="line">    newNode-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="comment">// 将新节点的 prev 指针指向指定节点</span></span><br><span class="line">    newNode-&gt;prev = node;</span><br><span class="line">    <span class="comment">// 将指定节点的下一个节点的 prev 指针指向新节点</span></span><br><span class="line">    node-&gt;next-&gt;prev = newNode;</span><br><span class="line">    <span class="comment">// 将指定节点的 next 指针指向新节点</span></span><br><span class="line">    node-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（DoubleCirLList-HeadInsert）"><a href="#头插（DoubleCirLList-HeadInsert）" class="headerlink" title="头插（DoubleCirLList_HeadInsert）"></a>头插（DoubleCirLList_HeadInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_HeadInsert</span><span class="params">(DoubleLList_t *Head, dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">//3.1建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        Head-&gt;prev = NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下四步操作将新节点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（DoubleCirLList-TailInsert）"><a href="#尾插（DoubleCirLList-TailInsert）" class="headerlink" title="尾插（DoubleCirLList_TailInsert）"></a>尾插（DoubleCirLList_TailInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_TailInsert</span><span class="params">(DoubleLList_t *Head, dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">// 将新节点的 prev 指针指向原尾节点</span></span><br><span class="line">    NewNode-&gt;prev = Head-&gt;prev;</span><br><span class="line">    <span class="comment">// 将原尾节点的 next 指针指向新节点</span></span><br><span class="line">    Head-&gt;prev-&gt;next = NewNode;</span><br><span class="line">    <span class="comment">// 将新节点的 next 指针指向头结点</span></span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    <span class="comment">// 将头结点的 prev 指针指向新节点</span></span><br><span class="line">    Head-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（DoubleCirLList-DestInsert）"><a href="#指定插入（DoubleCirLList-DestInsert）" class="headerlink" title="指定插入（DoubleCirLList_DestInsert）"></a>指定插入（DoubleCirLList_DestInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_DestInsert</span><span class="params">(DoubleLList_t *Head, dataType_t destval, dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">// 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head &amp;&amp; Phead-&gt;data != destval) &#123;</span><br><span class="line">        <span class="comment">// 若未找到目标节点且未遍历完链表，将指针移动到下一个节点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Phead == Head) &#123;</span><br><span class="line">        <span class="comment">// 未找到目标节点，释放新节点的内存并返回 false</span></span><br><span class="line">        <span class="built_in">free</span>(NewNode);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下四步操作将新节点插入到目标节点之后</span></span><br><span class="line">    NewNode-&gt;next = Phead-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Phead-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（DoubleCirLList-Print）"><a href="#遍历链表（DoubleCirLList-Print）" class="headerlink" title="遍历链表（DoubleCirLList_Print）"></a>遍历链表（DoubleCirLList_Print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_Print</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="comment">// 若链表为空，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">// 输出当前节点的数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>, i, Phead-&gt;data);</span><br><span class="line">        <span class="comment">// 将指针移动到下一个节点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除指定节点（deleteNode）"><a href="#删除指定节点（deleteNode）" class="headerlink" title="删除指定节点（deleteNode）"></a>删除指定节点（deleteNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(DoubleLList_t *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 将指定节点的前一个节点的 next 指针指向指定节点的下一个节点</span></span><br><span class="line">    node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="comment">// 将指定节点的下一个节点的 prev 指针指向指定节点的前一个节点</span></span><br><span class="line">    node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="comment">// 将指定节点的 next 和 prev 指针置为 NULL</span></span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 释放指定节点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除首结点（DoubleCirLList-HeadDel）"><a href="#头删-删除首结点（DoubleCirLList-HeadDel）" class="headerlink" title="头删 删除首结点（DoubleCirLList_HeadDel）"></a>头删 删除首结点（DoubleCirLList_HeadDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_HeadDel</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断链表是否为空，如果为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.2 对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.3 链表非空 删除首结点</span></span><br><span class="line">    <span class="comment">// 将首结点之后的结点的 prev 指针连接到头结点</span></span><br><span class="line">    Head-&gt;next-&gt;next-&gt;prev = Head;</span><br><span class="line">    <span class="comment">// 将头结点的 next 指针指向原先首结点之后的结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.4 释放首结点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    deleteNode(Head-&gt;next);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（DoubleCirLList-TailDel）"><a href="#尾删-删除尾结点（DoubleCirLList-TailDel）" class="headerlink" title="尾删 删除尾结点（DoubleCirLList_TailDel）"></a>尾删 删除尾结点（DoubleCirLList_TailDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%EF%BC%88%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8DoubleCirLList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_TailDel</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 8.1 判断判断链表是否为空，如果为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.2 记录当前尾结点的地址</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="comment">// 将头结点的 prev 指针连接到尾结点的前一个结点</span></span><br><span class="line">    Head-&gt;next-&gt;prev = Phead-&gt;prev;</span><br><span class="line">    <span class="comment">// 将尾结点的前一个结点的 next 指针连接到头结点</span></span><br><span class="line">    Phead-&gt;prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.4 释放尾结点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    deleteNode(Head-&gt;prev);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个双向循环链表</span></span><br><span class="line">    DoubleLList_t *Head = DoubleCirLList_Create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行头插操作</span></span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">5</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">8</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">1</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">6</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行尾插操作</span></span><br><span class="line">    DoubleCirLList_TailInsert(Head, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在值为 1 的节点后插入新节点</span></span><br><span class="line">    DoubleCirLList_DestInsert(Head, <span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行头删操作</span></span><br><span class="line">    DoubleCirLList_HeadDel(Head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行尾删操作</span></span><br><span class="line">    DoubleCirLList_TailDel(Head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名，将 int 类型重命名为 dataType_t，方便后续修改数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 构造双向循环链表的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">// 双向循环链表的数据域，用于存储具体的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> *<span class="title">prev</span>;</span>   <span class="comment">// 双向循环链表的前驱指针域，指向前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleCirLList</span> *<span class="title">next</span>;</span>   <span class="comment">// 双向循环链表的后继指针域，指向后一个节点</span></span><br><span class="line">&#125; DoubleLList_t;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 1 创建一个空链表，空链表应该有一个头结点</span></span><br><span class="line">DoubleLList_t* <span class="title function_">DoubleCirLList_Create</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个头结点并给头结点申请内存，使用 calloc 函数将内存初始化为 0</span></span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span> (Head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若内存分配失败，使用 perror 输出错误信息并退出程序</span></span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对头结点进行初始化，体现循环，将头结点的 prev 和 next 指针都指向自己</span></span><br><span class="line">    Head-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把头结点的地址返回，方便后续操作</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">DoubleLList_t *<span class="title function_">DoubleCirLList_NewNode</span><span class="params">(dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新结点并给新结点申请内存，使用 calloc 函数将内存初始化为 0</span></span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若内存分配失败，使用 perror 输出错误信息并返回 NULL</span></span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对新结点进行初始化（数据域 指针域2个），体现循环，将新结点的 prev 和 next 指针都指向自己</span></span><br><span class="line">    NewNode-&gt;prev = NewNode;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把新结点的地址返回，方便后续操作</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 插入新节点到指定节点之后</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertAfter</span><span class="params">(DoubleLList_t *node, DoubleLList_t *newNode)</span> &#123;</span><br><span class="line">    <span class="comment">// 将新节点的 next 指针指向指定节点的下一个节点</span></span><br><span class="line">    newNode-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="comment">// 将新节点的 prev 指针指向指定节点</span></span><br><span class="line">    newNode-&gt;prev = node;</span><br><span class="line">    <span class="comment">// 将指定节点的下一个节点的 prev 指针指向新节点</span></span><br><span class="line">    node-&gt;next-&gt;prev = newNode;</span><br><span class="line">    <span class="comment">// 将指定节点的 next 指针指向新节点</span></span><br><span class="line">    node-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 3 在链表中 头插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_HeadInsert</span><span class="params">(DoubleLList_t *Head, dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">//3.1建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        Head-&gt;prev = NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下四步操作将新节点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Head;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 4 在链表中 尾部插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_TailInsert</span><span class="params">(DoubleLList_t *Head, dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">// 将新节点的 prev 指针指向原尾节点</span></span><br><span class="line">    NewNode-&gt;prev = Head-&gt;prev;</span><br><span class="line">    <span class="comment">// 将原尾节点的 next 指针指向新节点</span></span><br><span class="line">    Head-&gt;prev-&gt;next = NewNode;</span><br><span class="line">    <span class="comment">// 将新节点的 next 指针指向头结点</span></span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    <span class="comment">// 将头结点的 prev 指针指向新节点</span></span><br><span class="line">    Head-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 5 在链表中 指定插入</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_DestInsert</span><span class="params">(DoubleLList_t *Head, dataType_t destval, dataType_t data)</span> &#123;</span><br><span class="line">    <span class="comment">// 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleCirLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若新节点创建失败，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head &amp;&amp; Phead-&gt;data != destval) &#123;</span><br><span class="line">        <span class="comment">// 若未找到目标节点且未遍历完链表，将指针移动到下一个节点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Phead == Head) &#123;</span><br><span class="line">        <span class="comment">// 未找到目标节点，释放新节点的内存并返回 false</span></span><br><span class="line">        <span class="built_in">free</span>(NewNode);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下四步操作将新节点插入到目标节点之后</span></span><br><span class="line">    NewNode-&gt;next = Phead-&gt;next;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Phead-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    insertAfter(Phead, NewNode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 6 遍历链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_Print</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="comment">// 若链表为空，输出提示信息并返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">// 输出当前节点的数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>, i, Phead-&gt;data);</span><br><span class="line">        <span class="comment">// 将指针移动到下一个节点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 删除指定节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(DoubleLList_t *node)</span> &#123;</span><br><span class="line">    <span class="comment">// 将指定节点的前一个节点的 next 指针指向指定节点的下一个节点</span></span><br><span class="line">    node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="comment">// 将指定节点的下一个节点的 prev 指针指向指定节点的前一个节点</span></span><br><span class="line">    node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="comment">// 将指定节点的 next 和 prev 指针置为 NULL</span></span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 释放指定节点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 7 头删 删除首结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_HeadDel</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断链表是否为空，如果为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.2 对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.3 链表非空 删除首结点</span></span><br><span class="line">    <span class="comment">// 将首结点之后的结点的 prev 指针连接到头结点</span></span><br><span class="line">    Head-&gt;next-&gt;next-&gt;prev = Head;</span><br><span class="line">    <span class="comment">// 将头结点的 next 指针指向原先首结点之后的结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.4 释放首结点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    deleteNode(Head-&gt;next);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 8 尾删 删除尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleCirLList_TailDel</span><span class="params">(DoubleLList_t *Head)</span> &#123;</span><br><span class="line">    <span class="comment">// 8.1 判断判断链表是否为空，如果为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (Head-&gt;next == Head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.2 记录当前尾结点的地址</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="comment">// 将头结点的 prev 指针连接到尾结点的前一个结点</span></span><br><span class="line">    Head-&gt;next-&gt;prev = Phead-&gt;prev;</span><br><span class="line">    <span class="comment">// 将尾结点的前一个结点的 next 指针连接到头结点</span></span><br><span class="line">    Phead-&gt;prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.4 释放尾结点的内存</span></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    deleteNode(Head-&gt;prev);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个双向循环链表</span></span><br><span class="line">    DoubleLList_t *Head = DoubleCirLList_Create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行头插操作</span></span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">5</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">8</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">1</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">6</span>);</span><br><span class="line">    DoubleCirLList_HeadInsert(Head, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行尾插操作</span></span><br><span class="line">    DoubleCirLList_TailInsert(Head, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在值为 1 的节点后插入新节点</span></span><br><span class="line">    DoubleCirLList_DestInsert(Head, <span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行头删操作</span></span><br><span class="line">    DoubleCirLList_HeadDel(Head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行尾删操作</span></span><br><span class="line">    DoubleCirLList_TailDel(Head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出结果</span></span><br><span class="line">    DoubleCirLList_Print(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 五 双向循环链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 双向循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构四（单向循环链表CircularLinkedList）</title>
      <link href="/2025/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/"/>
      <url>/2025/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个单向循环链表实现对单向循环链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历单向循环链表</p><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="单向循环链表" title="单向循环链表"></p><p>More info: <a href="https://github.com/gybpersist/CircularLinkedList">CircularLinkedList</a></p><h2 id="构造单向循环链表（CircularLinkedList）"><a href="#构造单向循环链表（CircularLinkedList）" class="headerlink" title="构造单向循环链表（CircularLinkedList）"></a>构造单向循环链表（CircularLinkedList）</h2><h3 id="构造单向循环链表的结点-单向循环链表中所有结点的数据类型应该是相同的"><a href="#构造单向循环链表的结点-单向循环链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造单向循环链表的结点 单向循环链表中所有结点的数据类型应该是相同的"></a>构造单向循环链表的结点 单向循环链表中所有结点的数据类型应该是相同的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CircularLinkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//单向循环链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CircularLinkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//单向循环链表的指针域</span></span><br><span class="line">&#125; CricLList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（CricLList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（CricLList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（CricLList_Create）"></a>创建一个空链表，空链表应该有一个头结点（CricLList_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CricLList_t* <span class="title function_">CricLList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    CricLList_t *Head = (CricLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (CricLList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化，头结点是不存储有效内容的</span></span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（CricLList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（CricLList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（CricLList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（CricLList_NewNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CricLList_t *<span class="title function_">CricLList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    CricLList_t *NewNode = (CricLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(CricLList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（CricLList-HeadInsert）"><a href="#头插（CricLList-HeadInsert）" class="headerlink" title="头插（CricLList_HeadInsert）"></a>头插（CricLList_HeadInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_HeadInsert</span><span class="params">(CricLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（CricLList-TailInsert）"><a href="#尾插（CricLList-TailInsert）" class="headerlink" title="尾插（CricLList_TailInsert）"></a>尾插（CricLList_TailInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_TailInsert</span><span class="params">(CricLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（CricLList-DestInsert）"><a href="#指定插入（CricLList-DestInsert）" class="headerlink" title="指定插入（CricLList_DestInsert）"></a>指定插入（CricLList_DestInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_DestInsert</span><span class="params">(CricLList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == Head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//代表循环完之后未找到 目标值destval</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（CricLList-Print）"><a href="#遍历链表（CricLList-Print）" class="headerlink" title="遍历链表（CricLList_Print）"></a>遍历链表（CricLList_Print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_Print</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点的地址进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除头结点（CricLList-HeadDel）"><a href="#头删-删除头结点（CricLList-HeadDel）" class="headerlink" title="头删 删除头结点（CricLList_HeadDel）"></a>头删 删除头结点（CricLList_HeadDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_HeadDel</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 对链表的首结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果链表只有一个节点，删除后让头结点指向自身</span></span><br><span class="line">    <span class="keyword">if</span> (Phead-&gt;next == Head) &#123;</span><br><span class="line">        Head-&gt;next = Head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（CricLList-TailDel）"><a href="#尾删-删除尾结点（CricLList-TailDel）" class="headerlink" title="尾删 删除尾结点（CricLList_TailDel）"></a>尾删 删除尾结点（CricLList_TailDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%EF%BC%88%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8CircularLinkedList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_TailDel</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 记录当前结点的地址</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    CricLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    CricLList_t *Head = CricLList_Create();            <span class="comment">//创建链表</span></span><br><span class="line"></span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造单向循环链表的结点 单向链循环表中所以结点的数据类型应该是相同的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CircularLinkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//单向链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CircularLinkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//单向链表的指针域</span></span><br><span class="line">&#125; CricLList_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建一个空链表，空链表应该有一个头结点</span></span><br><span class="line">CricLList_t* <span class="title function_">CricLList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    CricLList_t *Head = (CricLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (CricLList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化，头结点是不存储有效内容的,指针域指向自己，体现循环思想</span></span><br><span class="line">    Head-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">CricLList_t *<span class="title function_">CricLList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    CricLList_t *NewNode = (CricLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(CricLList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//3 在链表中 头插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_HeadInsert</span><span class="params">(CricLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//4 在链表中 尾部插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_TailInsert</span><span class="params">(CricLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next = NewNode;</span><br><span class="line">    NewNode-&gt;next = Head;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//5 在链表中 指定插入</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_DestInsert</span><span class="params">(CricLList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    CricLList_t *NewNode = CricLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != Head &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == Head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//代表循环完之后未找到 目标值destval</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//6 遍历链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_Print</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点的地址进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//7 头删 删除首结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_HeadDel</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 对链表的首结点进行备份</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果链表只有一个节点，删除后让头结点指向自身</span></span><br><span class="line">    <span class="keyword">if</span> (Phead-&gt;next == Head) &#123;</span><br><span class="line">        Head-&gt;next = Head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//8 尾删 删除尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CricLList_TailDel</span><span class="params">(CricLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == Head)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 记录当前结点的地址</span></span><br><span class="line">    CricLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    CricLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = Head;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    CricLList_t *Head = CricLList_Create();            <span class="comment">//创建链表</span></span><br><span class="line"></span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    CricLList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CricLList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    CricLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 四 单向循环链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 单向循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构二（单向链表linkedList）</title>
      <link href="/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/"/>
      <url>/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个单向链表实现对单向链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历单向链表</p><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="单向链表" title="单向链表"></p><p>More info: <a href="https://github.com/gybpersist/linkedList">linkedList</a></p><h2 id="构造单向链表（linkedList）"><a href="#构造单向链表（linkedList）" class="headerlink" title="构造单向链表（linkedList）"></a>构造单向链表（linkedList）</h2><h3 id="构造单向链表的结点-单向链表中所有结点的数据类型应该是相同的"><a href="#构造单向链表的结点-单向链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造单向链表的结点 单向链表中所有结点的数据类型应该是相同的"></a>构造单向链表的结点 单向链表中所有结点的数据类型应该是相同的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//单向链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//单向链表的指针域</span></span><br><span class="line">&#125; lList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（lList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（lList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（lList_Create）"></a>创建一个空链表，空链表应该有一个头结点（lList_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lList_t* <span class="title function_">lList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    lList_t *Head = (lList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (lList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化，头结点是不存储有效内容的</span></span><br><span class="line">    Head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（lList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（lList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（lList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（lList_NewNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lList_t *<span class="title function_">lList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    lList_t *NewNode = (lList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(lList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（lList-HeadInsert）"><a href="#头插（lList-HeadInsert）" class="headerlink" title="头插（lList_HeadInsert）"></a>头插（lList_HeadInsert）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lList_HeadInsert</span><span class="params">(lList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（lList-TailInsert）"><a href="#尾插（lList-TailInsert）" class="headerlink" title="尾插（lList_TailInsert）"></a>尾插（lList_TailInsert）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lList_TailInsert</span><span class="params">(lList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（lList-DestInsert）"><a href="#指定插入（lList-DestInsert）" class="headerlink" title="指定插入（lList_DestInsert）"></a>指定插入（lList_DestInsert）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lList_DestInsert</span><span class="params">(lList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != <span class="literal">NULL</span> &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（lList-Print）"><a href="#遍历链表（lList-Print）" class="headerlink" title="遍历链表（lList_Print）"></a>遍历链表（lList_Print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lList_Print</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除首结点（lList-HeadDel）"><a href="#头删-删除首结点（lList-HeadDel）" class="headerlink" title="头删 删除首结点（lList_HeadDel）"></a>头删 删除首结点（lList_HeadDel）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lList_HeadDel</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 对链表的首结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（lList-TailDel）"><a href="#尾删-删除尾结点（lList-TailDel）" class="headerlink" title="尾删 删除尾结点（lList_TailDel）"></a>尾删 删除尾结点（lList_TailDel）</h2><p> <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8linkedList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lList_TailDel</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 记录当前结点的地址</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    lList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    lList_t *Head = lList_Create();            <span class="comment">//创建链表</span></span><br><span class="line">    lList_NewNode(<span class="number">5</span>);                    <span class="comment">//创建新结点</span></span><br><span class="line"></span><br><span class="line">    lList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    lList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    lList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    lList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造单向链表的结点 单向链表中所有结点的数据类型应该是相同的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//单向链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//单向链表的指针域</span></span><br><span class="line">&#125; lList_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建一个空链表，空链表应该有一个头结点</span></span><br><span class="line">lList_t* <span class="title function_">lList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    lList_t *Head = (lList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (lList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化，头结点是不存储有效内容的</span></span><br><span class="line">    Head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">lList_t *<span class="title function_">lList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    lList_t *NewNode = (lList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(lList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//3 ccccccccc</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">lList_HeadInsert</span><span class="params">(lList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//4 在链表中 尾部插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">lList_TailInsert</span><span class="params">(lList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//5 在链表中 指定插入</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">lList_DestInsert</span><span class="params">(lList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    lList_t *NewNode = lList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != <span class="literal">NULL</span> &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//6 遍历链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lList_Print</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//7 头删 删除首结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">lList_HeadDel</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 对链表的首结点进行备份</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//8 尾删 删除尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">lList_TailDel</span><span class="params">(lList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 记录当前结点的地址</span></span><br><span class="line">    lList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    lList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    lList_t *Head = lList_Create();            <span class="comment">//创建链表</span></span><br><span class="line">    lList_NewNode(<span class="number">5</span>);                    <span class="comment">//创建新结点</span></span><br><span class="line"></span><br><span class="line">    lList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    lList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    lList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    lList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    lList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    lList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    lList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 二 单向链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 单向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构一（顺序表sequenceList）</title>
      <link href="/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8sequenceList%EF%BC%89/"/>
      <url>/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8sequenceList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- 文章内跳转[文章内目录](#前言)<p id = "前言"></p> --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个顺序表实现对顺序表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历顺序表</p><p><img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8sequenceList%EF%BC%89/%E9%A1%BA%E5%BA%8F%E8%A1%A8.png" alt="顺序表" title="顺序表"></p><p>More info: <a href="https://github.com/gybpersist/sequenceList">sequenceList</a></p><h2 id="构造顺序表（sequenceList）"><a href="#构造顺序表（sequenceList）" class="headerlink" title="构造顺序表（sequenceList）"></a>构造顺序表（sequenceList）</h2><h3 id="构造顺序表记录参数-顺序表的首地址-顺序表的容量-顺序表的有效元素的下标"><a href="#构造顺序表记录参数-顺序表的首地址-顺序表的容量-顺序表的有效元素的下标" class="headerlink" title="构造顺序表记录参数(顺序表的首地址 顺序表的容量 顺序表的有效元素的下标)"></a>构造顺序表记录参数(顺序表的首地址 顺序表的容量 顺序表的有效元素的下标)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sequenceList</span> &#123;</span></span><br><span class="line">    dataType_t *Addr;       <span class="comment">//顺序表的首地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;      <span class="comment">//顺序表的容量</span></span><br><span class="line">    <span class="type">int</span> last;               <span class="comment">//顺序表的有效元素的下标</span></span><br><span class="line">&#125; sqList_t;</span><br></pre></td></tr></table></figure><h2 id="创建顺序表并对顺序表进行初始化（sqList-Create）"><a href="#创建顺序表并对顺序表进行初始化（sqList-Create）" class="headerlink" title="创建顺序表并对顺序表进行初始化（sqList_Create）"></a>创建顺序表并对顺序表进行初始化（sqList_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sqList_t *<span class="title function_">sqList_Create</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 利用calloc为顺序表的管理结构体申请堆内存</span></span><br><span class="line">    sqList_t *manager = (sqList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (manager));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for manager is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 为所有元素申请堆内存 calloc,并完成错误处理</span></span><br><span class="line">    manager-&gt;Addr = (dataType_t*)<span class="built_in">calloc</span>(size,<span class="keyword">sizeof</span>(dataType_t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager-&gt;Addr)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for element is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(manager);  <span class="comment">//释放内存</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 对管理顺序表的结构体进行初始化（元素容量 最后元素下标）</span></span><br><span class="line">    manager-&gt;size = size; <span class="comment">//对顺序表的容量进行初始化</span></span><br><span class="line">    manager-&gt;last = <span class="number">-1</span>;   <span class="comment">//由于顺序表为空，则最后元素下标初值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序表是否以满（sqList-IsFull）"><a href="#判断顺序表是否以满（sqList-IsFull）" class="headerlink" title="判断顺序表是否以满（sqList_IsFull）"></a>判断顺序表是否以满（sqList_IsFull）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断顺序表是否以满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_IsFull</span><span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;last+<span class="number">1</span> == manager-&gt;size) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//        if(manager-&gt;last+1 == manager-&gt;size)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return ture;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return false;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（sqList-endAdd）"><a href="#尾插（sqList-endAdd）" class="headerlink" title="尾插（sqList_endAdd）"></a>尾插（sqList_endAdd）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向顺序表的尾部插入元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_endAdd</span> <span class="params">(sqList_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 判断顺序表是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceList is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 若顺序表有空闲空间，则把新元素添加到顺序表尾部</span></span><br><span class="line"><span class="comment">/*    manager-&gt;last++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span></span><br><span class="line">    manager-&gt;Addr[++manager-&gt;last] = data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（sqList-headAdd）"><a href="#头插（sqList-headAdd）" class="headerlink" title="头插（sqList_headAdd）"></a>头插（sqList_headAdd）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3 向顺序表的头部插入元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_headAdd</span> <span class="params">(sqList_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 判断顺序表是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceList is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 若顺序表有空闲空间，则把新元素添加到顺序表头部 顺序表中所以元素向后移动1个单位</span></span><br><span class="line"><span class="comment">/*    manager-&gt;last++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = manager-&gt;last;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i+<span class="number">1</span>] = manager-&gt;Addr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 把新元素放到顺序表的头部,并且更新管理结构体中的元素下标+1</span></span><br><span class="line">    manager-&gt;Addr[<span class="number">0</span>] = data;</span><br><span class="line">    manager-&gt;last++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断顺序表是否为空（sqList-IsEmpty）"><a href="#判断顺序表是否为空（sqList-IsEmpty）" class="headerlink" title="判断顺序表是否为空（sqList_IsEmpty）"></a>判断顺序表是否为空（sqList_IsEmpty）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断顺序表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_IsEmpty</span><span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;last == <span class="number">-1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定删除（sqList-delAdd）"><a href="#指定删除（sqList-delAdd）" class="headerlink" title="指定删除（sqList_delAdd）"></a>指定删除（sqList_delAdd）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4 向顺序表删除元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_delAdd</span> <span class="params">(sqList_t *manager,dataType_t destVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">-1</span>;     <span class="comment">//记录需要删除的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.1 判断顺序表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SequenceList is Empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 需要查找目标值是否在顺序表中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt;= manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果目标值与顺序表中的值相同</span></span><br><span class="line">        <span class="keyword">if</span>(destVal == manager-&gt;Addr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            temp=i;     <span class="comment">//把目标元素的下标备份到变量temp中</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果顺序表中没有目标值的元素则终止函数</span></span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;destval [%d] is not found\n&quot;</span>,destVal);</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.4 如果顺序表中有目标值的元素，则将该元素的后继元素向前移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = temp; i &lt; manager-&gt;last; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i] = manager-&gt;Addr[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.5 由于删掉一个元素，则顺序表有效元素下标减一</span></span><br><span class="line">    manager-&gt;last--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历顺序表（sqList-print）"><a href="#遍历顺序表（sqList-print）" class="headerlink" title="遍历顺序表（sqList_print）"></a>遍历顺序表（sqList_print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5 遍历顺序表中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqList_print</span> <span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element[%d]=%d\n&quot;</span>,i,manager-&gt;Addr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 创建顺序表</span></span><br><span class="line">    sqList_t *manager = sqList_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向顺序表尾部插入新元素</span></span><br><span class="line">    sqList_endAdd (manager,<span class="number">5</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">2</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">1</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">4</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//5 2 1 4 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4 向顺序表头部插入新元素</span></span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">4</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//8 8 4 8 5 2 1 4 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6 删除顺序表中元素</span></span><br><span class="line">    sqList_delAdd (manager,<span class="number">20</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">5</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">1</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//8 8 4 8 2 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Element[<span class="number">0</span>]=<span class="number">5</span></span><br><span class="line">Element[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line">Element[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">Element[<span class="number">3</span>]=<span class="number">4</span></span><br><span class="line">Element[<span class="number">4</span>]=<span class="number">6</span></span><br><span class="line"></span><br><span class="line">Element[<span class="number">0</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">1</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">2</span>]=<span class="number">4</span></span><br><span class="line">Element[<span class="number">3</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">4</span>]=<span class="number">5</span></span><br><span class="line">Element[<span class="number">5</span>]=<span class="number">2</span></span><br><span class="line">Element[<span class="number">6</span>]=<span class="number">1</span></span><br><span class="line">Element[<span class="number">7</span>]=<span class="number">4</span></span><br><span class="line">Element[<span class="number">8</span>]=<span class="number">6</span></span><br><span class="line"></span><br><span class="line">destval [<span class="number">20</span>] is not found</span><br><span class="line">Element[<span class="number">0</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">1</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">2</span>]=<span class="number">4</span></span><br><span class="line">Element[<span class="number">3</span>]=<span class="number">8</span></span><br><span class="line">Element[<span class="number">4</span>]=<span class="number">2</span></span><br><span class="line">Element[<span class="number">5</span>]=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造顺序表记录参数(顺序表的首地址 顺序表的容量 顺序表的有效元素的下标)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sequenceList</span> &#123;</span></span><br><span class="line">    dataType_t *Addr;       <span class="comment">//顺序表的首地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;      <span class="comment">//顺序表的容量</span></span><br><span class="line">    <span class="type">int</span> last;               <span class="comment">//顺序表的有效元素的下标</span></span><br><span class="line">&#125; sqList_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建顺序表并对顺序表进行初始化</span></span><br><span class="line">sqList_t *<span class="title function_">sqList_Create</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 利用calloc为顺序表的管理结构体申请堆内存</span></span><br><span class="line">    sqList_t *manager = (sqList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (manager));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for manager is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 为所有元素申请堆内存 calloc,并完成错误处理</span></span><br><span class="line">    manager-&gt;Addr = (dataType_t*)<span class="built_in">calloc</span>(size,<span class="keyword">sizeof</span>(dataType_t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == manager-&gt;Addr)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for element is failed&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(manager);  <span class="comment">//释放内存</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//程序终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 对管理顺序表的结构体进行初始化（元素容量 最后元素下标）</span></span><br><span class="line">    manager-&gt;size = size; <span class="comment">//对顺序表的容量进行初始化</span></span><br><span class="line">    manager-&gt;last = <span class="number">-1</span>;   <span class="comment">//由于顺序表为空，则最后元素下标初值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//判断顺序表是否以满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_IsFull</span><span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;last+<span class="number">1</span> == manager-&gt;size) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//        if(manager-&gt;last+1 == manager-&gt;size)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return ture;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return false;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 向顺序表的尾部插入元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_endAdd</span> <span class="params">(sqList_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 判断顺序表是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceList is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 若顺序表有空闲空间，则把新元素添加到顺序表尾部</span></span><br><span class="line"><span class="comment">/*    manager-&gt;last++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span></span><br><span class="line">    manager-&gt;Addr[++manager-&gt;last] = data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//3 向顺序表的头部插入元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_headAdd</span> <span class="params">(sqList_t *manager,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 判断顺序表是否以满</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsFull(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sequenceList is Full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 若顺序表有空闲空间，则把新元素添加到顺序表头部 顺序表中所以元素向后移动1个单位</span></span><br><span class="line"><span class="comment">/*    manager-&gt;last++;</span></span><br><span class="line"><span class="comment">    *(manager-&gt;Addr + manager-&gt;last) = data;*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = manager-&gt;last;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i+<span class="number">1</span>] = manager-&gt;Addr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 把新元素放到顺序表的头部,并且更新管理结构体中的元素下标+1</span></span><br><span class="line">    manager-&gt;Addr[<span class="number">0</span>] = data;</span><br><span class="line">    manager-&gt;last++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//判断顺序表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_IsEmpty</span><span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (manager-&gt;last == <span class="number">-1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//4 向顺序表删除元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sqList_delAdd</span> <span class="params">(sqList_t *manager,dataType_t destVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">-1</span>;     <span class="comment">//记录需要删除的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.1 判断顺序表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(sqList_IsEmpty(manager))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SequenceList is Empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 需要查找目标值是否在顺序表中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt;= manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果目标值与顺序表中的值相同</span></span><br><span class="line">        <span class="keyword">if</span>(destVal == manager-&gt;Addr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            temp=i;     <span class="comment">//把目标元素的下标备份到变量temp中</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果顺序表中没有目标值的元素则终止函数</span></span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;destval [%d] is not found\n&quot;</span>,destVal);</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.4 如果顺序表中有目标值的元素，则将该元素的后继元素向前移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = temp; i &lt; manager-&gt;last; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        manager-&gt;Addr[i] = manager-&gt;Addr[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.5 由于删掉一个元素，则顺序表有效元素下标减一</span></span><br><span class="line">    manager-&gt;last--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//5 遍历顺序表中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqList_print</span> <span class="params">(sqList_t *manager)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=manager-&gt;last;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element[%d]=%d\n&quot;</span>,i,manager-&gt;Addr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 创建顺序表</span></span><br><span class="line">    sqList_t *manager = sqList_Create(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 向顺序表尾部插入新元素</span></span><br><span class="line">    sqList_endAdd (manager,<span class="number">5</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">2</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">1</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">4</span>);</span><br><span class="line">    sqList_endAdd (manager,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//5 2 1 4 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4 向顺序表头部插入新元素</span></span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">4</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line">    sqList_headAdd (manager,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//8 8 4 8 5 2 1 4 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6 删除顺序表中元素</span></span><br><span class="line">    sqList_delAdd (manager,<span class="number">20</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">5</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">1</span>);</span><br><span class="line">    sqList_delAdd (manager,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7 遍历顺序表</span></span><br><span class="line">    sqList_print (manager);     <span class="comment">//8 8 4 8 2 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 一 顺序表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构三（双向链表DoubleLinkedList）</title>
      <link href="/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/"/>
      <url>/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 创建一个双向链表实现对双向链表内元素的<br> ——增加（头插 指定位置插入 尾插）<br> ——删除（头删 指定位置删除 尾删）<br> ——遍历双向链表</p><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表" title="双向链表"></p><p>More info: <a href="https://github.com/gybpersist/DoubleLinkedList">DoubleLinkedList</a></p><h2 id="构造双向链表（DoubleLinkedList）"><a href="#构造双向链表（DoubleLinkedList）" class="headerlink" title="构造双向链表（DoubleLinkedList）"></a>构造双向链表（DoubleLinkedList）</h2><h3 id="构造双向链表的结点-双向链表中所有结点的数据类型应该是相同的"><a href="#构造双向链表的结点-双向链表中所有结点的数据类型应该是相同的" class="headerlink" title="构造双向链表的结点 双向链表中所有结点的数据类型应该是相同的"></a>构造双向链表的结点 双向链表中所有结点的数据类型应该是相同的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//双向链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> *<span class="title">prev</span>;</span>      <span class="comment">//双向链表的后继指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//双向链表的前驱指针域</span></span><br><span class="line">&#125; DoubleLList_t;</span><br></pre></td></tr></table></figure><h2 id="创建一个空链表，空链表应该有一个头结点（DoubleLList-Create）"><a href="#创建一个空链表，空链表应该有一个头结点（DoubleLList-Create）" class="headerlink" title="创建一个空链表，空链表应该有一个头结点（DoubleLList_Create）"></a>创建一个空链表，空链表应该有一个头结点（DoubleLList_Create）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t* <span class="title function_">DoubleLList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化</span></span><br><span class="line">    Head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    Head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleLList-NewNode）"><a href="#创建新的结点，并对新结点进行初始化（数据域-指针域）（DoubleLList-NewNode）" class="headerlink" title="创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleLList_NewNode）"></a>创建新的结点，并对新结点进行初始化（数据域 指针域）（DoubleLList_NewNode）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DoubleLList_t *<span class="title function_">DoubleLList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域2个）</span></span><br><span class="line">    NewNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头插（DoubleLList-HeadInsert）"><a href="#头插（DoubleLList-HeadInsert）" class="headerlink" title="头插（DoubleLList_HeadInsert）"></a>头插（DoubleLList_HeadInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%A4%B4%E6%8F%92.png" alt="头插" title="头插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_HeadInsert</span><span class="params">(DoubleLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line">    NewNode-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾插（DoubleLList-TailInsert）"><a href="#尾插（DoubleLList-TailInsert）" class="headerlink" title="尾插（DoubleLList_TailInsert）"></a>尾插（DoubleLList_TailInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%B0%BE%E6%8F%92.png" alt="尾插" title="尾插"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_TailInsert</span><span class="params">(DoubleLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定插入（DoubleLList-DestInsert）"><a href="#指定插入（DoubleLList-DestInsert）" class="headerlink" title="指定插入（DoubleLList_DestInsert）"></a>指定插入（DoubleLList_DestInsert）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E6%8C%87%E5%AE%9A%E6%8F%92%E5%85%A5.png" alt="指定插入" title="指定插入"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_DestInsert</span><span class="params">(DoubleLList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;prev = Head;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != <span class="literal">NULL</span> &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表（DoubleLList-Print）"><a href="#遍历链表（DoubleLList-Print）" class="headerlink" title="遍历链表（DoubleLList_Print）"></a>遍历链表（DoubleLList_Print）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_Print</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点的地址进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头删-删除首结点（DoubleLList-HeadDel）"><a href="#头删-删除首结点（DoubleLList-HeadDel）" class="headerlink" title="头删 删除首结点（DoubleLList_HeadDel）"></a>头删 删除首结点（DoubleLList_HeadDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%A4%B4%E5%88%A0.png" alt="头删" title="头删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_HeadDel</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Phead-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾删-删除尾结点（DoubleLList-TailDel）"><a href="#尾删-删除尾结点（DoubleLList-TailDel）" class="headerlink" title="尾删 删除尾结点（DoubleLList_TailDel）"></a>尾删 删除尾结点（DoubleLList_TailDel）</h2><p>  <img src="/img/%E6%96%87%E7%AB%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8DoubleLinkedList%EF%BC%89/%E5%B0%BE%E5%88%A0.png" alt="尾删" title="尾删"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_TailDel</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 记录当前结点的地址</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    DoubleLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main主程序"><a href="#main主程序" class="headerlink" title="main主程序"></a>main主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DoubleLList_t *Head = DoubleLList_Create();            <span class="comment">//创建链表</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        <span class="comment">//3 6 1 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        <span class="comment">//3 6 1 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">Date[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Date[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">Date[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Date[<span class="number">3</span>] = <span class="number">9</span></span><br><span class="line">Date[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">Date[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> dataType_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//构造双向链表的结点 双向链表中所以结点的数据类型应该是相同的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> &#123;</span></span><br><span class="line">    dataType_t data;                 <span class="comment">//双向链表的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> *<span class="title">prev</span>;</span>      <span class="comment">//双向链表的后继指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span> *<span class="title">next</span>;</span>      <span class="comment">//双向链表的前驱指针域</span></span><br><span class="line">&#125; DoubleLList_t;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1 创建一个空链表，空链表应该有一个头结点</span></span><br><span class="line">DoubleLList_t* <span class="title function_">DoubleLList_Create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.1 创建一个头结点并给头结点申请内存</span></span><br><span class="line">    DoubleLList_t *Head = (DoubleLList_t*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for Head is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);       <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2 对头结点进行初始化</span></span><br><span class="line">    Head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    Head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.3 把头结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//2 创建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">DoubleLList_t *<span class="title function_">DoubleLList_NewNode</span><span class="params">(dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.1 创建一个新结点并给新结点申请内存</span></span><br><span class="line">    DoubleLList_t *NewNode = (DoubleLList_t *) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(DoubleLList_t));</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;calloc memory for NewNode is Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 对新结点进行初始化（数据域 指针域2个）</span></span><br><span class="line">    NewNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    NewNode-&gt;data = data;</span><br><span class="line">    NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 把新结点地地址返回</span></span><br><span class="line">    <span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//3 在链表中 头插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_HeadInsert</span><span class="params">(DoubleLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        NewNode-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 新节点是链表最后一个节点，next 指针置为 NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 如果链表为非空，则把新结点插入到链表头部</span></span><br><span class="line">    NewNode-&gt;next = Head-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = NewNode;</span><br><span class="line">    Head-&gt;next = NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//4 在链表中 尾部插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_TailInsert</span><span class="params">(DoubleLList_t *Head,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 如果链表为非空，则把新结点插入到链表尾部</span></span><br><span class="line">    <span class="comment">//对链表的头结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//5 在链表中 指定插入</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_DestInsert</span><span class="params">(DoubleLList_t *Head,dataType_t destval,dataType_t data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5.1 建新的结点，并对新结点进行初始化（数据域 指针域）</span></span><br><span class="line">    DoubleLList_t *NewNode = DoubleLList_NewNode(data);</span><br><span class="line">    <span class="keyword">if</span>(NewNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can not insert new node!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 判断链表是否为空，如果为则直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;next= NewNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3 如果链表为非空，遍历链表，找到目标结点（比较数据域）</span></span><br><span class="line">    <span class="comment">//对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (Phead != <span class="literal">NULL</span> &amp;&amp; destval != Phead-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把结点的直接后继作为新的结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Phead == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.4 说明找到目标结点，则把新结点加入到目标结点后面</span></span><br><span class="line">    NewNode-&gt;next=Phead-&gt;next;</span><br><span class="line">    Phead-&gt;next-&gt;prev = NewNode;</span><br><span class="line"></span><br><span class="line">    NewNode-&gt;prev = Phead;</span><br><span class="line">    Phead-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//6 遍历链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_Print</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对链表的头结点的地址进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表是否为空，为空则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current linkedList is empty!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前链表不为空则继续遍历</span></span><br><span class="line">    <span class="comment">//记录第几个</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出头结点的直接后继的数据域</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Date[%d] = %d\n&quot;</span>,i,Phead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//7 头删 删除首结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_HeadDel</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//7.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.2 对链表的首结点进行备份</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.3 链表非空 删除首结点</span></span><br><span class="line">    Head-&gt;next = Head-&gt;next-&gt;next;</span><br><span class="line">    Head-&gt;next-&gt;prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.4 原先首结点的 next指向NULL，并释放首结点的内存</span></span><br><span class="line">    Phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Phead-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//8 尾删 删除尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DoubleLList_TailDel</span><span class="params">(DoubleLList_t *Head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8.1 判断判断链表是否为空，如果为则直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(Head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.2 记录当前结点的地址</span></span><br><span class="line">    DoubleLList_t *Phead = Head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前结点的直接前驱</span></span><br><span class="line">    DoubleLList_t *Phead_Prev = Head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.3 链表非空 删除尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (Phead-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把头结点的直接后继作为新的头结点 指针向后移一位</span></span><br><span class="line">        Phead_Prev = Phead;</span><br><span class="line">        Phead = Phead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Phead_Prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Phead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DoubleLList_t *Head = DoubleLList_Create();            <span class="comment">//创建链表</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">5</span>);            <span class="comment">//头插</span></span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">8</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">1</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">6</span>);</span><br><span class="line">    DoubleLList_HeadInsert(Head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        <span class="comment">//3 6 1 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailInsert(Head,<span class="number">4</span>);               <span class="comment">//尾插</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                        <span class="comment">//3 6 1 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_DestInsert(Head,<span class="number">1</span>,<span class="number">9</span>);     <span class="comment">//destval后面插入</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 3 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_HeadDel(Head);                        <span class="comment">//头删</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DoubleLList_TailDel(Head);                        <span class="comment">//尾删</span></span><br><span class="line"></span><br><span class="line">    DoubleLList_Print(Head);                         <span class="comment">//遍历链表 6 1 9 8 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 三 双向链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 双向链表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
